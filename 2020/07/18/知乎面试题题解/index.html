<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
    
  
  <link href="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css" />







  

<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.2/css/font-awesome.min.css" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/Favicon.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="什么是bean的自动装配？  组件扫描(component scanning):Spring会自动发现应用上下文中所创建的Bean。 自动装配(autowiring):Spring自动满足bean之间的依赖。   解释不同方式的自动装配 。 Spring实战中说明的是有三种注入方式，但是其他的书籍有两种装配方式把JavaConfig和自动装配当成同一种。  基于XML的装配 基于注解的装配–Ja">
<meta property="og:type" content="article">
<meta property="og:title" content="知乎面试题题解">
<meta property="og:url" content="http://forhcl.github.io/2020/07/18/%E7%9F%A5%E4%B9%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E9%A2%98%E8%A7%A3/index.html">
<meta property="og:site_name" content="Hogan&#39;Blog">
<meta property="og:description" content="什么是bean的自动装配？  组件扫描(component scanning):Spring会自动发现应用上下文中所创建的Bean。 自动装配(autowiring):Spring自动满足bean之间的依赖。   解释不同方式的自动装配 。 Spring实战中说明的是有三种注入方式，但是其他的书籍有两种装配方式把JavaConfig和自动装配当成同一种。  基于XML的装配 基于注解的装配–Ja">
<meta property="og:image" content="g:/Blog/source/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="http://forhcl.github.io/2020/07/18/%E7%9F%A5%E4%B9%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E9%A2%98%E8%A7%A3/IP%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB.png">
<meta property="og:image" content="http://forhcl.github.io/2020/07/18/%E7%9F%A5%E4%B9%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E9%A2%98%E8%A7%A3/%E8%BF%90%E8%BE%93%E5%B1%82%E5%92%8C%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%AF%B9%E5%BA%94.png">
<meta property="article:published_time" content="2020-07-18T00:20:01.339Z">
<meta property="article:modified_time" content="2020-05-21T02:22:32.649Z">
<meta property="article:author" content="Hogan Lee">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="g:/Blog/source/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://forhcl.github.io/2020/07/18/知乎面试题题解/"/>





  <title>知乎面试题题解 | Hogan'Blog</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hogan'Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://forhcl.github.io/2020/07/18/%E7%9F%A5%E4%B9%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hogan Lee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hogan'Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">知乎面试题题解</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-18T08:20:01+08:00">
                2020-07-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <ul>
<li><p>什么是bean的自动装配？</p>
<ul>
<li>组件扫描(component scanning):Spring会自动发现应用上下文中所创建的Bean。</li>
<li>自动装配(autowiring):Spring自动满足bean之间的依赖。</li>
</ul>
</li>
<li><p>解释不同方式的自动装配 。</p>
<p>Spring实战中说明的是有三种注入方式，但是其他的书籍有两种装配方式把JavaConfig和自动装配当成同一种。</p>
<ul>
<li>基于XML的装配</li>
<li>基于注解的装配–JavaConfig</li>
<li>自动装配</li>
</ul>
</li>
<li><p>自动装配有哪些局限性 ?</p>
<p>自动装配的局限性就是如果一个接口有很多的实现类，可能在装配过程中会产生歧义性。Spring中可以通过指定各个实现类的优先级来解决。</p>
</li>
<li><p>如何将一个Java对象序列化到文件里？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> serialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于序列化的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hogan_Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-01-15 19:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Instance</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1307803802596986433L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"使用"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> serialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hogan_Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-01-15 19:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Serialize</span> </span>&#123;</span><br><span class="line">    <span class="comment">//序列化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSerialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//指定序列化之后存储的位置</span></span><br><span class="line">        <span class="keyword">try</span> (ObjectOutputStream outputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"G:\\Print.txt"</span>))) &#123;</span><br><span class="line">            <span class="comment">//序列化对象</span></span><br><span class="line">            outputStream.writeObject(<span class="keyword">new</span> Instance());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反序列化</span></span><br><span class="line">    <span class="comment">//查看资料显示反序列化的底层是使用反射实现的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">deSerialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Instance instance = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//指定用于反序列化的文件</span></span><br><span class="line">        <span class="keyword">try</span> (ObjectInputStream inputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"G:\\Print.txt"</span>))) &#123;</span><br><span class="line">            <span class="comment">//引用反序列化后生成的对象</span></span><br><span class="line">            instance = (Instance) inputStream.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        doSerialize();</span><br><span class="line">        deSerialize().print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>说说你对Java反射的理解</p>
<p>动态加载和静态加载</p>
</li>
<li><p>说说你对依赖注入的理解</p>
<p>DI(Dependency Injection)依赖注入的概念，就是在Spring创建这个对象的过程中，将这个对象所依赖的属性注入进去，从而实现应用对象之间协作关系的协调，让相互协作的软件组件保持松耦合。简单的说就是Spring又想使用这个对象，又不想自己创建这个对象，然后交给Spring容器代为创建，用到的时候就作为一个恬不知耻的伸手党。当然我们在运行Spring容器的时候要先加载容器上下文，要不然Spring要不到这些对象，就会到处都是空指针异常。</p>
<p><strong>在普通的Java应用程序中，应用程序被分解成为类，其中每个类与应用程序中的其他类经常有明显的联系，这些联系是在代码中直接调用类的构造器，一旦代码被编译，这些联系点将无法修改。</strong><br><strong>这在大型项目中是有问题的，因为这些外部联系是脆弱的，并且进行修改可能会对其他下游代码造成多重影响。依赖注入框架（如Spring），允许用户通过约定（以及注解）将应用程序对象之间的关系外部化，而不是在对象内部彼此硬编码实例化代码，以便更轻松地管理大型Java项目。Spring在应用程序的不同的Java类之间充当一个中间人，管理着它们的依赖关系。Spring本质上就是让用户像玩乐高积木一样将自己的代码组装在一起。</strong></p>
</li>
</ul>
<p>下面的这11道题到博客中找，有答案</p>
<ul>
<li><p>java中==和equals和hashCode的区别</p>
</li>
<li><p>int与integer的区别</p>
</li>
<li><p>a=a+b与a+=b有什么区别吗?</p>
</li>
<li><p>run()和start()方法区别</p>
</li>
<li><p>实现生产者消费者模式</p>
</li>
<li><p>用Java写一个会导致死锁的程序，你将怎么解决？</p>
</li>
<li><p>死锁的四个必要条件？</p>
</li>
<li><p>静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？</p>
</li>
<li><p>Object类的equal和hashCode方法重写，为什么？</p>
</li>
<li><p>Java的异常体系</p>
</li>
<li><p>什么是异常链</p>
</li>
</ul>
<ul>
<li><p>有哪些不同类型的IOC（依赖注入）方式？</p>
<p>构造注入和设值注入。</p>
</li>
<li><p>TCP与UDP的区别</p>
<p>TCP和UDP是计算机网络中传输层的两个不同的协议，它们之间主要有以下几个区别：</p>
<ul>
<li>TCP是面向连接的，也就是传输数据之前会创建一个逻辑连接，然后传输数据之后会把这个连接释放掉。而UDP是面向非连接的</li>
<li>TCP有超时重传、滑动窗口等机制保证数据传输的可靠性，但是UDP就没有</li>
<li>TCP在接收数据的时候会对报文段就行重排序，UDP则没有</li>
<li>速度上来说，TCP因为要建立连接保证数据传输的可靠性和有序性，从速度上来说相比UDP会慢很多</li>
<li>量级不一样，主要体现在首部字段TCP有20个字节，而UDP只有8个字节</li>
<li>数据传输的基本单位不同：TCP-报文段  UDP-用户数据报</li>
</ul>
</li>
<li><p>ARP是地址解析协议，简单语言解释一下工作原理。</p>
<p>&emsp;&emsp;每台主机上都有一个ARP高速缓存，里面维护着一个本局域网中其他主机物理地址和Ip地址的对应，但主机要和其它主机通信的时候就会在该表中查看。但是如果查不到，比如主机刚通电，缓存中不存在数据，这时候就会向该局域网中的其他主机广播发一个ARP请求分组，里面有着要通信主机的IP地址，其它主机接收到这个请求分组之后，如果是请求分组中的IP主机，就会回单播一个ARP响应分组，如果不是就刷新ARP高速缓存，不做响应。如果找不到就扔给路由器的处理。</p>
</li>
<li><p>throw和throws的区别？</p>
<p>throw是在方法体中明确地抛出一个异常。而throws是在方法声明时抛出抛出未被try-catch语句块捕获处理的异常。抛到调用该方法的方法中，由它来对异常进行进一步的处理。继续抛出，或者try-catch处理 。</p>
</li>
<li><p>同步方法和同步块，哪个是更好的选择？</p>
<p>同步块，因为同步方法中可能存在一些不需要同步的代码块，盲目地将所有代码进行同步，可能会降低执行性能。</p>
</li>
<li><p>为什么TCP连接需要三次握手，两次不可以吗？为什么？</p>
<p>我认为主要有以下两个方面的原因：</p>
<ol>
<li><p>首先要确认通信双方的通信能力</p>
<p>注意：有两个确认主体，需要明确双方的通信能力</p>
</li>
<li><p>防止产生脏数据连接</p>
</li>
</ol>
</li>
<li><p>OSI网络体系与TCP/IP协议模型</p>
<p>&emsp;&emsp;学习计算机网络原理时我们一般采用折中的办法，即综合 <code>OSI</code> 和 <code>TCP/IP</code> 的优点，采用一种只有五层协议的原理体系结构，这样既简洁又能将概念阐述清楚。</p>


<p><img src="G:/Blog/source/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt=""></p>
<ol>
<li><p>物理层</p>
<p>物理层传送数据的单位是比特(0或1)。物理层的作用是在连接各种计算机的传输媒体上传输比特流，而不是指具体的传输媒体；并且尽可能地屏蔽掉具体传输介质和物理设备的差异，使其上面的数据链路层不必考虑网络具体的传输媒体是什么。注意：传递信息所利用的一些物理传输媒体本身是在物理层的下面，并不属于物理层的范围，因此也有人把传输媒体当作第0层。</p>
</li>
<li><p>数据链路层（帧）</p>
<p>在相邻结点之间（主机和路由器之间或两个路由器之间）的链路上传送以帧为单位的数据。</p>
</li>
<li><p>网络层</p>
<p>为主机之间提供逻辑通信</p>
</li>
<li><p>运输层</p>
<p>为应用进程之间提供端到端的逻辑通信</p>
</li>
<li><p>应用层</p>
<p>通过应用进程间的交互来完成特定的网络应用。</p>
</li>
</ol>
</li>
<li><p>Java中实现多态的机制是什么？方法重写和重载的原理？</p>
<p>Java中的多态主要体现在两个方面，第一个方法的重载，第二个方法的重写。</p>
<p>条件：要有继承关系，父类类型的变量指向子类类型的实例，子类重写父类的方法。</p>
<p>A b=new B();</p>
<p>这里的A就是静态类型，编译阶段可以确定；</p>
<p>B就是实际类型，只能运行阶段才能确定。</p>
<p>1.重载（overload）方法<br><strong>对重载方法的调用主要看静态类型，静态类型是什么类型，就调用什么类型的参数方法。</strong><br>2.重写（override）方法<br><strong>对重写方法的调用主要看实际类型。实际类型如果实现了该方法则直接调用该方法，如果没有实现，则在继承关系中从低到高搜索有无实现。编译看左边，运行看右边</strong> 方法的动态绑定</p>
</li>
<li><p>什么是Daemon线程？它有什么意义？</p>
<p>在Java线程中有两种线程，一种是用户线程，另外一种就是守护（Deamon）线程。默认我们创建的线程都是用户线程。</p>
<p>比如一个国家，军队就是它的守护线程。当国家不存在守护线程就没有存在的必要了。比如Java中的内存回收线程GC</p>
</li>
<li><p>在Java中守护线程和用户线程的区别？</p>
<p>我认为守护线程和用户线程唯一的区别就是当Jvm中不存在用户线程的时候，守护线程就会自动退出。其它就没有区别了</p>
</li>
<li><p>选择排序</p>
</li>
<li><p>冒泡排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="comment">//参数校验</span></span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span>&amp;&amp;nums.length==<span class="number">0</span>&amp;&amp;nums.length==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//控制冒几轮泡</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//优化：当次循环是否发生交换</span></span><br><span class="line">        <span class="keyword">boolean</span> isSwap=<span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//两两冒泡,每一轮需要冒几次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;nums.length-i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j-<span class="number">1</span>]&lt;nums[j])&#123;</span><br><span class="line">                <span class="keyword">int</span> k=nums[j];</span><br><span class="line">                num[j]=num[j-<span class="number">1</span>];</span><br><span class="line">                num[j-<span class="number">1</span>]=k;</span><br><span class="line">                <span class="comment">//优化：如果这一轮发生冒泡，就置为true</span></span><br><span class="line">                isSwap=<span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//优化：通过设置标志，当确认排好序之后尽快跳出循环</span></span><br><span class="line">        <span class="comment">//节省时间，优化性能</span></span><br><span class="line">        <span class="keyword">if</span>(isSwap=<span class="keyword">false</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>谈谈SQL注入</p>
<p>&emsp;&emsp;SQL注入是发生于应用程序与数据库层的安全漏洞。简而言之，是在<strong>输入的字符串之中注入SQL指令</strong>，在设计不良的程序当中忽略了字符检查，那么这些注入进去的恶意指令就会被数据库服务器误认为是正常的SQL指令而运行，因此遭到破坏或是入侵。</p>
</li>
<li><p>数组和链表之间的区别</p>
<p>&emsp;&emsp;最底层的区别就是数组是顺序存储结构，存储空间是连续的。而链表是链式存储结构，存储空间不是连续的。针对于存储空间的分配不同导致了它们在使用场景上的不同，数据可以根据下标进行随机索引，比较适合与下标有语义的情况，但是当要进行增加删除的时候需要对增加或删除位置之后的元素进行后移或者前移，每次都这样子做，过于浪费时间。但是链表只需要改变前后指针的指向就能很容易实现元素的添加或者删除。</p>
</li>
<li><p>Java中String类型的理解</p>
<ol>
<li><p>String类型底层是一个char类型的字符数组。</p>
</li>
<li><p>然后String类型是一个不可变的字符串，主要体现在String类上和底层char字符串上都加了final关键字。字符串一旦创建就不可变，任何改变字符串的操作最终都会生成一个新的对象。</p>
</li>
<li><p>最后一个比较值得说的就是String常量池，String类的对象有两种创建方式=和new</p>
<p>=是直接在常量池中创建字符串。而new是在堆中创建如果常量池里面不存在会在常量池中再创建一个。对于字符串拼接的只认字符不认变量，变量会new新建。</p>
</li>
</ol>
</li>
<li><p>String为什么要设计成不可变的？</p>
<p>常量池设计的需要</p>
<p>安全性，经常作为集合的键，使用到hashcode对比。如果可变的话，会引起很多安全隐患</p>
</li>
<li><p>Collection 和Collections 的区别？</p>
<p>Collection是集合类的上级接口，继承与他有关的接口主要有List和Set</p>
<p>Collections是针对集合类的一个工具类，类似于数组的Arrays吧，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全等操作</p>
</li>
<li><p>怎么检测一个线程是否拥有锁？</p>
<p>wait抛出异常！！</p>
<p>或者一个不常用的方法holdsLock(Object obj)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">    System.out.println(<span class="string">"进入task同步块 :"</span> + System.currentTimeMillis());</span><br><span class="line">    System.out.println(<span class="string">"新线程检测　lock = "</span> + Thread.holdsLock(lock));</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception ex)&#123;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"退出task同步块 :"</span> + System.currentTimeMillis());</span><br></pre></td></tr></table></figure>
</li>
<li><p>有了唯一的Mac地址为啥还需要IP地址？为每一台主机分配了唯一的IP地址，为什么还要物理地址？</p>
</li>
<li><p>DDos 攻击</p>
<p><strong>拒绝服务攻击</strong>（英语：denial-of-service attack，简称<strong>DoS攻击</strong>）亦称<strong>洪水攻击</strong>，是一种<a href="https://zh.wikipedia.org/wiki/網絡攻擊" target="_blank" rel="noopener">网络攻击</a>手法，其目的在于使目标电脑的<a href="https://zh.wikipedia.org/wiki/網際網路" target="_blank" rel="noopener">网络</a>或<a href="https://zh.wikipedia.org/wiki/系統" target="_blank" rel="noopener">系统</a>资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。</p>
<p>简单的说，就是好多肉鸡群殴。让它无暇顾及其它事情</p>
<p>主要是针对与TCP协议的攻击，就是请求连接但不确认连接。但是服务器端会等一会，一群肉鸡群殴，让它一直等。</p>
</li>
<li><p>DDos攻击的预防</p>
</li>
<li><p>什么是Bean的装配</p>
<p>在Spring中，当要使用到某个对象的时候不是自己创建，而是由Spring容器创建然后满足bean之间的依赖关系</p>
</li>
<li><p>如何开启注解装配？</p>
<p>在配置类中@componentScan注解，指定要装配的包。它会扫描应用上下文中的组件。</p>
</li>
<li><p>谈谈@Required、 @Autowired、 @Qualifier注解。</p>
<p>这三个注解都是Spring中用来满足组件之间依赖关系的</p>
<p>@Required 只能用于setter方法，找不到参数的bean就会抛出异常。和另外两个注解任意一个一起使用</p>
<p>@Autowired 按类型注入</p>
<p>@Qualifier 按名称注入</p>
</li>
<li><p>数据库范式</p>
</li>
<li><p>插入排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InsertionSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="comment">//假设第一个已经排好序，需要插入的次数为</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//保存未排序序列第一个元素的值</span></span><br><span class="line">        <span class="keyword">int</span> value=nums[i+<span class="number">1</span>]；</span><br><span class="line">        <span class="keyword">int</span> j=i;</span><br><span class="line">        <span class="comment">//获得要插入元素位置的下标j</span></span><br><span class="line">        <span class="keyword">for</span>(;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="comment">//决定升序还是降序</span></span><br><span class="line">            <span class="keyword">if</span>(value&gt;nums[j])</span><br><span class="line">                <span class="comment">//将已排序序列中插入元素位置后面的元素后移 </span></span><br><span class="line">                nums[j+<span class="number">1</span>]=nums[j];</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="comment">//将要插入的元素插入</span></span><br><span class="line">        nums[j]=value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>IP地址的分类</p>
<p><strong>分类编址方式将IP地址划分为若干固定类，每一类地址都由两个固定长度的字段组成，其中一个是网络号</strong>(net-id)，它标志主机(或路由器)所连接到的网络。一个网络号在整个因特网范围内必须是唯一的。<strong>第二个字段是主机号</strong>(host-id)，它标志该主机(或路由器)。一个主机号在它前面的网络号所指明的网络范围内必须是唯一的，由此可见，一个IP地址在整个因特网范围内是唯一的。</p>
<p>IP地址::={&lt;网络号&gt;,&lt;主机号&gt;}</p>
<p>这种两级编址方式的好处是：第一，IP 地址管理机构在分配 IP 地址时只分配网络号（第一级），而剩下的主机号（第二级）则由得到该网络号的单位自行分配。这样就方便了IP地址的管理。第二，路由器仅根据目的主机所连接的网络号来转发分组（而不考虑目的主机号），这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所占的存储空间及查找路由表的时间。</p>
<p><img src="IP%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB.png" alt=""></p>
<p>● A 类、B 类和 C 类地址的网络号字段（在图中这个字段是灰色的）分别为 1，2 和 3 字节长，而在网络号字段的最前面有1∼3位的类别位，其数值分别规定为0，10和110。<br>● A 类、B 类和 C 类地址的主机号字段分别为 3 个、2 个和 1 个字节长。<br>● D 类地址（前 4 位是 1110）用于多播（一对多通信）。<br>● E 类地址（前 4 位是 1111）保留为以后用。</p>
</li>
<li><p>TCP和UDP分别对应的常见应用层协议</p>
<p><img src="%E8%BF%90%E8%BE%93%E5%B1%82%E5%92%8C%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%AF%B9%E5%BA%94.png" alt=""></p>
</li>
<li><p>使用Spring框架的好处</p>
<ol>
<li><p>低耦合</p>
<p>通过Spring容器创建Bean，满足Bean之间的依赖关系，降低了组件之间的耦合</p>
</li>
<li><p>高内聚</p>
<p>AOP能很好的将业务逻辑和系统服务分离</p>
</li>
<li><p>轻量级、非侵入式</p>
</li>
<li><p>统一异常处理</p>
</li>
<li><p>方便集成其它优秀的框架</p>
</li>
</ol>
</li>
<li><p>常见的状态码及原因短语</p>
<p>状态码（Status-Code）都是三位数字的，分为5大类共33种。例如：<br>1xx表示通知信息的，如请求收到了或正在进行处理；<br>2xx表示成功，如接受或知道了；<br>3xx表示重定向，表示要完成请求还必须采取进一步的行动；<br>4xx表示客户的差错，如请求中有错误的语法或不能完成；<br>5xx表示服务器的差错，如服务器失效无法完成请求。</p>
<p>200 400 403 404 500</p>
<p>一般也记不了这么多，但是在Spring.web的Jar包里有一个HttpStatus的类，里面有所有的状态码和相关解释说明，有不认识状态码我会直接去查看这个类的源码</p>
</li>
<li><p>Comparable和Comparator接口有何区别？</p>
<p>Comparable是让我们创建的对象变成一个可比较的对象</p>
<p>Comparator是另外创建一个比较器，在比较的时候和要比较的类一起作为参数传入，和设计原则中说的不修改源代码适应吧</p>
</li>
<li><p>Array和ArrayList有何区别？什么时候更适合用Array</p>
<p>Array是数组，可以存储引用类型或基本类型的元素，固定大小。</p>
<p>ArrayList是列表，只能存储引用类型的元素，当然基本类型会自动转型，大小可变。</p>
<p><strong>当存储基本类型且固定大小的情况选择数组，其它情况选择ArrayList</strong></p>
</li>
<li><p>Iterator类有什么作用?</p>
<p>迭代器，用于遍历集合</p>
</li>
<li><p>线程之间是如何通信的？</p>
<p>共享内存</p>
</li>
<li><p>Java中的四种引用</p>
<p><strong>四种引用类型</strong></p>
<p>&emsp;&emsp;JDK1.2之前，一个对象只有“已被引用”和“未被引用”两种状态，这将无法描述某些特殊情况下的对象，比如，当内存充足时需要保留，而内存紧张时才需要被抛弃的一类对象。</p>
<p>&emsp;&emsp;所以在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为了：强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)4种，这四种引用的强度依次减弱。</p>
<ol>
<li><p>强引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只要obj还指向new Object()实例对象，Object实例对象就不会被回收</span></span><br><span class="line">Object obj=<span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">//显式将obj置为null，过一会new Object()实例对象就会被回收</span></span><br><span class="line">obj=<span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足时，JVM也会直接抛出OutOfMemoryError，不会去回收。如果想中断强引用与对象之间的联系，可以显式的将强引用赋值为null，这样一来，JVM就可以适时的回收对象了。</p>
</li>
<li><p>软引用</p>
<p>软引用是用来描述一些非必要但仍有用的对象。在内存足够的时候，软引用对象不会被回收，只有在内存不足的时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。这种特性常常被用来实现缓存技术，如网页缓存、图片缓存等。</p>
<p>在JDK1.2之后，用java.lang.ref.SoftReference类来表示软引用。</p>
</li>
<li><p>弱引用</p>
<p>弱引用的引用强度比软引用更弱一些，无论内存是否足够，只要JVM开始进行垃圾回收，那些被弱引用关联的对象都会被回收。在JDK1.2之后，用java.lang.ref.WeakReference来表示弱引用。</p>
</li>
<li><p>虚引用</p>
<p>虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收，在JDK1.2之后，用PhantomReference类来表示，通过查看这个类的源码，发现它只有一个构造函数和一个get()方法，而且它的get()方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象，虚引用必须要和ReferenceQueue引用队列一起使用。</p>
</li>
</ol>
</li>
<li><p>String转换成Integer的方式和原理</p>
<ol>
<li><p>Integer.parseInt(“23”)</p>
</li>
<li><p>Integer.valueOf(“23”)</p>
<p>原理不是很清楚，琢磨源码吧</p>
</li>
</ol>
</li>
<li><p>final，finally，finalize的区别</p>
<p>final关键字，表示常量。修饰基本类型变量的时候表示值不可以被改变，修饰引用类型的变量的时候，表示引用的实例地址不可以改变，但实例对象内部内容是可以改变的。修饰类，表示类不可以被继承。修饰方法表示方法不可以被重写。</p>
<p>finally是异常处理的try-catch-finally语句块中的一部分，表示总会被执行。finally中如果抛出异常或者有返回值，会覆盖掉try或catch块中的返回值或异常。</p>
<p>finalize是Object中的一个方法，一旦垃圾收集器准备好释放对象占用的存储空间，它首先调用finalize()，而且只有在下一次垃圾收集过程中，才会真正回收对象的内存。子类可以通过重写这个方法来释放系统资源或者做一些其他的清理工作，但是一般我们会在try-with-resource或try-finally进行资源释放工作。深入理解Java虚拟机一书中，作者建议我们要避免使用它，因为它并不能等同于C和C++语言中的析构函数，而是Java刚诞生时为了使传统C、C++程序员更容易接受Java所做出的一项妥协。<strong>它的运行代价高昂，不确定性大。无法保证各个对象的调用顺序</strong>，如今已被官方明确声明为不推荐使用的语法。有些教材中描述它适合做“关闭外部资源”之类的清理性工作，这完全是对finalize()方法用途的一种自我安慰。finalize()能做的所有工作，使用try-finally或者其他方式都可以做得更好、更及时。</p>
</li>
<li><p>你对String对象的intern()熟悉么?</p>
<p>看了一下源码，这是一个本地方法。也就是由其它语言编写的方法。</p>
</li>
<li><p>同一个类里面两个synchronized方法，两个线程同时访问的问题？</p>
<p>分为三种情况</p>
<ol>
<li><p>两个方法都是实例方法</p>
<p>同一个实例中两个线程池同步，不同实例中两个线程异步。</p>
</li>
<li><p>两个方法都是静态方法</p>
<p>一直同步</p>
</li>
<li><p>一个方法是实例方法，一个方法是类方法</p>
<p>对象锁和类锁是否会互相影响？不会互相影响，所以一直异步</p>
</li>
</ol>
</li>
<li><p>什么是可重入锁（ReentrantLock）？</p>
<p>广义上的可重入锁指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁（前提得是同一个对象或者class），这样的锁就叫做可重入锁。ReentrantLock和synchronized都是可重入锁，下面是一个用synchronized实现的例子：</p>
<pre><code>public class ReentrantTest implements Runnable {
public synchronized void get() {
    System.out.println(Thread.currentThread().getName());
    set();
}

public synchronized void set() {
    System.out.println(Thread.currentThread().getName());
}

public void run() {
    get();
}

public static void main(String[] args) {
    ReentrantTest rt = new ReentrantTest();
    for(;;){
        new Thread(rt).start();
    }
}
}</code></pre></li>
<li><p>Thread类中的yield方法有什么作用？</p>
<p>这个方法日常很少使用到，书上说是线程的礼让，调用该方法之后会暂停线程，然后重新和就绪状态的高优先级或相同优先级的线程重新争夺cpu时间，如果非说它有用的话，我认为就是避免一个线程长时间的霸占cpu，让其它的线程也有机会上位。</p>
</li>
<li><p>抽象类的意义</p>
<ol>
<li>代码复用（一般方法），既然它是一个类而且是专门设计来让别人继承的(即使有构造函数也不能创建自己的实例)，那么就有像继承关系中子类可以复用父类的代码。</li>
<li>将抽象和具体实现分离（抽象方法）。类似于模板方法模式的实现，定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</li>
</ol>
</li>
<li><p>@Controller 注解</p>
<p><code>@Component</code> ：表明该类会作为组件类，并告知 <code>Spring</code> 要为这个类创建 <code>bean</code>，它的目的就是辅助实现组件扫描。除了<code>@Component</code>（通用）外，<code>Spring</code> 提供了3个功能基本和<code>@component</code>等效的注解：</p>
<ul>
<li>@Repository 用于对DAO实现类进行标注</li>
<li>@Service 用于对Service实现类进行标注</li>
<li>@Controller 用于对Controller实现类进行标注</li>
</ul>
<p>这三个注解除了表明了它是做什么的，其它功能和<code>@component</code>注解一致。</p>
</li>
<li><p>ApplicationContext通常的实现是什么?</p>
<ul>
<li>AnnotationConfigApplicationContext：从一个或多个基于Java的配置类中加载Spring应用上下文。</li>
<li>AnnotationConfigWebApplicationContext：从一个或多个基于Java的配置类中加载Spring Web应用上下文。</li>
<li>ClassPathXmlApplicationContext：从类路径下的一个或多个XML配置文件中加载上下文定义，把应用上下文的定义文件作为类资源。</li>
<li>FileSystemXmlApplicationContext：从文件系统下的一个或多个XML配置文件中加载上下文定义。</li>
<li>XmlWebApplicationContext：从Web应用下的一个或多个XML配置文件中加载上下文定义。</li>
</ul>
</li>
<li><p>forward和redirect的区别</p>
<p>转发是服务器端的行为，地址栏的地址不会改变。共享request中的内容。</p>
<p>而重定向是客户端的行为，地址栏的地址会发生改变，不能共享request中的内容。</p>
<p><a href="https://www.cnblogs.com/Qian123/p/5345527.html" target="_blank" rel="noopener">https://www.cnblogs.com/Qian123/p/5345527.html</a></p>
<p>面试的时候如果问到了和它讲去单位办事情，如果这个单位办不了，但是它帮你移交给其它单位办理然后把结果返回给你就是转发。如果直接告诉你办不了，让你去其它单位办理就是重定向。</p>
</li>
<li><p>开启线程的第三种方式？除了继承Thread类和实现Runnable接口</p>
</li>
<li><p>你如何确保main()方法所在的线程是Java程序最后结束的线程？</p>
<p>&emsp;&emsp;在Java中，只有当最后一个非守护线程结束时，JVM才会结束工作，也就是说Main用户线程不一定是最后结束的线程。在很多情况下，主线程创建并启动子线程，如果子线程中要进行大量的耗时运算，主线程往往将早于子线程结束之前结束。这时，如果主线程想等待子线程执行完成之后再结束，比如子线程处理一个数据，主线程要取得这个数据中的值，就要用到join（）方法了。<strong>方法join（）的作用是使所属的线程对象x正常执行run（）方法中的任务，而使当前线程z进行无限期的阻塞，等待线程x销毁后再继续执行线程z后面的代码。</strong></p>
<p>&emsp;&emsp;通过在主线程中调用所有子线程的join方法，就能够确保main()方法所在的线程(主线程)是Java程序最后结束的线程。</p>
</li>
<li><p>普通队列–基于动态数组增删改查实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> datastructure;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hogan_Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-01-20 7:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//底层维护一个动态数组</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;E&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器：用户可以指定队列的容量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        queue =<span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器：用户不指定队列的容量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        queue=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储元素个数Size</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//增:队列尾部</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">        queue.add(queue.size(),e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删：队列头部</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dequeue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        queue.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查:队首</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>从输入网址到获得页面的过程</p>
<p>1.通过DNS域名解析找到网址对应的服务器IP地址</p>
<p>2.HTTP请求</p>
<p>3.TCP三次握手</p>
<p>4.MVC、前后端分离不同架构有不同架构的响应请求流程</p>
<p>5.HTTP响应</p>
<p>6.客户端解析H5页面代码</p>
<p>7.TCP四次挥手</p>
</li>
<li><p>解释MySQL外连接、内连接与自连接的区别</p>
<p>但查询结果涉及到两张表的时候，就需要进行连接操作</p>
<p><strong>右外连接</strong>会返回右表的所有记录和左表中匹配记录的组合（如果左表中无匹配记录，来自于左表的所有列的值设为 NULL）。</p>
<p><strong>左外连接</strong>会返回左表的所有记录和右表中匹配记录的组合（如果右表中无匹配记录，来自于右表的所有列的值设为 NULL）。</p>
<p><strong>全连接</strong>是左右外连接的并集。连接表包含被连接的表的所有记录，如果缺少匹配的记录，即以 NULL 填充。</p>
<p>内连接：两张表的交集</p>
<p>自连接：自连接(self join)是SQL语句中经常要用的连接方式，使用自连接可以将自身表的一个镜像当作另一个表来对待，从而能够得到一些特殊的数据。当表中的某一个字段与这个表中另外字段的相关时，我们可能用到自连接。</p>
</li>
<li><p>@RequestMapping 注解</p>
<p>指定请求和处理器方法之间的映射关系。</p>
</li>
<li><p>什么是Spring的MVC框架？</p>
<p>Spring MVC是一个基于MVC架构用于简化Web应用程序开发的框架，是Spring框架的一个子项目。</p>
<p>MVC模式(Model-View-Controller)将软件系统分为三个基本部分：</p>
<p>模型(Model)、视图(View)、控制器(Controller)。</p>
<ul>
<li>控制器（Controller）- 负责转发请求，对请求进行处理。</li>
<li>视图（View） - 界面设计人员进行图形界面设计。</li>
<li>模型（Model） - 程序员编写程序应有的功能（实现算法等等）、数据库专家进行数据管理和数据库设计(可以实现具体的功能)。</li>
</ul>
</li>
<li><p>你对String对象的intern()熟悉么?</p>
<p>当一个String实例str调用intern()方法时，Java查找常量池中是否有相同Unicode的字符串常量，如果有，则返回其的引用，如果没有，则在常量池中增加一个Unicode等于str的字符串并返回它的引用。日常没用到过</p>
</li>
<li><p>在Java中<code>wait</code>和<code>seelp</code>方法的不同；</p>
<p>相同点：</p>
<ol>
<li>两者都让线程进入到<code>TIMED_WAITING</code>状态，并且可以设置等待的时间。</li>
</ol>
<p>不同点：</p>
<ol>
<li><code>wait</code>是<code>Object</code>类的方法，<code>sleep</code>是<code>Thread</code>的方法。</li>
<li><code>sleep</code>不会释放锁，沉睡的时候，其它线程是无法获得锁的，但<code>wait</code>会释放锁。</li>
</ol>
</li>
<li><p>为什么wait, notify 和 notifyAll这些方法不在thread类里面？</p>
<p>&emsp;&emsp;一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。</p>
</li>
<li><p>TCP协议是如何保证数据传输的可靠性的？(差错检测、序号、确认、超时重传、滑动窗口)</p>
<ul>
<li><p>数据编号和确认</p>
<p>&emsp;&emsp;<code>TCP</code>将应用层交下来的长报文划分为若干个部分，然后为每个部分添加首部形成若干个报文段。报文段的首部中的序号字段数值表示该报文段中紧接着首部后面的第一个数据字节的序号。</p>
<p>&emsp;&emsp;TCP采用的是<u>累积确认</u>，比如接收方收到了三个包，第一个包1<del>10字节，第二个包11</del>20字节，第三个包31~40字节。这时候接收方会向发送方回一个确认号21，表示前面的报文段都<strong>按序正确</strong>收到了。那为什么不在收到第一个包的时候就回确认号呢？因为TCP采用了一种<u>延迟确认</u>的机制，即接收方在正确收到数据时可能要等待一小段时间(一般不超过0.5s)再发送确认。若这段时间内有数据要发送给对方，则可以捎带确认。也有可能在这段时间内又有数据到达，则可以同时对这两次到达的数据进行累积确认。这样做可以减少发送完全不带数据的确认报文段，以提高TCP的传输效率。那第三个包没有按序到达应该怎么处理呢？先将其暂存在接收缓存内，待所缺序号的报文段收齐在确认，从而避免不必要的重传。收到错误或重复的信息，不会发送否认信息直接丢掉。</p>
<p>&emsp;&emsp;当TCP发送一个报文段时，它同时也在自己的重传队列中存放这个报文段的一个副本，并为这个报文段设置一个计时器。若收到确认，则删除这个副本，若规定时间内没有收到确认，则重传此报文段的副本。</p>
</li>
<li><p>以字节为单位的滑动窗口</p>
<p>内容比较容易记住，看书</p>
</li>
<li><p>超时重传时间的选择</p>
<p>多久才算超时呢？对这个时间应该有一个限定。因为不知道网络当前的拥塞情况和通信双方是跨了一个太平洋或者是在你家隔壁，所以很难确认隔多长时间进行报文段的重传。然后就扯出了一个计算这个时间的算法，不看了，记不住有个大概印象就可以。</p>
</li>
<li><p>快速重传</p>
</li>
<li><p>选择确认</p>
<p>前面说没有按序到达的报文段先将其暂存在接收缓存内，待所缺序号的报文段收齐在确认，从而避免不必要的重传。虽然这些字节已经被接收方接收并暂存在接收缓存中。这些没有被确认的字节很可能因为超时而被发送方重传。为避免这些无意义的重传，一个可选的功能选择确认（Selective ACK，SACK）[RFC 2018]可以用来解决这个问题。选择确认允许接收方通知发送方所有正确接收了的但是失序的字节块，发送方可以根据这些信息只重传那些接收方还没有收到的字节块。接收方要将这些接收到的失序字节块通告给对方，只使用一个确认号是办不到的。从图5-14可以看出，每一个字节块需要用两个边界序号来表示。例如，第一个失序的字节块的左边界 L1为1501，右边界R1为2001。这里有两个失序字节块，因此需要4个边界序号来表示。<br>但我们知道，TCP的固定首部中没有哪个字段能提供上述这些字节块的边界信息，因此TCP在首部中提供了一个可变长的“SACK选项字段”来存放这些信息。除此之外，要使用选择确认功能，在建立 TCP 连接时，双方还要分别在 SYN 报文段和 SYN+ACK 报文段的首部选项中都添加“允许 SACK 选项字段”，表示都支持选择确认功能。之后，才能在数据传输阶段使用 SACK选项字段进行选择确认。<br>当使用选择确认时，TCP首部中的“确认号字段”的功能和意义并没有改变，实际上SACK是对原来累积确认功能的一种补充，并可以和使用累积确认的超时重传与快速重传机制一起工作。目前多数TCP实现都支持选择确认功能。</p>
</li>
</ul>
</li>
<li><p>接口和抽象类的区别</p>
<ul>
<li><p>抽象类里面可以包含非抽象方法，接口里面都是抽象方法。</p>
</li>
<li><p>抽象类存在构造器，接口中不存在构造器。但是都不能够实例化。</p>
</li>
<li><p>只能继承一个抽象类，但是能够实现很多个接口。</p>
</li>
<li><p>如果继承抽象类的子类也是抽象类，那它可以不实现接口中的抽象方法。当时实现一个接口，一定要为接口中的抽象方法提供实现。</p>
</li>
</ul>
</li>
<li><p>谈谈对java多态的理解</p>
<p>利用方法的运行时绑定，实现了龙生九子，各有不同。</p>
</li>
<li><p>Java线程池中submit() 和 execute()方法有什么区别？</p>
<p>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。</p>
<p>submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</p>
</li>
<li><p>Java中interrupted 和 isInterrupted方法的区别？</p>
<p>1）this.interrupted（）：测试<strong>当前线程</strong>是否已经是中断状态，执行后具有将状态标志置清除为false的功能。<br>2）this.isInterrupted（）：测试<strong>指定线程</strong>（不一定是当前线程）Thread对象是否已经是中断状态，但不清除状态标志。</p>
</li>
<li><p>什么是Spring MVC框架的控制器？</p>
<p>为请求绑定具体的处理器方法，并处理请求。</p>
</li>
<li><p>String、StringBuffer、StringBuilder区别</p>
<p>&emsp;&emsp;这三个类都是字符串相关的类，由于String类的不变性，对String修改之后就会重新创建一个对象，底层开销比较大，因此就有了StringBuilder类，日常开发常用于拼接字符串之类的操作。StringBuffer是StringBuilder的线程安全的实现，在单线程的情况下就使用StringBuilder，多线程的情况下就使用StringBuffer。在执行效率方面，StringBuilder最高，StringBuffer次之，String最低。String与StringBuffer和StringBuilder的另外一个区别在于当实例化String时，可以利用构造函数<code>String s1=new String(&quot;world&quot;);</code>的方式来对其进行初始化，也可以用赋值<code>String s=&quot;hello&quot;</code>的方式来对其进行初始化，而StringBuffer和StringBuilder则必须使用构造函数来初始化。<!-- Java中双引号的字符串都是String类型的实例 --></p>
</li>
<li><p>进程和线程的区别</p>
<p>进程是一个运行中的程序，进程是代码+数据集合，是代码在数据集合上的运行活动。</p>
<p>线程则是进程中的一个执行路径，线程本身是不会独立存在的，而必须存在于某一个进程中。</p>
<p>从资源调度的角度来说，线程是进程的一部分，主要用来对CPU的资源进行管理</p>
</li>
<li><p><strong>反射的原理</strong>，反射创建类实例的三种方式是什么。</p>
<p><span style="color:red">作用：实现对类的动态加载。</span></p>
<p>反射创建类实例的三种方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Object obj=<span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">//(1) Class.forName("类的路径");</span></span><br><span class="line"><span class="comment">/* Class.forName()方法的作用就是把类加载到JVM中，它会返回一个与带有给定字符串名的类或接口相关联的Class对象，并且JVM会加载这个类，同时JVM会执行该类的静态代码段。 */</span></span><br><span class="line">Class c1=Class.forName(<span class="string">"java.lang.Object"</span>);</span><br><span class="line"><span class="comment">//(2) 类名.class</span></span><br><span class="line">Class c2=Object<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"><span class="comment">//(3) 实例.getClass()</span></span><br><span class="line">Class c3=obj.getClass();</span><br></pre></td></tr></table></figure>
</li>
<li><p>Java创建对象的方式有几种？</p>
<p>1) new关键字实例化对象</p>
<p>2) Object类的clone()方法克隆一个对象</p>
<p>3) 反射创建对象</p>
<p>4) 反序列化创建对象</p>
</li>
<li><p>成员内部类、静态内部类、局部内部类和匿名内部类的理解，以及项目中的应用</p>
<ul>
<li><p>静态内部类</p>
<p>静态内部类是指被声明为static的内部类，它可以不依赖与外部类的实例而被实例化，而通常的内部类需要在外部类实例化后才能实例化。静态内部类不能与外部类有相同的名字，不能访问外部类的普通成员变量，只能访问外部类中的静态成员变量和静态方法（包括私有类型）。</p>
</li>
<li><p>成员内部类</p>
<p>一个静态内部类，如果去掉“static”关键字，就成为成员内部类。成员内部类为非静态内部类，它可以自由地引用外部类的属性和方法，无论这些属性和方法是静态的还是非静态的。但是它与一个实例绑定在了一起，不可以定义静态的属性和方法。只有在外部的类被实例化后，这个内部类才能被实例化。需要注意的是<strong>非静态内部类中不能有静态成员</strong>。</p>
</li>
<li><p>局部内部类</p>
<p>局部内部类是指定义一个在代码块内的类，它的作用范围为其所在的代码块，是内部类中最少使用到的一种类型。局部内部类的局部变量一样，不能被public、protected、private以及static修饰，只能访问方法中定义为final类型的局部变量。对一个静态内部类，去掉其声明的“static”关键字，将其定义移入外部类的静态方法或静态初始化代码就成为局部静态内部类对一个成员类，将其定义移入其外部类的实例方法或实例初始化代码中就成为了局部内部类。局部静态内部类与静态内部类的基本特性相同。局部内部类与内部类的基本特性相同。</p>
</li>
<li><p>匿名内部类</p>
<p>匿名内部类是一种没有类名的内部类，不使用关键字class、extends、implements，没有构造函数，它必须继承（extends）其他类或实现其他接口。匿名内部类的好处是代码更加简洁、紧凑，但带来的问题是易读性下降。它一般应用于GUI（Graphical User Interface，图形用户界面）编程中实现事件处理等。在使用匿名内部类时，需要牢记以下几个原则：1）匿名内部类不能有构造函数。2）匿名内部类不能定义静态成员、方法和类。3）匿名内部类不能是public、protected、private、static。4）只能创建匿名内部类的一个实例。5）一个匿名内部类一定是在new的后面，这个匿名类必须继承一个父类或实现一个接口。6）因为匿名内部类为局部内部类，所以局部内部类的所有限制都对其生效。</p>
<p>应用：静态内部类实现的单例模式；链表或树、图的节点一般为成员内部类；监听器、线程都可以用匿名内部类来创建只使用一次的实例。</p>
</li>
</ul>
</li>
<li><p>在Spring框架中如何更有效地使用JDBC?</p>
<ul>
<li>数据库连接池</li>
<li>JDBC Temptelate</li>
<li>ORM框架</li>
<li>Spring Data JPA</li>
</ul>
</li>
<li><p>什么情况下会触发类的初始化？</p>
<ul>
<li><p>遇到 new、getstatic、putstatic或invokestatic这 4 条字节码指令时，如果类未进行过初始化，那么需首先触发类的初始化。分别对应的场景为：1、使用 new 关键字实例化对象时；2、读取类的静态变量时（被 final修饰，已在编译期把结果放入常量池的静态字段除外）；3、设置类的静态变量时；4、调用一个类的静态方法时。</p>
</li>
<li><p>使用反射对类进行调用时。</p>
</li>
<li><p>初始化一个类时，如果其父类还未初始化，那么会先触发其父类的初始化。</p>
<!--顺序： Main类、父类静态变量、父类静态块、子类静态变量、子类静态块、main方法、构造器 -->
</li>
<li><p>当虚拟机启动时，被指定为需要执行的那个主类（main() 方法所在的类），虚拟机需要先初始化。</p>
</li>
<li><p>JDK 1.7 动态语言支持，详见《深入理解 Java 虚拟机》。</p>
</li>
</ul>
</li>
<li><p>什么是编译器常量？使用它有什么风险？<a href="https://www.cnblogs.com/ningvsban/p/3591610.html" target="_blank" rel="noopener">https://www.cnblogs.com/ningvsban/p/3591610.html</a></p>
<p>还是存在争议，没有找到官方一点的说明</p>
</li>
<li><p>堆内存设置的参数是什么？（强引用、软引用、弱引用、虚引用的例子里面设置过）</p>
<p>打开 IDEA 安装目录，看到有一个 bin 目录，其中有两个 vmoptions 文件，需针对不同的JDK进行配置：</p>
<p>-Xms256m -Xmx512m<br>256m表示JVM堆内存最小值<br>512m表示JVM堆内存最大</p>
<p>还有一些参数设置年轻代、老年代之类的参数，堆细化</p>
</li>
<li><p>内存模型以及分区，需要详细到每个区放什么。</p>
<p>内存模型和内存分区是两码事</p>
<p>内存模型是用来屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。提升访问速度。</p>
<p>内存模型是Java运行时数据区域……</p>
</li>
<li><p>什么是cookie？Session和cookie有什么区别？</p>
</li>
<li><p>说说Session、Cookie 与 Application</p>
<p>Http协议是一种无状态的协议，所以没办法实现状态的维持。比如登录一个网站的时候要维护登录状态。cookie和session就是来解决这个问题的，两种都可以存储客户端和服务端的状态信息</p>
<p>1) cookie保存在客户端的浏览器上，session保存在服务器上</p>
<p>2）cookie保存在客户端上，不安全。session保存在服务器上，较为安全</p>
<p>3）大量的session会对服务器的性能造成影响</p>
<p>4）单个cookie保存的信息不能超过4k，很多浏览器限制单个站点最多保存20个cookie。但是session则不存在这种问题。</p>
<p>Application 整个程序声明周期，服务端，没有限制大小，所有用户共享</p>
</li>
<li><p>Get与POST的区别</p>
<p>Get与Post是HTTP协议的两个Method，除此之外还有几个Method</p>
<p>在Restful风格下，GET表示请求资源，Post表示创建资源</p>
<ol>
<li>Get中的数据会显示在地址栏上，通过？和&amp;连接，长度受到Url的限制，传输的数据量有限。Post则采用HTTP请求的附件实现数据的传输，可以传送更多的数据</li>
<li>Get的数据显示在地址栏，有安全隐患，涉及到敏感数据，比如密码，应采用Post同时加密</li>
</ol>
</li>
<li><p>请解释StackOverflowError和OutOfMemeryError的区别？</p>
</li>
</ul>
<ul>
<li><p>序列化的方式</p>
<p>Java原生：实现Serializable接口或者Externalizable接口</p>
<p>网络中针对具体传输格式的序列化，有一系列的序列化框架。</p>
<p>json序列化：JackSon</p>
<p>XML序列化：……</p>
</li>
<li><p>如何保证多线程读写文件的安全？</p>
<p>对文件对象加锁、对操作文件的方法加锁、一些读写安全的类</p>
<p>额~、这道题还不是很完整，得找一个例子来实现</p>
</li>
<li><p>HTTP的长连接和短连接?</p>
<p>HTTP是基于TCP协议的，HTTP的长连接和短链接实质上是TCP的长连接和短链接。</p>
<ul>
<li><p>长连接：长连接可以实现当服务端与客户端连接成功后连续地传输数据，在这个过程中，连接保持开启状态，数据传输完毕后连接不关闭。长连接是指建立Socket连接后，无论是否使用这个连接，该连接都保持连接状态。长连接就是复用当前的连接以达到数据多次通信的目的。由于复用当前的连接进行数据通信，因此不需要重复创建连接，传输的效率比较高。</p>
<p>优点：除第一次之外，客户端不需要每次传输数据时都先与服务端进行握手，这样就减少了握手确认的时间，直接传输数据，提高程序的运行效率。</p>
<p>缺点：在服务端保存多个Socket对象，大量占用服务器资源。</p>
</li>
<li><p>短连接：短链接是当服务端与客户端连接成功后开始传输数据，数据传输完毕后则连接立即关闭，如果还想再次传输数据，则需要再创建新的连接进行数据传输。当实现1次数据通信之后，关闭连接，这种情况就可以称为短连接。使用短连接进行数据传输时，由于每次传输数据前要创建连接，这样会产生多个连接对象，增大占用内存的空间，在创建连接时也要进行服务端和客户端之间确认彼此存在，确认过程比较耗时，因此运行效率较低。</p>
<p>优点：在服务端不需要保存多个Socket对象，降低内存占用率。</p>
<p>缺点：每次传输数据前都要重新创建连接，也就是每次都要进行三次握手，增加了处理的时间。</p>
</li>
</ul>
</li>
<li><p>Java集合的快速失败机制 “fail-fast”？</p>
</li>
<li><p>fail-fast 与 fail-safe 之间的区别？</p>
<p>//记录迭代过程中 HashMap 结构是否发生变化，如果有变化，迭代时会 fail-fast<br>transient int modCount;</p>
<p>相关文章：<a href="https://juejin.im/post/5cb683d6518825186d65402c#heading-4" target="_blank" rel="noopener">https://juejin.im/post/5cb683d6518825186d65402c#heading-4</a></p>
<p><a href="https://blog.csdn.net/ch717828/article/details/46892051" target="_blank" rel="noopener">https://blog.csdn.net/ch717828/article/details/46892051</a></p>
</li>
<li><p>URI和URL的区别</p>
<p>URI(统一资源标识符Universal Resource <strong>Identifier</strong>)唯一表示某个资源</p>
<p>URL(统一资源定位符Universal Resource <strong>Locator</strong>)通过位置唯一标识某个资源</p>
<p>URL是URI的一种实现，URI包含URL。</p>
<p>说成Java里的就是URI是接口，URL是实现类</p>
<p><a href="https://www.zhihu.com/question/21950864" target="_blank" rel="noopener">https://www.zhihu.com/question/21950864</a></p>
</li>
<li><p>localhost和127.0.0.1区别</p>
<p>localhost是域名、127.0.0.1是IP地址</p>
<p>localhost需要通过DNS解析为IP地址，所以感觉127.0.0.1比较快</p>
</li>
<li><p>Spring框架中的单例bean是线程安全的吗?</p>
<p>Spring里的单例和我们日常里的单例还不是一回事，它是容器内单例，也就是你new了一个应用上下文，它只在你这个上下文范围内保证单例。也就是说，单例模式是指在一个JVM进程中仅有一个实例，而Spring单例是指在一个SpringBean容器(ApplicationContext)中仅有一个实例</p>
<p>Spring框架并没有对它进行线程安全的处理，涉及到线程安全的问题，应该自己去确保线程安全。比如有状态的bean，将作用范围设置为prototype。就不会出现共享实例的情况。但大多数情况下都是无状态的bean，如Dao、Service。但是如果entity要作为bean就得设置为prototype，避免线程安全问题。。</p>
</li>
<li><p>解释Spring支持的几种bean的作用域。</p>
<p><a href="https://blog.csdn.net/icarus_wang/article/details/51586776" target="_blank" rel="noopener">https://blog.csdn.net/icarus_wang/article/details/51586776</a></p>
<p>主要是和Web有关的三种作用域解释不清楚</p>
</li>
<li><p>GET请求中URL编码的意义</p>
<p>关于编码的多看看《深入分析Java Web技术内幕》</p>
<p><a href="http://www.ruanyifeng.com/blog/2010/02/url_encoding.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2010/02/url_encoding.html</a></p>
</li>
<li><p>Java是从C++改进过来的，有什么新改变？</p>
<p>Java和C++都是面向对象语言，都使用了面向对象思想(例如封装、继承、多态等)，由于面向对象有许多非常好的特性(继承、组合等)，因此二者都有很好的可重用性(代码复用)。需要注意的是，二者并非完全一样，下面主要介绍它们的不同点：</p>
<p>1）Java是解释性语言，其运行过程为：程序源代码经过Java编译器编译成字节码，然后由JVM解释执行。而C/C++为编译型语言，源代码经过编译和链接后生成可执行的二进制代码。因此，Java的执行速度比C/C++慢，但是Java能够跨平台执行，而C/C++不能。<!-- 相当于多了个中间层JVM --></p>
<p>Java具有平台无关性，即对每种数据类型都分配固定长度，例如，int类型总是占据32位，而C/C++却不然，同一个数据类型在不同的平台上会分配不同的字节数。</p>
<p>2）Java为纯面向对象语言，所有代码(包括函数、变量等)必须在类中实现，除基本数据类型(包括int、float等)外，所有类型都是类。此外，Java语言中不存在全局变量和全局函数，而C++兼容面向过程和面向过程编程的特点，可以定义全局变量和全局函数。</p>
<p>3）与C/C++语言相比，Java语言中没有指针的概念，这有效防止了C/C++语言中操作指针可能引起的系统问题，从而使程序变得更加安全。</p>
<p>4）与C++语言相比，Java不支持多重继承，但是Java语言引入了接口的概念，可以同时实现多个接口。由于接口也具有多态特性，因此在Java语言中可以通过实现多个接口来实现与C++语言中多重继承类似的目的。</p>
<!-- 比如C++的多继承，和Java单根继承用接口实现多重继承 怎么解决二义性(致命方块)问题？ -->

<p>Java允许接口多实现，可能引起像C++多继承的致命方块问题的情景：</p>
<ul>
<li><p>实现两个接口，两个接口里声明了一样的方法。这种情况只需要实现一个类的方法体即可</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hogan_Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-01-26 17:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interface1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hogan_Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-01-26 17:52</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interface2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hogan_Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-01-26 17:52</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImplClass</span> <span class="keyword">implements</span> <span class="title">Interface1</span>,<span class="title">Interface2</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>继承了一个类和实现了一个接口，类和接口中存在相同的方法声明。这种情况如果类没有实现就用父类的方法作为实现方法，如果有就用实现类的方法作为实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hogan_Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-01-26 17:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hogan_Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-01-26 17:52</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hogan_Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-01-26 17:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImplAndSonClass</span> <span class="keyword">extends</span> <span class="title">Class</span> <span class="keyword">implements</span> <span class="title">Interface</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ul>
</li>
</ul>
<p>  5）在C++语言中，需要开发人员去管理对内存的分配(包括申请和释放)，而Java语言提供了垃圾回收器来实现垃圾的自动回收，不需要程序显式地管理内存的分配。在C++语言中，通常会把释放资源的代码放到析构函数中，Java语言中虽然没有析构函数，但却引入了一个finalize()方法，当垃圾回收器将要释放无用对象的内存时，会首先会调用该对象的finalize()方法，因此，开发人员不需要关心也不需要知道对象所占的内存空间何时会被释放。</p>
<p>  &emsp;&emsp;接下来这些比较扯淡，了解一下即可。C++语言支持运算符重载，而Java语言不支持运算符重载。C++语言支持预处理，而Java语言没有预处理器，虽然不支持预处理功能(包括头文件、宏定义等)，但它提供的import机制和C++中的预处理器功能类似。C++支持默认的函数参数，而Java不支持默认的参数函数。C/C++支持goto语句，而Java不提供goto语句(但Java中goto是保留关键字)。C/C++支持自动强制类型转换，这会导致程序的不安全；而Java不支持自动强制类型转换，必须由开发人员进行显式地强制类型转换。C/C++中，结构和联合的所有成员均为公有，这往往会导致安全性问题的发生，而Java根本就不包含结构和联合，所有的内容都封装在类里面。</p>
<p>  &emsp;&emsp;Java提供对注释文档的内建支持，所以源码文件也可以包含它们自己的文档。通过一个单独的程序，这些文档信息可以提取出来，并重新格式化生成HTML。</p>
<p>  &emsp;&emsp;Java包含了一些标准库，用于完成特定的任务，同时这些库简单易用，能够大大缩短开发周期，例如，Java提供了用于访问数据库的JDBC库，用于实现分布式对象的RMI等标准库。C++则依靠一些非标准的、有其他厂商提供的库。</p>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    Hogan Lee
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://forhcl.github.io/2020/07/18/%E7%9F%A5%E4%B9%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E9%A2%98%E8%A7%A3/" title="知乎面试题题解">http://forhcl.github.io/2020/07/18/%E7%9F%A5%E4%B9%8E%E9%9D%A2%E8%AF%95%E9%A2%98%E9%A2%98%E8%A7%A3/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/07/07/%E5%B0%8F%E6%AF%9B%E7%97%85/" rel="next" title="小毛病">
                <i class="fa fa-chevron-left"></i> 小毛病
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      
  <script src="https://utteranc.es/client.js"
    repo="forhcl/forhcl.github.io"
    issue-term="pathname"
    theme="github-light"
    crossorigin="anonymous"
    async>
  </script>

    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="Hogan Lee" />
            
              <p class="site-author-name" itemprop="name">Hogan Lee</p>
              <p class="site-description motion-element" itemprop="description">Talk is not cheap. Talk can be powerful.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives%7C%7Carchive">
              
                  <span class="site-state-item-count">67</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">37</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/forhcl" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:18028543308@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hogan Lee</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/jquery/2.1.3/jquery.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/fastclick/1.0.6/fastclick.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/jquery.lazyload/1.9.3/jquery.lazyload.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.ui.min.js"></script>
  

  
  
    <script type="text/javascript" src="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.pack.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  











  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/chitose.model.json"},"display":{"position":"left","width":200,"height":400},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body>
</html>
