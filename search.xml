<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>手把手搭建FTP服务器</title>
    <url>/2020/06/28/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%90%AD%E5%BB%BAFTP%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p>&emsp;&emsp;由于软件更新需要，需要使用到FTP和SFTP。现在尝试手动来搭建SFTP和FTP服务器！！！</p>
<ul>
<li>FTP服务器搭建</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Weblogic学习</title>
    <url>/2020/06/19/Weblogic%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>Oracle WebLogic Server：WebLogic应用服务器是整个WebLogic产品的核心。</p>
<p>&emsp;&emsp;首先，因为weblogic是通过一个jar包进行安装的，所以需要进行java环境的配置；其次，由于是通过可视化java GUI界面进行安装，在远程工具上面需要配置好DISPLAY环境变量，才能让可视化窗口在远程机器上面连接到！！</p>
<h2 id="DISPLAY环境变量的配置"><a href="#DISPLAY环境变量的配置" class="headerlink" title="DISPLAY环境变量的配置"></a>DISPLAY环境变量的配置</h2><p>在Linux/Unix类操作系统上, DISPLAY用来设置将图形显示到何处。</p>
<p><a href="https://blog.csdn.net/qq_39101111/article/details/78729647" target="_blank" rel="noopener">https://blog.csdn.net/qq_39101111/article/details/78729647</a></p>
<p>这个真的是超级头痛，display设置出现的问题就是，X server也就是我们的机器处于局域网中，没有独立的公网IP地址，且有防火墙阻拦，由于阿里云服务器和我们的主机不是在同一个子网下，配置DISPLAY为ip:0.0的时候找不到我们的主机，没办法把GUI搞到我们的机器上面！！</p>
<p>大多数客户端位于局域网中，IP地址是经过转换的，因此<strong>ipconfig</strong>或<strong>ifconfig</strong>命令返回的IP不一定是客户端的真实公网IP地址。若后续客户端无法登录FTP服务器，请重新确认其公网IP地址。</p>
<h2 id="weblogic的安装最后需要去手动添加一个配置文件"><a href="#weblogic的安装最后需要去手动添加一个配置文件" class="headerlink" title="weblogic的安装最后需要去手动添加一个配置文件"></a>weblogic的安装最后需要去手动添加一个配置文件</h2><p>添加配置文件的位置，在启动文件下同一目录下面./servers/AdminServer/下创建一个security文件夹，然后通过vi创建一个boot.properties文件，</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">username</span>=<span class="string"></span></span><br><span class="line"><span class="attr">password</span>=<span class="string"></span></span><br></pre></td></tr></table></figure>

<p>然后在<strong>第一次启动</strong>的时候会编译这个文件，然后把用户名密码编译成看起来像乱码的字符串。</p>
<p>Linux下面的webLogic启动文件的一个路径<code>/home/redhat/Oracle/Middleware/Oracle_Home/user_projects/domains/base_domain/startWebLogic.sh</code>   启动在7001端口</p>
<p><a href="http://192.168.91.129:7001/console" target="_blank" rel="noopener">http://192.168.91.129:7001/console</a> 进行访问</p>
<p>其中192.168.91.7001是虚拟机的IP地址</p>
<h2 id="启动weblogic"><a href="#启动weblogic" class="headerlink" title="启动weblogic"></a>启动weblogic</h2><p><code>nohup ./startWebLogic.sh &amp; tail -f nohup.out</code></p>
<p>&amp;后面的命令可以等后面在打，主要用来显示weblogic的启动信息。如果没有的话就没有相应启动信息打印</p>
<p><code>ifconfig</code> 展示配置信息，如ip等</p>
<p><code>clear</code>:在SecureCRT中用来将命令行置顶</p>
<p><code>cat</code>:用来查看文件的内容，可以翻页比vim方便。用于查看文件内容的命令还有<code>more、less、head、tail</code>等</p>
<p><code>tab键</code>：按了首字母就可以帮助补全</p>
<p><code>chown</code>：修改文件的所有者和所属组 语法：chown <u>-R</u> user:group directory     -R选项：对目录下面的所有目录递归这个操作</p>
<p> <code>su</code>：切换用户 su = su - root  语法：su - username</p>
<p><code>chkconfig</code>：设置服务开机自启</p>
<p><code>service</code>：管理服务</p>
<p><code>ls</code>;<code>ll</code> 相当于 <code>ls -l</code></p>
<h2 id="weblogic的基本概念学习"><a href="#weblogic的基本概念学习" class="headerlink" title="weblogic的基本概念学习"></a>weblogic的基本概念学习</h2><h6 id="域（Domain）"><a href="#域（Domain）" class="headerlink" title="域（Domain）"></a>域（Domain）</h6><p>一个管理服务器，多个受管服务器形成集群。一个域中可以有多个受管服务器，但是只能有一个管理服务器。通常情况下业务应用程序运行在受管服务器中，而管理服务器不会运行业务应用程序，仅仅用于管理域中的资源。</p>
<p>集群中的多台机器都要使用同一个版本的weblogic！！！</p>
<p>SecureCRT：一个类似于MobaXterm的软件</p>
<p>winscp：文件传输</p>
<p>我感觉MobaXterm一个顶两，但是没办法工作要前面两个</p>
]]></content>
  </entry>
  <entry>
    <title>Linux虚拟机设置静态IP地址</title>
    <url>/2020/06/09/Linux%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81IP%E5%9C%B0%E5%9D%80/</url>
    <content><![CDATA[<p>&emsp;&emsp;VMware虚拟机中的Linux镜像系统IP地址在午休重启之后总是由DHCP重新分配，而我们外部的SecureCRT和ftp文件传输工具都是通过IP地址连接到虚拟机的，所以每次都需要手动去修改这些Linux工具的IP地址，次数多了超级烦人！！所以我就想着能不能把虚拟机的IP地址固定下来！！避免变化！！</p>
<p>&emsp;&emsp;下面整理了我设置静态IP地址的全过程，首先虚拟网络编辑器窗口中把这个勾去掉！！</p>
<p><img src="http://cdn1.hikariblog.cn/%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C%E7%BC%96%E8%BE%91%E5%99%A8.png" alt="虚拟网络编辑器"></p>
<p>注意：修改配置文件的时候先拷贝一份备份！！！</p>
<p><code>cp ifcfg-xxx ifcfg-xxx.bak</code></p>
<p>然后修改文件/etc/sysconfig/network-scripts/ifcfg-xxx，这里xxx不是lo是其它的！！xxx貌似是ifconfig上面的ip地址网卡名称！！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">DEVICE="eth0"</span><br><span class="line">BOOTPROTO=static     # 这一行由dhcp改成static</span><br><span class="line">IPV6INIT="yes"</span><br><span class="line">NM_CONTROLLED="yes"</span><br><span class="line">ONBOOT="yes"         # 这一行改成yes</span><br><span class="line">TYPE=Ethernet</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">IPV4_FAILURE_FATAL=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">NAME="System eth0"</span><br><span class="line">UUID=5fb06bd0-0bb0-7ffb-45f1-d6edd65f3e03</span><br><span class="line">HWADDR=00:0C:29:65:61:B5</span><br><span class="line">PEERDNS=yes</span><br><span class="line">PEERROUTES=yes</span><br><span class="line">IPV6_PEERDNS=yes</span><br><span class="line">IPV6_PEERROUTES=yes</span><br><span class="line"><span class="meta">#</span><span class="bash"> 下面四行都是需要手动添加的，要填的值都可以在虚拟网络编辑器窗口里面找到</span></span><br><span class="line">IPADDR=192.168.91.129  # 固定IP地址，有限制范围不是随便给的</span><br><span class="line">NETMASK=255.255.255.0  # 子网掩码</span><br><span class="line">GATEWAY=192.168.91.2   # 网关</span><br><span class="line">DNS1=192.168.91.2      # DNS，填和网关一样</span><br></pre></td></tr></table></figure>

<p>然后执行命令，”service network restart”重启网络服务</p>
<p>DNS1不配的话可能虚拟机不能访问外网，然后可以ping一下<a href="http://www.baidu.com，ping一下外部主机的IP。用主机的ftp、secureCRT等工具连接测试一下是否出错！！" target="_blank" rel="noopener">www.baidu.com，ping一下外部主机的IP。用主机的ftp、secureCRT等工具连接测试一下是否出错！！</a></p>
<p>如果出错就把配置文件删除，把刚才备份的重新用上。然后去虚拟网络编辑器窗口把那个勾勾上。实在还是不行的话就直接去虚拟网络编辑器窗口里面还原网络默认配置！！</p>
<p>不知道为什么全部配置好了下次开机就又出问题了！！下一次找到问题再更新</p>
<p>可以直接改变虚拟机的IP地址，就不用逐个去修改远程连接的地址!!!</p>
<p><code>ifconfig eth0 192.168.117.128</code></p>
]]></content>
  </entry>
  <entry>
    <title>2020春招</title>
    <url>/2020/06/07/2020%E6%98%A5%E6%8B%9B/</url>
    <content><![CDATA[<p>&emsp;&emsp;个人情况：普通二本院校计算机科班应届生，成绩水平中等，在校期间也较少参加社团活动；求职之初是希望往Java开发方向，后面也开始动摇了。</p>
<p><strong>到手Offer状况：</strong></p>
<ul>
<li>助理软件实施工程师：6200</li>
<li>外包公司的Java开发：4500</li>
<li>传统企业的Java开发：5500-7500</li>
<li>国企的信息技术岗位：5000</li>
</ul>
<p>然后最后选择了“助理软件实施工程师”，我也不知道为什么！！可能是从心了。</p>
]]></content>
  </entry>
  <entry>
    <title>Linux命令行大全</title>
    <url>/2020/06/04/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<h3 id="第一章-shell是什么？"><a href="#第一章-shell是什么？" class="headerlink" title="第一章 shell是什么？"></a>第一章 shell是什么？</h3><p>&emsp;&emsp;当我们启动Terminal 终端（或者其它远程工具的命令行界面）的时候，在每一行开始的地方会有shell提示符<code>[root@localhost ~]#</code>，其中root为当前用户名，localhost为主机名称，<code>~</code>为主机的名称。当shell提示符的最后一个字符是<code>#</code>，而不是一个<code>$</code>符号，那么终端会话将享有超级用户特权。这就意味着要么我们是以根用户身份登录，<u>要么我们选择的终端仿真器可以提供超级用户（管理）特权</u>。</p>
<ul>
<li><p>命令历史记录</p>
<p>向上或者向下可以查看命令历史记录，大部分的Linux发行版本能够存储最近输入的<strong>500</strong>个命令。</p>
</li>
<li><p>复制和粘贴</p>
<p>Linux中的复制粘贴不同于Windows的Ctrl+C和Ctrl+V，Linux中的复制、粘贴命令为Ctrl+Insert和Shift+Insert。至于为什么不同去问微软吧，毕竟Linux比windows先出现。</p>
</li>
<li><p>date</p>
<p>查看系统当前的时间，注意：虚拟机查出来的时间和本机的不同，怎么去把它调成一样？</p>
</li>
<li><p>cal</p>
<p>查看系统当月的日历</p>
</li>
<li><p>df</p>
<p>查看磁盘可用的空间</p>
</li>
<li><p>free</p>
<p>查看可用的内存</p>
</li>
<li><p>exit/logout  结束终端会话</p>
</li>
</ul>
<h3 id="Linux中导航文件系统"><a href="#Linux中导航文件系统" class="headerlink" title="Linux中导航文件系统"></a>Linux中导航文件系统</h3><p>&emsp;&emsp;在Windows系统中，每个存储设备都有一个独立的文件系统树。而在类UNIX系统中，如Linux，无论多少驱动器或存储设备与计算机相连，通常只有一个文件系统树。根据管理员的设置，存储设备将会连接（更准确的说是“挂载”）到文件系统树的不同位置。。 <strong>如何通过命令行访问到挂载的存储设备（U盘、光盘）？</strong></p>
<ul>
<li><p>pwd</p>
<p>当前工作目录的绝对路径</p>
</li>
</ul>
<p>每个用户账号都有一个主目录，<strong>作为普通用户操作时，这是唯一一个允许用户<span style="color:red">写</span>文件的地方。</strong>那这样子的话安装的软件就安装在当前用户的主目录中，不会对其它的用户造成影响。所以尽量不要采用root安装软件，不然可能造成不好的影响。</p>
<ul>
<li><p>cd</p>
<ul>
<li><p>绝对路径</p>
<p>以<code>/</code>开始</p>
</li>
<li><p>相对路径</p>
<p>绝对路径名是从根目录开始，通向目标目录，而相对路径名则是从工作目录开始的。为了实现这个目的，它通常使用一些特殊符号来表示文件系统树的相对位置，这些特殊符号是“.”(当前工作目录)和“..”（上一级工作目录/父目录）。“.”当前工作目录使用的情况很少，因为它是隐含的，比如你要进入子目录./bin的时候完全不需要cd ./bin而是可以直接cd bin。</p>
</li>
</ul>
</li>
</ul>
<p><img src="http://cdn1.hikariblog.cn/cd%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F.png" alt="cd常用快捷方式"></p>
<ul>
<li><p>ls</p>
<p><strong>以“.”字符开头命名的文件是隐藏的。</strong>这仅说明ls不会列出这些文件，除非输入ls -a。在创建用户账号时，主目录里会放置一些隐藏文件，用来配置账号信息。仔细观察这样的文件，可以使我们了解如何自定义工作环境。此外，一些应用程序也会将他们的配置文件和设置文件以隐藏文件的形式放在主目录下面。</p>
<p>与UNIX一样，在Linux中，文件名与命令是区分大小写的。文件名File1和file1指向不同的文件。</p>
<p><strong>文件名不用采用空格，不然对于命令的执行可以很不友好！！采用下划线代替空格。</strong></p>
</li>
</ul>
<h3 id="第3章-Linux系统"><a href="#第3章-Linux系统" class="headerlink" title="第3章 Linux系统"></a>第3章 Linux系统</h3><p><code>ls -l</code>可以缩写为<code>ll</code></p>
<p>WebLogic</p>
<h3 id="高级键盘技巧"><a href="#高级键盘技巧" class="headerlink" title="高级键盘技巧"></a>高级键盘技巧</h3><ul>
<li>clear清屏  在shell里面的确是清屏，但是在SecureCRT里面的话只是把要输入命令的那一行置顶。</li>
<li>history：显示历史列表的记录。一般能保存大概500个历史命令。</li>
</ul>
<p>Ctrl+A移动到行首，Ctrl+E移动到行末</p>
<p>搜索历史命令记录，Ctrl+R进入历史命令搜索模式，搜索到了Enter键执行，Ctrl+J将搜索到的命令输出到当前命令行中以作进一步的编辑。</p>
<p>看一下权限和用户！！！！！和软件安装yum。然后安装一下Oracle</p>
<h3 id="Linux根目录下各个文件夹的含义"><a href="#Linux根目录下各个文件夹的含义" class="headerlink" title="Linux根目录下各个文件夹的含义"></a>Linux根目录下各个文件夹的含义</h3><p><img src="http://cdn1.hikariblog.cn/Linux%E6%A0%B9%E7%9B%AE%E5%BD%95.png" alt="Linux根目录"></p>
<ul>
<li><p>bin</p>
<p>包含二进制可执行文件。<br>在单用户模式下，你需要使用的常见linux命令都位于此目录下。系统的所有用户使用的命令都设在这里。<br>例如：ps、ls、ping、grep、cp</p>
</li>
<li><p>boot</p>
<p>引导加载程序相关的所有文件</p>
</li>
<li><p>home</p>
<p>存储所有普通用户的主目录</p>
</li>
<li><p>var</p>
<p>变量文件</p>
</li>
<li><p>tmp</p>
<p>临时文件，当系统重新启动的时候，这个目录下的文件都将被删除掉</p>
</li>
<li><p>media</p>
<p>可移动存储介质的挂载目录  怎么把U盘挂载到Linux虚拟机上面！！</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Linux运维</title>
    <url>/2020/06/01/Linux%E8%BF%90%E7%BB%B4/</url>
    <content><![CDATA[<p>$$<br>Linux\begin{cases}<br>内核版本\\<br>发行版本\begin{cases}<br>商业版本\\<br>社区版本<br>\end{cases}<br>\end{cases}<br>$$</p>
<p>Linux——代表系统的内核。</p>
<p>Linux操作系统——代表基于Linux内核的操作系统，通常由内核与商业公司定制的程序结合而成。</p>
<h4 id="Linux系统安装"><a href="#Linux系统安装" class="headerlink" title="Linux系统安装"></a>Linux系统安装</h4><ul>
<li><p>光盘安装（正版）</p>
<p>适用于单台机器，但是如果是集群环境下存在大量的服务器，逐一进行安装就会导致效率低下。</p>
</li>
<li><p>无人职守自动安装</p>
<p>通过网络方式安装并结合自动应答文件，实现无人职守自动安装部署操作系统。</p>
</li>
</ul>
<h4 id="Linux命令行"><a href="#Linux命令行" class="headerlink" title="Linux命令行"></a>Linux命令行</h4><p>&emsp;&emsp;<span style="color:red">在企业生产环境中，Linux主要担当服务器的角色，而图形界面会占用大量的系统资源。因此，从运行效率以及资源占用率的角度考虑，通常会使用命令行完成日常工作。</span><!-- 这就是为什么你要学习Linux命令行的原因，Terminal:终端 --></p>
<ul>
<li><p>pwd</p>
<p>描述：显示<u>当前</u>工作目录的<strong>绝对路径</strong>名称。</p>
<!-- 也就是当前在哪一个文件夹下面，显示目前所在的工作目录的绝对路径名称 -->
</li>
<li><p>mkdir</p>
<p>描述：创建目录（相当于windows的创建文件夹）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir 目录名（创建一级目录）</span><br><span class="line">mkdir -p  /ddd/ddd（创建多级目录）</span><br><span class="line">//需要注意的就是后面的这个路径是绝对路径还是相对路径</span><br></pre></td></tr></table></figure>

<p>新建文件的话用vim</p>
</li>
<li><p>rm</p>
<p>描述：删除文件或者目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm ee.txt  &#x2F;&#x2F;删除指定的文件</span><br><span class="line">rm -r  dd  &#x2F;&#x2F;删除dd目录以及目录下的所有内容</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">-r 删除目录以及目录下的所有内容</span><br><span class="line">-f 不提示强制删除</span><br><span class="line">-i 删除前，提示是否删除</span><br></pre></td></tr></table></figure>

<p>用这个命令的时候要谨慎，rm -rf删库跑路！！！</p>
</li>
<li><p>mv</p>
<p>描述：移动（重命名）文件或目录</p>
</li>
<li><p>echo</p>
<p>描述：打印语句，相当于Java的System.out.println()</p>
</li>
</ul>
<h2 id="grep命令配合管道符使用-杀死进程"><a href="#grep命令配合管道符使用-杀死进程" class="headerlink" title="grep命令配合管道符使用(杀死进程)"></a>grep命令配合管道符使用(杀死进程)</h2><p><code>ps -ef|grep firefox</code></p>
<p>把ps的查询结果通过管道给grep查找<strong>包含特定字符串</strong>的进程，<strong>管道符|用来隔开两个命令、管道符左边命令的输出会作为管道符右边命令的输入。</strong></p>
<p><strong>grep 命令用于查找文件里符合条件的字符串！！！</strong>是一种强大的文本搜索工具</p>
<p>然后通过<code>kill -s 9 进程号</code>来杀死进程</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>假设存在文件1.txt</p>
<ul>
<li><p>硬链接</p>
<p>只能创建在和文件同一个分区中，硬链接相当于一个引用、文件本身也算一个引用，当所有引用都被删除了文件就消失了。例如删除文件但是没有删除硬链接，那么我们还可以通过硬链接访问文件。</p>
<p>创建硬链接：<code>ln 1.txt a</code></p>
</li>
<li><p>软链接</p>
<p>这个就相当于Windows10中的快捷方式，保存的是某个文件的路径，当这个文件被删除了，那么就不能通过软连接去访问文件了。软链接可以存放在不同的分区中。</p>
<p><code>ln -s 1.txt b</code></p>
</li>
</ul>
<p><code>echo &quot;sss&quot;&gt;1.txt 2&gt;&amp;1</code>  放在 &gt; 后面的 &amp; ，表示重定向的目标不是一个文件，而是一个文件描述符。这里如果去掉了&amp;就是把错误输出给了文件1了，用了&amp;是表明 1 是标准输出。</p>
]]></content>
  </entry>
  <entry>
    <title>职业变动</title>
    <url>/2020/05/30/%E8%81%8C%E4%B8%9A%E5%8F%98%E5%8A%A8/</url>
    <content><![CDATA[<p>&emsp;&emsp;受2020年疫情影响，同时本人的技术没能达到进入大厂的境界，也想让自己未来能够变得能言善语，而不仅仅是一个技术宅。所以我尝试去做软件实施，虽然感觉有点自封天花板。但是我不后悔，我会为我的选择买单。趁现在年轻还能够试错。</p>
<p>&emsp;&emsp;同时，也希望自己不要因为技术要求的降低而松懈自己，多考证然后尝试考珠三角一二线城市的编制岗位。蜕变成一个自己希望的乐观、开朗、普普通通的人。日常多看书，练字、锻炼，书也不要都是技术类的，作为一个大学生，文笔这么差，感觉好丢脸。腹有诗书气自华嘛！！</p>
<p>存钱开自己的便利店、买房（公寓）、老家自建房、老家再买一套。搞线上的副业，无关技术想做点小买卖成为一个小商人（想卖宠物口粮）。</p>
]]></content>
  </entry>
  <entry>
    <title>弹尽粮绝，资源关闭</title>
    <url>/2019/12/22/%E5%BC%B9%E5%B0%BD%E7%B2%AE%E7%BB%9D%EF%BC%8C%E8%B5%84%E6%BA%90%E5%85%B3%E9%97%AD/</url>
    <content><![CDATA[<p>&emsp;&emsp;日常开发的时候，总是有许多需要我们调用 <code>close()</code> 方法手动关闭的<strong>物理</strong>资源，如文件/流资源、套接字资源、数据库连接资源等等。通常都是在 <code>finally</code> 语句块对资源进行关闭，如下面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">oldFileHandle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 声明</span></span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">null</span>;</span><br><span class="line">        InputStreamReader inputStreamReader = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader bufferedReader = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建文件读取流</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileInputStream = <span class="keyword">new</span> FileInputStream(url);</span><br><span class="line"></span><br><span class="line">            inputStreamReader =</span><br><span class="line">                    <span class="keyword">new</span> InputStreamReader(fileInputStream);</span><br><span class="line"></span><br><span class="line">            bufferedReader =</span><br><span class="line">                    <span class="keyword">new</span> BufferedReader(inputStreamReader);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            执行相关的业务逻辑</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 资源关闭</span></span><br><span class="line">            <span class="keyword">if</span> (bufferedReader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bufferedReader.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (inputStreamReader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    inputStreamReader.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (fileInputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fileInputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这些资源关闭的代码不仅繁琐还降低了代码的简洁、可读性。大家可能会疑惑，Java不是提供了内存回收的机制吗？不手动关闭等GC自动回收可不可以？</p>
<p>答案当然是不可以：）垃圾回收机制只负责回收堆内存资源，不会回收任何的物理资源。所以我们必须得手动地去关闭这些资源！！当然如果你对钱没有兴趣也可以不关闭，但是贫穷的我们要知道资源是有限的，如果我们不关闭这些资源，它们将会被长时间无效占用，浪费完所有的资源后，系统将没有办法继续维持生活。生活不易，且行且珍惜~  山区的小朋友们还在等你们省下来的资源打一局王者荣耀:smile:</p>
<p>&emsp;&emsp;JDK7以后提供了一个语法糖 <code>try-with-resource</code>，利用这个可以把上面的例子修改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">newFileHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (</span><br><span class="line">            <span class="comment">// 声明</span></span><br><span class="line">            FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"G:/Singleton.txt"</span>);</span><br><span class="line">            InputStreamReader inputStreamReader = <span class="keyword">new</span> InputStreamReader(fileInputStream);</span><br><span class="line">            BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(inputStreamReader)</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        执行相关的业务逻辑</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比较而言，代码的数量少了很多！！</p>
<h2 id="try-with-resource-简介"><a href="#try-with-resource-简介" class="headerlink" title="try-with-resource 简介"></a><code>try-with-resource</code> 简介</h2><p>&emsp;&emsp;<code>try-with-resource</code> 是JDK7引入的新特性，并没有对Java的底层语法有所改变，只是JDK7提供的一种语法糖，方便程序猿们使用，让代码更加简洁，有更高的可读性。</p>
<p>查看编译后的源码，可以发现还是会将try-with-resource语句try小括号中的资源在finally语句块中进行关闭，并将相关异常追加到异常链中。</p>
<h4 id="try-with-resource使用"><a href="#try-with-resource使用" class="headerlink" title="try-with-resource使用"></a>try-with-resource使用</h4><ul>
<li>多资源自动关闭</li>
<li>通过try-with-resource语句进行关闭的物理资源需实现AutoCloseable接口</li>
<li>避免异常屏蔽</li>
</ul>
<p>推荐文章： <strong>Effective Java</strong>中的第9小节<code>Prefer try-with-resource to try-finally</code></p>
<h6 id="资源关闭的特殊情况"><a href="#资源关闭的特殊情况" class="headerlink" title="资源关闭的特殊情况"></a>资源关闭的特殊情况</h6><ol>
<li>资源对象被<code>return</code>的情况下，由调用方关闭。</li>
<li>ByteArrayInputStream等不需要检查关闭的资源对象。</li>
<li>使用Socket获取的InputStream和OutputStream对象不需要关闭，直接关闭InputStream和OutputStream会导致Socket也被关闭了（正确的方法是调用Socket的shutdown进行关闭）。</li>
</ol>
<p><code>try-with-resource</code>资源关闭的顺序：</p>
<ul>
<li>先开后关：如数据库连接JDBC中Connection、Statement、ResultSet三个资源的开关顺序</li>
<li>从外到内原则</li>
<li>底层资源单独声明原则</li>
</ul>
]]></content>
      <tags>
        <tag>Java语法糖</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客网Java专项练习</title>
    <url>/2019/12/18/%E7%89%9B%E5%AE%A2%E7%BD%91Java%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h5 id="Java的参数传递是“按值传递”还是“按引用传递”？"><a href="#Java的参数传递是“按值传递”还是“按引用传递”？" class="headerlink" title="Java的参数传递是“按值传递”还是“按引用传递”？"></a>Java的参数传递是“按值传递”还是“按引用传递”？</h5><ul>
<li>值传递：在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</li>
<li>引用传递：在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.xerces.internal.dom.PSVIAttrNSImpl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以下程序运行的结果是：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hogan_Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-12-18 10:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tester</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer var1=<span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">        Integer var2=var1;</span><br><span class="line">        doSomething(var2);</span><br><span class="line">        System.out.print(var1.intValue());</span><br><span class="line">        System.out.print(var2==var1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Integer integer)</span></span>&#123;</span><br><span class="line">        integer=<span class="keyword">new</span> Integer(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A 1true  B 2true  C 1false  D 2false</span></span><br><span class="line"><span class="comment"> * 正确答案为A</span></span><br><span class="line"><span class="comment"> * 如果还是不明白就再去ide中debug一下，看一下运行流程</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>分析上例，可以得出如下图的结果。<span style="color:red">当传入引用类型的变量作为参数时，是将引用类型中存储的实例对象地址复制一份传递给形参，实参和形参指向同一个实例对象。</span>当对对象进行修改时，形参和实参都会发生改变，但是当形参指向一个新的对象的时候，实参并不会发生改变。可见，Java的引用类型和基本类型一样都是值传递，并不存在引用传递。</p>
<p><img src="http://cdn1.hikariblog.cn/image1.png" alt=""></p>
<h5 id="import关键字的导入范围？"><a href="#import关键字的导入范围？" class="headerlink" title="import关键字的导入范围？"></a>import关键字的导入范围？</h5><p><code>import java.util.*</code> 只能读取其目录下的类，不能读取其子目录下的类。</p>
<p>因为其根目录和子目录下可能有同名类，若都能读取，则会混淆。</p>
]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>存储管理</title>
    <url>/2019/12/15/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>&emsp;&emsp;近年来，随着硬件技术和生产水平的提高，存储器的成本迅速下降，容量一直在不断地扩大，但仍然不能满足各种软件对存储空间急剧增长的需求，因此，存储器仍然是一种宝贵而紧俏的资源，如何对其进行有效的管理，不仅直接影响存储器的利用率，而且对系统性能也有重大影响。</p>
<p>&emsp;&emsp;众所周知，计算机在执行程序的时候，每条指令都是在CPU中执行的，而执行的时候，又免不了要和数据打交道。而计算机上面的程序及其要访问的数据往往是存放在内存中。刚开始，还相安无事的，但是随着CPU技术的发展，CPU的执行速度越来越快。从<strong>内存中读取和写入数据的速度</strong>开始跟不上<strong>CPU的执行速度</strong>，两者的差距越来越大，这导致CPU每次操作内存都要耗费很多的等待时间。</p>
<p>&emsp;&emsp;可是吧，我们总不能因为内存拖后腿就暂停发展CPU，等待内存技术赶上来吧！为了解决CPU和存储器之间速度上的不匹配，就在CPU和内存之间设置了高速缓存存储器；高速缓冲存储器相比较主存而言有以下特点：价格昂贵，容量小，速度快。其工作原理就是将CPU频繁访问的数据保存一份拷贝在高速缓冲存储器中，将大多数的CPU和主存之间的交互转换为CPU与高速缓冲存储器之间的交互，从而在整体上提高系统的性能。由于高速缓存的速度越高价格也越贵，因此目前的计算机系统中多设置两级或多级高速缓存。两级缓存比一级缓存速度慢，但容量更大，主要用作一级缓存和内存之间数据临时交换的地方。</p>
<p><img src="http://cdn1.hikariblog.cn/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AD%98%E5%82%A8%E5%B1%82%E6%AC%A1%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="计算机系统存储层次示意图"></p>


<p>在多级存储结构中，在储存层次中越往上，存储介质的访问速度越快，价格也越高，相对存储容量也越小。CPU寄存器、主存掉电后其存储的信息不再存在，属于操作系统存储管理的讨论范畴；辅存属于操作系统设备管理的范畴，其存储的信息会长期保存。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>攻略JDK8新特性--Lambda表达式</title>
    <url>/2019/11/26/%E6%94%BB%E7%95%A5JDK8%E6%96%B0%E7%89%B9%E6%80%A7-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>Lambda表达式？</p>
<h1 id="一、什么是Lambda表达式？"><a href="#一、什么是Lambda表达式？" class="headerlink" title="一、什么是Lambda表达式？"></a>一、什么是Lambda表达式？</h1><p><strong>Lambda表达式，针对函数式接口的简单实现。</strong></p>
<ul>
<li>Lambda表达式也被称为箭头函数、匿名函数、闭包。</li>
<li>Lambda表达式体现的是轻量级函数式编程思想</li>
<li>‘-&gt;’符号是Lambda表达式核心操作符号，符号左侧是操作参数，符号右侧是操作表达式</li>
</ul>
<h2 id="Model-Code-as-Data"><a href="#Model-Code-as-Data" class="headerlink" title="Model Code as Data"></a>Model Code as Data</h2><p>Model Code as Data，编码即数据，尽可能轻量级的将代码封装为数据。传统的实现方案为接口&amp;实现类（匿名内部类），但是这种实现方式存在语法冗余、this关键字、变量捕获、数据控制不友好等问题。下面通过一个例子来展示传统开发方式中存在的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">项目问题：功能接口的设计及优化</span></span><br><span class="line"><span class="comment">  需求环境：线程类的创建</span></span><br><span class="line"><span class="comment">  解决方案：匿名内部类实现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hogan_Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-11-26 22:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 传统模式下，新线程的创建</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"threading...."</span>+Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"Thread01"</span>).start();</span><br><span class="line">        <span class="comment">//2. jdk8新特性，lambda表达式优化线程模式</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"lambda threading..."</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;,<span class="string">"Thread02"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在传统的模式下，与线程创建语义相关的只占一小部分，大部分的代码与数据相关，很明显出现了代码的冗余。</p>
<p>为什么要使用lambda表达式？</p>
<ul>
<li>它不是解决未知问题的新技术</li>
<li>对现有解决方案的语义化优化</li>
<li>需要根据实际需求考虑性能问题 </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Lambda表达式实现一个死锁</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hogan_Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-11-27 12:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Deadlock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//临界资源1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object object1=<span class="keyword">new</span> Object();</span><br><span class="line">    <span class="comment">//临界资源2</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object object2=<span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object1)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"取得object1的锁"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (object2)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"取得object2的锁"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"Thread1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object2)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"取得object2的锁"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (object1)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"取得object1的锁"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"Thread2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="函数式接口（function-interface）"><a href="#函数式接口（function-interface）" class="headerlink" title="函数式接口（function interface）"></a>函数式接口（function interface）</h2><p>JDK8在传统的语法语义中抽象出来的语义化数据。</p>
<ul>
<li><p>函数式接口，就是Java类型系统中的普通接口</p>
</li>
<li><p>函数式接口，是<span style="color:red">只包含一个没有方法体的接口方法</span>（可以同时存在多个默认方法和静态方法）的特殊接口</p>
</li>
<li><p>语义化检测注解：<code>@FunctionInterface</code></p>
</li>
<li><p>如果抽象接口方法是从Object类继承过来的，那么不会计算到函数是接口中的抽象方法数量中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hogan_Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-11-27 10:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MarkerInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过用户id，查找对应的用户名的 接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 要查找的用户的id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回用户名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">findOne</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    List&lt;String&gt; findAll();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="默认方法和静态方法"><a href="#默认方法和静态方法" class="headerlink" title="默认方法和静态方法"></a>默认方法和静态方法</h2><p>JDK1.8新特性-default方法，打破了Java之前版本对接口的语法限制，允许接口中存在默认的实现。</p>
<p>默认方法是给所有实现该接口的对象增加的通用的方法</p>
<p>静态方法 额，好像和普通的接口方法使用一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hogan_Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-11-27 10:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MarkerInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过用户id，查找对应的用户名的 接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 要查找的用户的id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回用户名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">findOne</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    List&lt;String&gt; findAll();</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Name"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"dd"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">getTrue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">getFalse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数式接口（function-interface）-1"><a href="#函数式接口（function-interface）-1" class="headerlink" title="函数式接口（function interface）"></a>函数式接口（function interface）</h2><p>函数式接口，只包含一个操作方法</p>
<p>Lambda表达式，只能操作一个方法</p>
<p><span style="color:red">Java中的Lambda表达式，核心就是一个<strong>函数式接口</strong>的实现。</span></p>
<p>Lambda表达式常见用途就是在简化匿名内部类，注意只有当这个匿名内部类实现的是一个函数式接口的时候才可以使用lambda表达式。</p>
<p>()-&gt;{}</p>
<p>()中为接口方法的参数</p>
<p>{}为具体实现</p>
<h4 id="JDK中常见的函数式接口"><a href="#JDK中常见的函数式接口" class="headerlink" title="JDK中常见的函数式接口"></a>JDK中常见的函数式接口</h4><ol>
<li>java.lang.Runnable</li>
<li>java.lang.Comparable</li>
<li>java.lang.Comparator</li>
<li>java.io.FileFilter</li>
<li>more……</li>
</ol>
<p>针对lambda表达式，jdk8提供了java.util.function包，提供了常用的函数式功能接口（这里有点懵，自己自定义一个方法不行吗！？？ ）</p>
<ul>
<li><p><code>java.util.function.Predicate&lt;T&gt;</code> 接受参数对象T，返回一个boolean类型结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Predicate&lt;String&gt; predicate=(String username)-&gt;&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(predicate.test(<span class="string">"加油"</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>java.util.function.Consumer&lt;T&gt;</code>  接收参数对象T，不返回结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Consumer&lt;String&gt; consumer=(String usenamer)-&gt;&#123;</span><br><span class="line">    System.out.println(usenamer);</span><br><span class="line">&#125;;</span><br><span class="line">consumer.accept(<span class="string">"加油"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>java.util.function.Function&lt;T,R&gt;</code>  接受参数对象T，返回结果对象R</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;String,String&gt; function=(String message)-&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(function.apply(<span class="string">"消息~"</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>java.util.function.Supplier&lt;T&gt;</code> 不接受参数，提供T对象的创建工厂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Supplier&lt;String&gt; supplier=()-&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> UUID.randomUUID().toString();</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(supplier.get());</span><br><span class="line">System.out.println(supplier.get());</span><br><span class="line">System.out.println(supplier.get());</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>java.util.function.UnaryOperator&lt;T&gt;</code> 接受参数对象T，返回结果对象T</p>
<p>比如前端传递一张图片过来之后，我们要对图片进行处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UnaryOperator&lt;String&gt; unaryOperator=(String img)-&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> img+=<span class="string">"[100*200]"</span>;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(unaryOperator.apply(<span class="string">"原图--"</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>java.util.function.BinaryOperator&lt;T&gt;</code> 接受两个T对象，返回一个T对象结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BinaryOperator&lt;Integer&gt; binaryOperator=(Integer a,Integer b)-&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.max(a,b);</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(binaryOperator.apply(<span class="number">4</span>,<span class="number">5</span>));</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Lambda表达式基本语法"><a href="#Lambda表达式基本语法" class="headerlink" title="Lambda表达式基本语法"></a>Lambda表达式基本语法</h2><p><strong>1) 声明：就是和lambda表达式绑定的接口类型（必须的，不然怎么知道你要实现的是哪一个接口）</strong><br><strong>2) 参数：包含在一堆圆括号中，和绑定的接口中的抽象方法中的参数个数及顺序一致</strong>  </p>
<p>(注意：</p>
<ul>
<li><p>只有一个参数情况下括号可以省略掉；</p>
</li>
<li><p>在Lambda表达式中可以省略参数的类型，JVM会在运行时根据Lambda表达式绑定的接口抽象方法参数类型，自动推导对应的参数类型)</p>
</li>
</ul>
<p><strong>3) 操作符：-&gt;</strong><br><strong>4) 执行代码块：包含在一对大括号中，出现在操作符的右侧</strong></p>
<p>（注意：</p>
<ul>
<li>执行代码块如果只有一行，可以省略大括号</li>
<li>执行代码只有一行且省略大括号的情况下，有返回值时可以省略return关键字，单行代码的执行结果会自动返回）；如果添加了大括号，或者有多行代码，必须通过return关键字返回执行结果。</li>
</ul>
<p><strong>[接口声明]=(参数)-&gt;{执行代码块};</strong></p>
<p>例子如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hogan_Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-11-26 22:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. Lambda表达式的基本语法</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1) 声明：就是和lambda表达式绑定的接口类型</span></span><br><span class="line"><span class="comment">        2) 参数：包含在一堆圆括号中，和绑定的接口中的抽象方法中的参数个数及顺序一致</span></span><br><span class="line"><span class="comment">        3) 操作符：-&gt;</span></span><br><span class="line"><span class="comment">        4) 执行代码块：包含在一对大括号中，出现在操作符的右侧</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        [接口声明]=(参数)-&gt;&#123;执行代码块&#125;;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ILambda1 iLambda1 = () -&gt; System.out.println(<span class="string">"ILambda1"</span>);</span><br><span class="line">        iLambda1.test();</span><br><span class="line"></span><br><span class="line">        ILambda2 iLambda2=n-&gt;&#123;</span><br><span class="line">            System.out.println(n+<span class="string">"say:my year's old is "</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        iLambda2.test(<span class="string">"小明"</span>);</span><br><span class="line"></span><br><span class="line">        ILambda3 iLambda3=message-&gt; message;</span><br><span class="line">        System.out.println(iLambda3.test(<span class="string">"消息"</span>));</span><br><span class="line">        System.out.println(iLambda3.test(<span class="string">"消息"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没有参数，没有返回值的lambda表达式绑定的接口</span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">ILambda1</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//带有参数，没有返回值的lambda表达式</span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">ILambda2</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(String name)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//带有参数，带有返回值的Lambda表达式</span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">ILambda3</span></span>&#123;</span><br><span class="line">        <span class="function">String <span class="title">test</span><span class="params">(String message)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="变量捕获"><a href="#变量捕获" class="headerlink" title="变量捕获"></a>变量捕获</h2><ul>
<li>匿名内部类中的变量捕获</li>
<li>lambda表达式的变量捕获</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hogan_Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-11-27 20:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App2</span> </span>&#123;</span><br><span class="line">    String s1=<span class="string">"全局变量"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.匿名内部类型中对于变量的访问</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInnerClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String s2=<span class="string">"局部变量"</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            String s3=<span class="string">"内部变量"</span>;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//访问全局变量</span></span><br><span class="line"><span class="comment">//                System.out.println(this.s1);  this关键字~表示是当前内部类型的对象</span></span><br><span class="line">                System.out.println(s1);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//访问局部变量</span></span><br><span class="line">                System.out.println(s2);  <span class="comment">//不能对局部变量进行数据的修改[final]</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//访问内部变量</span></span><br><span class="line">                System.out.println(s3);</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.s3);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.Lambda表达式变量捕获</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLambda</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String s2=<span class="string">"局部变量lambda"</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">           String s3=<span class="string">"内部变量lambda"</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//访问全局变量</span></span><br><span class="line">            System.out.println(<span class="keyword">this</span>.s1); <span class="comment">//this关键字，表示的就是所属方法所在类型的对象</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//访问局部变量</span></span><br><span class="line">            System.out.println(s2);</span><br><span class="line"><span class="comment">//            s2="hello"; 不能进行数据的修改，默认推导变量的修饰符：final</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//访问内部变量</span></span><br><span class="line">            System.out.println(s3);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        App2 app2=<span class="keyword">new</span> App2();</span><br><span class="line"><span class="comment">//        app2.testInnerClass();</span></span><br><span class="line">        app2.testLambda();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：lambda表达式优化了匿名内部类访问全局变量的时候对于this关键字的使用；同时无论是匿名内部类还是Lambda表达式都不可以对局部变量进行修改，默认将巨变变量推导为fianl类型。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>REST API接口测试</title>
    <url>/2019/11/10/REST-API%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h4 id="REST-API-接口测试"><a href="#REST-API-接口测试" class="headerlink" title="REST API 接口测试"></a>REST API 接口测试</h4>]]></content>
  </entry>
  <entry>
    <title>Spring Security身份认证和授权</title>
    <url>/2019/11/07/Spring-Security%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/</url>
    <content><![CDATA[<h2 id="Spring-Security开发安全的REST服务"><a href="#Spring-Security开发安全的REST服务" class="headerlink" title="Spring Security开发安全的REST服务"></a><code>Spring Security</code>开发安全的<code>REST</code>服务</h2><div class="note primary"><p>认证和授权–&gt;最终表现为<span style="color:red">登录</span>功能。 </p></div>

<p>&emsp;&emsp;最初对于登录的理解就是前台的一个登录表单，提交到后台查看数据库是否存在该用户。如果存在，则登录成功；不存在，则登录失败。</p>
<p><img src="http://cdn1.hikariblog.cn/%E7%AE%80%E9%99%8B%E7%89%88%E7%9A%84%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD.png" alt="简陋版的登录功能"></p>
<p>但是在真正的生产环境中远没有这么简单，会有以下几个方面需要考虑</p>
<ul>
<li>同时支持多种认证登录方式：表单登录、手机短信登录、微信登录、QQ登录</li>
<li>同时支持多种前端渠道：浏览器、手机APP（两种原理的不同的）</li>
<li>支持集群登录(一台机器上登录了，其他机器怎么办)，跨应用工作（单点登录SSO），SESSION控制，控制用户的权限，防护与身份认证相关的攻击 </li>
</ul>
<p>对于企业级的认证和授权，也就是登录功能的实现，主要有以下几个技术框架：</p>
<ul>
<li><p>Spring Security：授权机制的实现</p>
</li>
<li><p>Spring Social：第三方认证</p>
</li>
<li><p>Spring Security OAuth：手机APP认证，创建、管理和分发token。（Spring Security OAuth最终的效果就是能同时支持浏览器登录和手机App登录）</p>
</li>
</ul>
<p>浏览器和服务器之间采用Session保存用户信息，App和服务器之间采用token保存用户信息（没有Session）。</p>
<p><img src="http://cdn1.hikariblog.cn/%E6%A1%88%E4%BE%8B%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84.png" alt="案例代码结构"></p>
<p><img src="http://cdn1.hikariblog.cn/%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%9A%84%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83.png" alt="企业级的认证和授权"></p>
<h4 id="使用Spring-Security开发基于表单的认证"><a href="#使用Spring-Security开发基于表单的认证" class="headerlink" title="使用Spring Security开发基于表单的认证"></a>使用Spring Security开发基于表单的认证</h4><p>认证（你是谁）</p>
<p>授权（你能做什么）</p>
<p>攻击防护（防止伪造身份）</p>
<p>内容简介</p>
<ul>
<li><p>SpringSecurity基本原理</p>
<p>关闭引入SpringSecurity之后默认拦截所有URL的HTTP基本认证</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">security.basic.enabled</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"># HTTP基本认证后才能访问对应的URL资源，其默认使用的用户名为user，密码则是动态生成并打印到控制台的一串随机码</span></span><br><span class="line"><span class="comment"># 自定义HTTP基本认证的用户名和密码</span></span><br><span class="line"><span class="comment">#  security:</span></span><br><span class="line"><span class="comment">#    user:</span></span><br><span class="line"><span class="comment">#      name: admin</span></span><br><span class="line"><span class="comment">#      password: 123</span></span><br></pre></td></tr></table></figure>

<p>Spring Security其实就是一组过滤器链</p>
</li>
<li><p>实现用户名+密码登录</p>
</li>
<li><p>实现手机号+短信登录</p>
</li>
</ul>
<h4 id="自定义用户认证逻辑"><a href="#自定义用户认证逻辑" class="headerlink" title="自定义用户认证逻辑"></a>自定义用户认证逻辑</h4><ul>
<li><p>处理用户信息获取逻辑</p>
<p>SpringSecurity将用户信息获取逻辑封装在UserDetailService中</p>
</li>
<li><p>处理用户校验逻辑</p>
</li>
<li><p>处理密码加密解密</p>
</li>
</ul>
<p>课程目标</p>
<ol>
<li>深入理解Spring Security及其相关框架的原理、功能和代码</li>
<li>可以基于Spring Security及相关框架独立开发认证授权相关功能</li>
<li>掌握抽象和封装的常用技巧，可以编写可重用的模块供他人使用</li>
</ol>
]]></content>
      <categories>
        <category>Spring Security</category>
      </categories>
      <tags>
        <tag>身份认证和授权</tag>
      </tags>
  </entry>
  <entry>
    <title>统一异常处理</title>
    <url>/2019/11/03/%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="SpringBoot配置全局的异常捕获"><a href="#SpringBoot配置全局的异常捕获" class="headerlink" title="SpringBoot配置全局的异常捕获"></a>SpringBoot配置全局的异常捕获</h2><p>异常当作篮球的话,你有两种方式处理它,要么投篮,即是用try{}catch(){}来处理<br>一种是传球,即是用throws来处理<br>这里不能这样理解的,只能说把它交给别人</p>
<h4 id="1-页面跳转的形式"><a href="#1-页面跳转的形式" class="headerlink" title="1.页面跳转的形式"></a>1.页面跳转的形式</h4><p>首先，定义一个抛出异常的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/err"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/error"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">error</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//分母不能为0，会抛出ArithmeticException异常</span></span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"thymeleaf/error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们来研究如何对抛出的异常进行统一处理，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hogan_Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-11-03 23:25</span></span><br><span class="line"><span class="comment"> * 全局异常处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">//自定义的用户友好错误页面的逻辑视图名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ERROR_VIEW=<span class="string">"error"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">Object</span> <span class="title">errorHandler</span>(<span class="title">HttpServletRequest</span> <span class="title">request</span>, <span class="title">HttpServletResponse</span> <span class="title">response</span>,<span class="title">Exception</span> <span class="title">e</span>) <span class="title">throws</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line"></span><br><span class="line">        ModelAndView mav=<span class="keyword">new</span> ModelAndView();</span><br><span class="line">        mav.setViewName(ERROR_VIEW);</span><br><span class="line">        mav.addObject(<span class="string">"exception"</span>,e);</span><br><span class="line">        mav.addObject(<span class="string">"url"</span>,request.getRequestURL());</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;对于 <code>@ExceptionHandler</code> 注解标注的方法来说，比较有意思的一点在于它能处理同一个控制器中所有的处理器方法所抛出的异常。而在带有 <code>@ControllerAdvice</code> 注解的类中，<code>@ExceptionHandler</code> 方法会运用到整个应用程序所有的控制器中带有 <code>@RequestMapping</code> 注解的方法上，以实现异常的集中统一处理。</p>
<h4 id="2-ajax形式"><a href="#2-ajax形式" class="headerlink" title="2.ajax形式"></a>2.ajax形式</h4><h4 id="3-统一返回异常的方式"><a href="#3-统一返回异常的方式" class="headerlink" title="3.统一返回异常的方式"></a>3.统一返回异常的方式</h4>]]></content>
      <categories>
        <category>springboot</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript基础</title>
    <url>/2019/11/03/JavaScript%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>如何在页面中插入JS代码？</p>
<p><img src="http://img.mukewang.com/52e31ea8000149f406440218.jpg" alt="img"></p>
<p>在H5页面中的哪个位置嵌入javascript代码最为合适？</p>
<hr>
<p><code>document.write(&quot;hello&quot;)</code>:直接在H5页面进行输出。</p>
]]></content>
  </entry>
  <entry>
    <title>Ajax全接触</title>
    <url>/2019/11/03/Ajax%E5%85%A8%E6%8E%A5%E8%A7%A6/</url>
    <content><![CDATA[<p>&emsp;&emsp;现在遇到一个问题！就是如果后端只给前端提供一个API，返回JSON格式的数据但是不指定用于渲染模型数据的视图。前端如果不是在当前页面上进行渲染的，涉及到页面的跳转应该如何处理？</p>
]]></content>
  </entry>
  <entry>
    <title>JSON数据格式</title>
    <url>/2019/09/29/JSON%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p><span style="color:red">以数据为中心的表述性状态转移(REST)对JSON的定义是——用于<strong>表述REST资源</strong>的一种形式。表述是REST中很重要的一个方面，它是关于客户端和服务端针对某一资源是如何通信的。</span><code>JSON</code>是当前行业内使用最为广泛的数据传输格式。最常见的就是服务端提供给客户端的<code>API</code>，即控制器方法一般就是采用JSON作为数据传输的格式。NoSQL数据库采用JSON作为数据储存格式。JSON还为我们提供了一种对象序列化的方式。</p>
<h4 id="JSON的基础知识"><a href="#JSON的基础知识" class="headerlink" title="JSON的基础知识"></a>JSON的基础知识</h4><h6 id="什么是JSON？"><a href="#什么是JSON？" class="headerlink" title="什么是JSON？"></a>什么是JSON？</h6><p>&emsp;&emsp;JSON是一种与开发语言无关的、轻量级的<span style="color:red">数据格式</span>。全称<code>JavaScript Object Notation</code>.</p>
<ul>
<li>最早源于JavaScript这门语言，后面使用得原来越广泛。几乎每种语言都有处理JSON的API</li>
</ul>
<p>优点：易于人的阅读和编写，易于程序解析和生产</p>
<p>一个简单的JSON的样例</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>:<span class="string">"JSON快速入门（Java版）"</span>,</span><br><span class="line">    <span class="attr">"author"</span>:<span class="string">"李广"</span>,</span><br><span class="line">    <span class="attr">"content"</span>:[<span class="string">"JSON基础入门"</span>,<span class="string">"常用JSON处理"</span>],</span><br><span class="line">    <span class="attr">"time"</span>:&#123;</span><br><span class="line">        <span class="attr">"value"</span>:<span class="number">30</span>,</span><br><span class="line">        <span class="attr">"unit"</span>:<span class="string">"分钟"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="标准的JSON数据表示"><a href="#标准的JSON数据表示" class="headerlink" title="标准的JSON数据表示"></a>标准的JSON数据表示</h6><p>数据结构</p>
<p>Object:使用花括号{}包含的<span style="color:blue">键值对</span>结构，Key必须是string类型，value为任何的<span style="color:red">基本类型</span>或<span style="color:red">数据结构</span>。</p>
<p><img src="http://cdn1.hikariblog.cn/JSON%E5%AF%B9%E8%B1%A1%E8%A1%A8%E7%A4%BA.png" alt="JSON对象表示"></p>
<p>Array:使用中括号[]来起始，并用逗号，来分割元素</p>
<p><img src="http://cdn1.hikariblog.cn/JSON%E6%95%B0%E7%BB%84%E8%A1%A8%E7%A4%BA.png" alt="JSON数组表示"></p>
<p>基本类型</p>
<p>​    string,number,true,false,null</p>
<h4 id="Java中两种常见的JSON处理方式"><a href="#Java中两种常见的JSON处理方式" class="headerlink" title="Java中两种常见的JSON处理方式"></a>Java中两种常见的JSON处理方式</h4><p>Json中没有日期这样的数据格式，所以要采用字符串或数字的时间戳来表示</p>
<p>Json本身不支持任何形式的注释！！</p>
<p>能自动将Java中的对象转换为Json吗？</p>
<h6 id="Json-In-Java"><a href="#Json-In-Java" class="headerlink" title="Json In Java"></a>Json In Java</h6><p>Java中有许多Json的Jar包，如</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.json/json --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.json<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>json<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>20190722<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如何使用Json生成我们想要的JSON数据，有两种方法</p>
<ol>
<li>使用JsonObject生成Json格式的数据</li>
</ol>
<h4 id="综合运用"><a href="#综合运用" class="headerlink" title="综合运用"></a>综合运用</h4><p>idea快捷键</p>
<p>Ctrl+Shift+O : 将没有用到的包去掉</p>
<h1 id="SpringBoot响应客户端渲染数据"><a href="#SpringBoot响应客户端渲染数据" class="headerlink" title="SpringBoot响应客户端渲染数据"></a><code>SpringBoot</code>响应客户端渲染数据</h1><ul>
<li><p><code>SpringBoot</code>构造并返回一个json对象，注意在实际的开发中肯定不会单单返回JSON数据，会对JSON格式的数据进行进一步的封装。具体见Spring In Action书籍P440.</p>
<p><code>@Responsebody</code>:将对象转换为资源表述(如JSON或XML)。</p>
<p><code>@RequestBody</code>:将资源表述转换为对象。</p>
<p>使用<code>@RESTController</code>代替<code>@Controller</code>，Spring将会为该控制器的所有处理方法应用消息转换功能。我们不必再为每个方法都添加 <code>@Responsebody</code> 注解。</p>
<p><img src="http://cdn1.hikariblog.cn/JSON%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85.png" alt="JSON数据封装"></p>
</li>
</ul>
<ul>
<li><p>Jackson基本演绎法</p>
<p><code>@JacksonIgnore</code>注解某一个字段就可以在返回给前端的该对象从JSON数据移除这个属性</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>经典同步问题——生产者/消费者模式</title>
    <url>/2019/09/19/%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>一对一交替打印:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hogan_Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-09-19 9:10</span></span><br><span class="line"><span class="comment"> * 生产者/消费者模式:一对一交替打印</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P_C</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition=lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> hasValue=<span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (hasValue==<span class="keyword">true</span>)&#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"producer"</span>);</span><br><span class="line">            hasValue=<span class="keyword">true</span>;</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (hasValue==<span class="keyword">false</span>)&#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"customer"</span>);</span><br><span class="line">            hasValue=<span class="keyword">false</span>;</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>SpringAOP</title>
    <url>/2019/09/13/SpringAOP/</url>
    <content><![CDATA[<p>&emsp;&emsp;日常开发中都是直接使用AOP框架进行开发的，对于基于JDK动态代理的AOP传统开发一知半解，所以花一些时间来整理一下。</p>
<ul>
<li><p>AOP的概述</p>
<p>什么是AOP？</p>
<ul>
<li>AOP Aspect Oriented Programing 面向切面编程</li>
<li>AOP采取<strong>横向抽取机制</strong>，取代了<strong>传统纵向继承体系</strong>来（减少重复性代码（性能监视、事务管理、安全检查、缓存））</li>
<li>Spring AOP使用纯JAVA实现，不需要专门的编译过程和类加载器，在运行期通过<strong>代理方式</strong>向目标类织入增强代码。</li>
</ul>
<p>AOP相关术语</p>
<ul>
<li>Jointpoint（连接点）:所谓连接点是指那些可以被拦截到的点。在Spring中，这些点指的是方法，因为spring只支持方法类型的连接点</li>
<li>Pointcut（切入点）:所谓切入点是指我们要对哪些JoinPoint进行拦截的定义。</li>
</ul>
</li>
<li><p>AOP的底层实现</p>
</li>
<li><p>Spring的传统AOP</p>
<ul>
<li>不带切入点的切面</li>
<li>带有切入点的切面</li>
</ul>
</li>
<li><p>Spring的传统AOP的自动代理</p>
<ul>
<li>基于Bean名称的自动代理</li>
<li>基于切面信息的自动代理</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>面试题3:数组中重复的数字</title>
    <url>/2019/09/06/%E9%9D%A2%E8%AF%95%E9%A2%983-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<blockquote class="blockquote-center"><p>&emsp;&emsp;题目一：找出数组中重复的数字。</p>
<p>&emsp;&emsp;在一个长度为n的数组里的所有数字都在0~n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2，3，1，0，2，5，3}，那么对应的输出是重复的数字2或者3。</p>
</blockquote>

<a id="more"></a>

<blockquote class="blockquote-center"><p>&emsp;&emsp;题目二：不修改数组找出重复的数字。</p>
<p>&emsp;&emsp;在一个长度为n+1的数组里的所有数字都在1~n的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为8的数组{2，3，5，4，3，2，6，7}，那么对应弄个的输出是重复的数字2或者3。</p>
</blockquote>]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>面试题10:斐波那契数列</title>
    <url>/2019/09/04/%E9%9D%A2%E8%AF%95%E9%A2%9810-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<blockquote class="blockquote-center"><p>题目一：求斐波那契数列的第n项。写一个函数，输入n，求斐波那契（Fibonacci）数列的第n项。斐波那契数列的定义如下：</p>
</blockquote>

<p>$$<br>f(n)=\begin{cases}<br>0, &amp; \text{$ n=0 $}\\<br>1, &amp; \text{$ n=1 $}\\<br>f(n-1)+f(n-2), &amp; \text{$ n&gt;1 $}<br>\end{cases}<br>$$</p>
<a id="more"></a>

<ol>
<li><p><strong>递归解法</strong></p>
<p>&emsp;&emsp;斐波那契数列采用递归解法相对而言比较容易实现，直接分支语句列出斐波那契数列的分段函数即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> fibonacci(n-<span class="number">1</span>)+fibonacci(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;但是递归解法并不是最适合这道题目的，它存在很严重的效率问题。例如，想求得f(10)，需要先求得f(9)和f(8)。同样，想求得f(9)，需要先求得f(8)和f(7)……我们可以使用树形结构来表示这种依赖关系，如下图</p>
<p><img src="http://cdn1.hikariblog.cn/%E5%9B%BE%E7%89%871.png" alt=""></p>
<p>&emsp;&emsp;很明显，在这棵树中有很多节点是重复的，而且重复的节点数会随着n的增大而急剧增加，这意味着计算量会随着n的增大而急剧增大。事实上，用递归方法计算的时间复杂度是以n的指数的方式递增的。我们不妨设想到第100项，会有多少重复项，会进行多少重复的运算！！！</p>
</li>
<li><p><strong>循环解法</strong></p>
<p>&emsp;&emsp;第一种解法效率低的原因是存在大量的重复项，所以我们只需要避开这些重复项即可。把递归的算法用循环实现就可以避开重复项从而达到提高时间效率的目的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(N&lt;<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    <span class="keyword">int</span> x1=<span class="number">0</span>,x2=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        result=x1+x2;</span><br><span class="line">        x1=x2;</span><br><span class="line">        x2=result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote class="blockquote-center"><p>青蛙跳台阶问题。一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个n级台阶总共有多少种跳法。</p>
</blockquote>]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>面试题6:从尾到头打印链表</title>
    <url>/2019/09/04/%E9%9D%A2%E8%AF%95%E9%A2%986-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<blockquote class="blockquote-center"><p>题目：输入一个链表的头节点，从尾到头反过来打印出每个节点的值。链表节点定义如下：</p>
</blockquote>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    ListNode next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解法一：借助于栈作为中间存储区来实现从尾到头反过来打印</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printLinkedList1</span><span class="params">(ListNode listNode)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果为空链表就直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(listNode==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开辟栈作为中间存储区</span></span><br><span class="line">    Stack&lt;Integer&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="comment">//从头到尾依次将链表中的元素存放到栈中</span></span><br><span class="line">    <span class="keyword">while</span>(listNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        stack.push(listNode.data);</span><br><span class="line">        listNode=listNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//借助栈的“先进后出”特性实现链表的反向打印</span></span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        System.out.println(stack.pop()+<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：Java标准类库中包含的栈实现类</p>
<blockquote>
<p>java.util.Stack<E> 1.0</p>
</blockquote>
<ul>
<li><p>E push(E item)</p>
<p>将item压入栈并返回item。</p>
</li>
<li><p>E pop()</p>
<p>弹出并返回栈顶的item。如果栈为空，请不要调用这个方法。</p>
</li>
<li><p>E peek()</p>
<p>返回栈顶元素，但不弹出。如果栈为空，请不要调用这个方法。</p>
</li>
</ul>
<p><strong>解法二：因为递归本质上也是栈结构，利用递归进行实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printLinkedList2</span><span class="params">(ListNode listNode)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ListNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(listNode.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            printLinkedList(LisstNode.next)</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(listNode.data+<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归解法的缺点：当链表非常长的时候，就会导致函数调用的层次很深，从而有可能导致函数调用栈溢出。显然用栈基于循环实现的代码的鲁棒性要好一些。</p>
]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
  </entry>
  <entry>
    <title>面试题9:用两个栈实现队列</title>
    <url>/2019/09/04/%E9%9D%A2%E8%AF%95%E9%A2%989-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>死锁</title>
    <url>/2019/08/31/%E6%AD%BB%E9%94%81/</url>
    <content><![CDATA[<h3 id="一、死锁的概念"><a href="#一、死锁的概念" class="headerlink" title="一、死锁的概念"></a><em>一、死锁的概念</em></h3><p>&emsp;&emsp;死锁是指在一个进程集合中的所有进程都在等待只能由该集合中的其他一个进程才能引发的事件而无限期僵持下去的局面。</p>
<h3 id="二、死锁产生的原因和条件"><a href="#二、死锁产生的原因和条件" class="headerlink" title="二、死锁产生的原因和条件"></a><em>二、死锁产生的原因和条件</em></h3><h4 id="死锁产生的原因可以总结为下面两点："><a href="#死锁产生的原因可以总结为下面两点：" class="headerlink" title="死锁产生的原因可以总结为下面两点："></a>死锁产生的原因可以总结为下面两点：</h4><ol>
<li><p><strong>资源竞争（请求同种类型的不可剥夺资源）</strong></p>
<p>&emsp;&emsp;系统资源不足是产生死锁的根本原因。例如，系统中有三个进程A、B、C，其对不可剥夺资源D的需求分别为3、5、2，资源D的总数量为6，当前已分别分配给A、B、C的资源数为1、4、1，此时三个进程都没有拿到足够数量的资源D，但系统中也没有空闲的此类资源，三个进程都要等待其他进程完成后释放资源D才能继续进行，同时又由于自身没有完成而不能推进并最终释放资源，显然此时三个进程互相等待，进入死锁状态。</p>
<p>&emsp;&emsp;当然，系统资源不足时也并不一定就会引起死锁。只要并发进程之间的推进顺序合理，也可能不会引起死锁。</p>
</li>
<li><p><strong>资源的请求或释放顺序不当（请求多种不同类型的不可剥夺资源）</strong></p>
</li>
</ol>
<h4 id="产生死锁的四个必要条件："><a href="#产生死锁的四个必要条件：" class="headerlink" title="产生死锁的四个必要条件："></a>产生死锁的四个必要条件：</h4><ol>
<li><p><strong>互斥条件</strong></p>
<p>在一段时间内，某个资源只能被一个进程使用，如果其他进程提出使用申请，那么后到进程只能等待该资源被当前进程释放后才能使用，即进程对已获取的资源进行排他性使用。即临界资源。</p>
</li>
<li><p><strong>不剥夺条件</strong></p>
<p>进程所获得的资源在未使用完毕前，其他进程不能强行剥夺，而只能等待使用该资源的进程完成任务后自行释放。</p>
</li>
<li><p><strong>请求与保持条件</strong></p>
<p>已经获取了一部分资源的若又提出新资源申请，且新资源已被别的进程占用时，该进程阻塞自身，并在保持已经获取到的资源的同时等待其他进程释放其他资源。</p>
</li>
<li><p><strong>环路条件</strong></p>
<p>在死锁发生时，必然存在一个进程——资源循环等待链，链中每一个进程已获得的资源都同时被下一个进程所请求。</p>
</li>
</ol>
<h3 id="三、死锁的避免"><a href="#三、死锁的避免" class="headerlink" title="三、死锁的避免"></a><em>三、死锁的避免</em></h3><ul>
<li><p>用Java写一个会导致死锁的程序，你将怎么解决？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用匿名内部类实现一个死锁</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hogan_Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-08-31 7:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义临界资源</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object resourceA = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object resourceB = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="comment">//定义线程的名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String ThreadA = <span class="string">"A"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String ThreadB = <span class="string">"B"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义线程A，先后对资源resourceA和resourceB发起请求</span></span><br><span class="line">        Thread A = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (resourceA) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"获得resourceA"</span>);</span><br><span class="line">                    <span class="comment">//休眠2秒，确保线程B持有resourceB</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">synchronized</span> (resourceB) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"获得resourceB"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, ThreadA);</span><br><span class="line">        <span class="comment">//定义线程B，先后对资源resourceB和resourceA发起请求</span></span><br><span class="line">        Thread B = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (resourceB) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"获得resourceB"</span>);</span><br><span class="line">                    <span class="comment">//休眠2秒，确保线程A持有resourceA</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">synchronized</span> (resourceA) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"获得resourceA"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, ThreadB);</span><br><span class="line">        A.start();</span><br><span class="line">        B.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 使用Lambda表达式实现一个死锁</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- <span class="doctag">@author</span> Hogan_Lee</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- <span class="doctag">@create</span> 2019-11-27 12:38</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Deadlock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//临界资源1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object object1=<span class="keyword">new</span> Object();</span><br><span class="line">    <span class="comment">//临界资源2</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object object2=<span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (object1)&#123;</span><br><span class="line">             System.out.println(Thread.currentThread().getName()+<span class="string">"取得object1的锁"</span>);</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">             &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">synchronized</span> (object2)&#123;</span><br><span class="line">                 System.out.println(Thread.currentThread().getName()+<span class="string">"取得object2的锁"</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;,<span class="string">"Thread1"</span>).start();</span><br><span class="line">     <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (object2)&#123;</span><br><span class="line">             System.out.println(Thread.currentThread().getName()+<span class="string">"取得object2的锁"</span>);</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">             &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">synchronized</span> (object1)&#123;</span><br><span class="line">                 System.out.println(Thread.currentThread().getName()+<span class="string">"取得object1的锁"</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;,<span class="string">"Thread2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;首先创建了两个资源，并创建了两个线程，线程调度器先调度了线程 A，也就是把 CPU 资源让给了线程 A，线程 A 调用了 getResourceA() 方法，方法里面使用 synchronized(resourceA) 方法获取到了 resourceA 的监视器锁，然后调用 sleep 函数休眠 1s，休眠 1s 是为了保证线程 A 在执行 getResourceB 方法前让线程 B 抢占到 CPU 执行 getResourceB 方法。线程 A 调用了 sleep 后线程 B 会执行 getResourceB 方法里面的 synchronized(resourceB)，代表线程 B 获取到了 objectB 对象的监视器锁资源，然后调用 sleep 函数休眠 1s。</p>
<p>&emsp;&emsp;到了这里线程 A 获取到了 objectA 的资源，线程 B 获取到了 objectB 的资源。线程 A 休眠结束后会调用 getResouceB 方法企图获取到 objectB 的资源，而 objectB 资源被线程 B 所持有，所以线程 A 会被阻塞而等待。而同时线程 B 休眠结束后会调用 getResourceA 方法企图获取到 objectA 上的资源，而资源 objectA 已经被线程 A 持有，所以线程 A 和 B 就陷入了相互等待的状态，也就产生了死锁。</p>
<p>&emsp;&emsp;那么如何规避死锁呢？其实造成死锁的原因和申请资源的顺序有很大关系。使用资源申请的有序性原则就可以避免死锁。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>线程通信</title>
    <url>/2019/08/23/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<h3 id="使用等待-通知机制实现线程间的通信"><a href="#使用等待-通知机制实现线程间的通信" class="headerlink" title="使用等待/通知机制实现线程间的通信"></a><em>使用等待/通知机制实现线程间的通信</em></h3><ol>
<li>方法wait()的作用是是当前执行的线程进行等待。</li>
</ol>
<h3 id="生产者-消费者模式的实现"><a href="#生产者-消费者模式的实现" class="headerlink" title="生产者/消费者模式的实现"></a><em>生产者/消费者模式的实现</em></h3><h3 id="方法join的使用"><a href="#方法join的使用" class="headerlink" title="方法join的使用"></a><em>方法join的使用</em></h3><h3 id="ThreadLocal类的使用"><a href="#ThreadLocal类的使用" class="headerlink" title="ThreadLocal类的使用"></a><em>ThreadLocal类的使用</em></h3>]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构之链表</title>
    <url>/2019/08/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>&emsp;&emsp;由于本人大学期间对数据结构的学习都是基于c语言，Java又采用了内存自动分配和垃圾回收技术，远离了内存管理的高墙，所以我很好奇基于Java的链表在少了c语言的指针之后又是如何进行实现的呢？</p>
<p>&emsp;&emsp;动态数组 和基于动态数组的栈 队列这三种数据结构是靠重新分配内存解决固定容量问题，底层还是依托静态数组，则所谓的动态是从用户的角度来体现的。而链表则是一种<span style="color:red">真正的、最简单的动态数据结构</span>。通过对链表的学习，我们可以更加深刻的理解<span style="color:blue">引用（或者指针）、递归</span>等知识点;辅助组成其他数据结构，栈也可以通过链表来实现。</p>
<h3 id="Linked-List-链表"><a href="#Linked-List-链表" class="headerlink" title="Linked List(链表)"></a>Linked List(链表)</h3><p><img src="http://cdn1.hikariblog.cn/%E9%93%BE%E8%A1%A8.png" alt="链表"></p>
<ul>
<li><p>数据存储在“节点”（Node）中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="comment">//数据</span></span><br><span class="line">    E e;</span><br><span class="line">    <span class="comment">//通过节点类型的引用--指向下一个节点，相当于c语言中的指针</span></span><br><span class="line">    Node next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一个节点指向null</p>
<ul>
<li>优点：真正的动态，不需要处理固定容量的问题。</li>
<li>缺点：丧失了随机访问的能力。</li>
</ul>
</li>
<li><p>数组和链表的对比</p>
<ul>
<li>数组最好用于索引有语意的情况。scores[2]</li>
<li>最大的优点：支持快速查询</li>
<li></li>
<li>链表不适用于索引有语意的情况。</li>
<li>最大的优点：动态。</li>
</ul>
</li>
</ul>
<h5 id="自定义链表"><a href="#自定义链表" class="headerlink" title="自定义链表"></a>自定义链表</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hogan_Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-08-20 16:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//链表的节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> E e;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e, Node next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.e = e;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>(e, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> e.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        head=<span class="keyword">null</span>;</span><br><span class="line">        size=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取链表中元素的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回链表是否为null</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在（链表头）添加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addfirst</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">        <span class="comment">//Node node=new Node(e);</span></span><br><span class="line">        <span class="comment">//node.next=head;</span></span><br><span class="line">        <span class="comment">//head=node;</span></span><br><span class="line">        head=<span class="keyword">new</span> Node(e,head);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Path环境变量</title>
    <url>/2019/08/11/Path%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<p>&emsp;&emsp;当我们安装各种软件的时候经常需要配置Path环境变量，但是为什么要这样子配置呢？其实原因很简单，当我们在cmd中输入命令时，Windows首先会在当前目录中寻找可执行文件或脚本，如果没有找到，Windows会接着遍历环境变量Path中定义的路径。</p>
<p>&emsp;&emsp;Path环境变量的作用就是使得在任何目录下都可以执行该目录下的可执行文件或脚本。同时很多软件的可执行文件或脚本都是放在bin目录下，所以Path环境变量要配置到bin目录。</p>
]]></content>
      <categories>
        <category>计算机常识</category>
      </categories>
  </entry>
  <entry>
    <title>ElasticSearch全文搜索</title>
    <url>/2019/08/09/ElasticSearch%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h2 id="全文搜索"><a href="#全文搜索" class="headerlink" title="_全文搜索_"></a>_<span style="color:SeaGreen">全文搜索</span>_</h2><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><em>数据结构</em></h5><ul>
<li>结构化：指具有固定格式或有限长度的数据，如数据库，元数据等。</li>
<li>非结构化：指不定长或无固定格式的数据，如邮件，word文档等。</li>
</ul>
<h6 id="非结构化数据的检索"><a href="#非结构化数据的检索" class="headerlink" title="非结构化数据的检索"></a><em>非结构化数据的检索</em></h6><ul>
<li><p>顺序扫描法（Serial Scanning）</p>
</li>
<li><p>全文搜索（Full-text Search）：全文搜索是一种将文件中所有文本与搜索项匹配的文字资料检索的方法。</p>
<ul>
<li>全文搜索实现原理</li>
</ul>
<p><img src="http://cdn1.hikariblog.cn/%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt=""></p>
<ul>
<li>全文搜索实现技术（基于Java的开源实现）<ul>
<li>Lucene</li>
<li>ElasticSearch</li>
<li>Solr</li>
</ul>
</li>
</ul>
<p>将非结构化数据转换成结构化数据，建立索引后进行搜索</p>
</li>
</ul>
<h3 id="ElasticSearch简介"><a href="#ElasticSearch简介" class="headerlink" title="ElasticSearch简介"></a><em>ElasticSearch简介</em></h3><h5 id="ElasticSearch是什么？"><a href="#ElasticSearch是什么？" class="headerlink" title="ElasticSearch是什么？"></a><em>ElasticSearch是什么？</em></h5><ul>
<li>高度可扩展的开源全文搜索和分析引擎</li>
<li>快速地、近实时地对大数据进行存储、搜索和分析</li>
<li>用来支撑有复杂的数据搜索需求的企业级应用</li>
</ul>
<h5 id="ElasticSearch特点"><a href="#ElasticSearch特点" class="headerlink" title="ElasticSearch特点"></a><em>ElasticSearch特点</em></h5><ul>
<li>分布式</li>
<li>高可用</li>
<li>多类型</li>
<li>多API  支持HTTPRESTful</li>
<li>面向文档</li>
<li>异步写入</li>
<li>近实时</li>
<li>基于Lucene</li>
<li>Apache协议</li>
</ul>
<h5 id="ElasticSearch核心概念"><a href="#ElasticSearch核心概念" class="headerlink" title="ElasticSearch核心概念"></a><em>ElasticSearch核心概念</em></h5><ul>
<li>近实时</li>
<li>集群</li>
<li>节点</li>
<li>索引</li>
<li>类型</li>
<li>文档</li>
<li>分片</li>
<li>副本</li>
</ul>
<h3 id="Elasticsearch与Spring-Boot集成"><a href="#Elasticsearch与Spring-Boot集成" class="headerlink" title="Elasticsearch与Spring Boot集成"></a><em>Elasticsearch与Spring Boot集成</em></h3><p>配置环境</p>
<ul>
<li><p>Elasticsearch</p>
</li>
<li><p>Spring Data Elasticsearch（Spring对Elasticsearch的支持）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 添加Spring Data Elasticsearch的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>JNA 4.3.0（用来访问操作系统原生的一些应用）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 添加JNA的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.java.dev.jna<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jna<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>bootstrap</title>
    <url>/2019/08/09/bootstrap/</url>
    <content><![CDATA[<h3 id="集成Bootstrap"><a href="#集成Bootstrap" class="headerlink" title="集成Bootstrap"></a><em>集成Bootstrap</em></h3><ul>
<li><p>Bootstrap简介、核心概念</p>
<ul>
<li><p>基于HTML、CSS、JavaScript的前端框架</p>
</li>
<li><p>响应式布局</p>
</li>
<li><p>移动设备优先</p>
</li>
<li><p>遵循html5规范(如果不是html5可能会出现一系列的问题)</p>
</li>
<li><p>响应式meta标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1,shrink-to-fit=no"</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Normalize.css</p>
<ul>
<li>使用Normalize来建立跨浏览器的一致性</li>
<li>Reboot</li>
</ul>
</li>
</ul>
</li>
<li><p>Bootstrap网格系统</p>
<ul>
<li><p>基础的CSS是移动优先。优先设计更小的宽度</p>
</li>
<li><p>媒体查询。针对与平板电脑、台式电脑</p>
</li>
<li><p>渐进增强。随着屏幕大小的增加而增加元素。</p>
</li>
<li><p>响应式：viewport尺寸的增加，系统会自动分为最多12列，根据屏幕宽度进行响应。</p>
<p><img src="http://cdn1.hikariblog.cn/Bootstrap%E7%BD%91%E6%A0%BC%E9%80%89%E9%A1%B9.png" alt=""></p>
</li>
</ul>
</li>
<li><p>Bootstrap网格示例</p>
<p>移动设备及桌面设备<code>.col-xs-*</code>、<code>.col-md-*</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Stack the columns on mobile one full-width and the other half-width --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"raw"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-xs-12 col-md-8"</span>&gt;</span></span><br><span class="line">        .col-xs-12 .col-md-8</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-xs-6 col-md-4"</span>&gt;</span></span><br><span class="line">        .col-xs-6 .col-md-4</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li>Bootstrap与Spring Boot集成</li>
<li>Bootstrap实战</li>
</ul>
<p>剧情：引入样式表，套样式。</p>
<h3 id="Bootstrap与Spring-Boot集成"><a href="#Bootstrap与Spring-Boot集成" class="headerlink" title="Bootstrap与Spring Boot集成"></a><em>Bootstrap与Spring Boot集成</em></h3><h5 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a><em>配置环境</em></h5><ul>
<li><p>Tether 1.4.0：<a href="http://tether.io/" target="_blank" rel="noopener">http://tether.io/</a></p>
<p>Bootstrap中的一些样式依赖于Tether来实现的</p>
</li>
<li><p>Bootstrap v4.0.0-alpha.6：<a href="https://v4-alpha.getbootstrap.com" target="_blank" rel="noopener">https://v4-alpha.getbootstrap.com</a></p>
</li>
<li><p>JQuery 3.1.1:<a href="http://jquery.com/download/" target="_blank" rel="noopener">http://jquery.com/download/</a></p>
</li>
</ul>
<p>常用前端框架与Spring Boot集成</p>
<ul>
<li>Font Awesome 4.7.0：<a href="http://fontawesome.io" target="_blank" rel="noopener">http://fontawesome.io</a> 图标库</li>
<li>NProgress 0.2.0:<a href="http://ricostacruz.com/nprogress/" target="_blank" rel="noopener">http://ricostacruz.com/nprogress/</a> 进度条</li>
<li>Thinker-md：<a href="http://git.oschina.net/benhail/thinker-md" target="_blank" rel="noopener">http://git.oschina.net/benhail/thinker-md</a> 使编辑器支持MarkDown语法</li>
<li>JQuery Tags Input 1.3.6：<a href="http://xoxco.com/projects/code/tagsinput/" target="_blank" rel="noopener">http://xoxco.com/projects/code/tagsinput/</a></li>
<li>Bootstrap Chosen 1.0.3：<a href="https://github.com/haubek/bootstrap4c-chosen" target="_blank" rel="noopener">https://github.com/haubek/bootstrap4c-chosen</a></li>
<li>toastr 2.1.1：<a href="http://www.toastrjs.com" target="_blank" rel="noopener">http://www.toastrjs.com</a> 响应处理如出错警示</li>
</ul>
<p>下载下来放到static包里面，</p>
<p>css一般在head中引入，js在body的底部进行引入，js较大最后加载对性能优化较好</p>
<p>css放在header中，js放在footer里面</p>
]]></content>
      <categories>
        <category>Bootstrap</category>
      </categories>
  </entry>
  <entry>
    <title>SpringDataJPA</title>
    <url>/2019/08/09/SpringDataJPA/</url>
    <content><![CDATA[<h3 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a><em>数据持久化</em></h3><ul>
<li>JPA简介<ul>
<li>JPA（Java Persistence API）是用于管理Java EE和Java SE环境中的持久化，以及对象/关系映射的Java API</li>
<li>最新规范为“JSR 338”</li>
<li>实现：EclipseLink、Hibernate、Apache OpenJPA</li>
</ul>
</li>
<li>Spring Data JPA用法介绍</li>
<li>Spring Data JPA、Hibernate与Spring Boot集成</li>
<li>数据持久化实战</li>
</ul>
<h5 id="JPA核心概念"><a href="#JPA核心概念" class="headerlink" title="JPA核心概念"></a><em>JPA核心概念</em></h5><p><strong>实体</strong></p>
<ul>
<li>实体表示关系数据库中的表</li>
<li>每个实体实例对应与该表中的行</li>
<li>类必须用javax.persistence.Entity注解</li>
<li>类必须有一个public或protected的无参数的构造函数</li>
<li>实体实例被当作值以分离对象方式进行传递（例如通过会话bean的远程业务接口），则该类必须实现Serializable接口</li>
<li>唯一的对象标识符：简单主键（javax.persistence.id)、复合主键（javax.persistence.Embeddedld和javax.persistence.IdClass)</li>
</ul>
]]></content>
      <categories>
        <category>Spring Data JPA</category>
      </categories>
  </entry>
  <entry>
    <title>gradle</title>
    <url>/2019/08/06/gradle/</url>
    <content><![CDATA[<h2 id="新一代构建工具Gradle"><a href="#新一代构建工具Gradle" class="headerlink" title="新一代构建工具Gradle"></a>新一代构建工具Gradle</h2><h3 id="1-Gradle是什么？"><a href="#1-Gradle是什么？" class="headerlink" title="1 Gradle是什么？"></a><em>1 Gradle是什么？</em></h3><p>&emsp;&emsp;一个开源的<span style="color:red">项目自动化构建工具</span>，建立在 <code>Apache Ant</code> 和 <code>Apache Maven</code> 概念的基础上，并引入了基于 <code>Groovy</code> 的特定领域语言（DSL），而不在使用XML形式管理构建脚本，能具有更高的灵活性和可拓展性。</p>
<h5 id="1-1-Gradle安装"><a href="#1-1-Gradle安装" class="headerlink" title="1.1 Gradle安装"></a><em>1.1 Gradle安装</em></h5><ul>
<li>确保电脑上已经安装JDK，可以通过 <code>java -version</code> 命令进行确认。</li>
<li>从Gradle官网下载Gradle，<a href="http://gradle.org" target="_blank" rel="noopener">http://gradle.org</a></li>
<li>配置环境变量，<span style="color:red">GRADLE_HOME</span></li>
<li>添加到Path，<span style="color:red">%GRADLE_HOME%\bin;</span></li>
<li>验证是否安装成功，<span style="color:red">gradle -v</span></li>
</ul>
<h3 id="2-Groovy是什么？"><a href="#2-Groovy是什么？" class="headerlink" title="2 Groovy是什么？"></a><em>2 Groovy是什么？</em></h3><p>&emsp;&emsp;<code>Groovy</code> 是用于 <code>Java</code> 虚拟机的一种敏捷的动态语言，它是一种成熟的面向对象编程语言，既可以用于面向对象编程，又可以用作纯粹的脚本语言。使用该种语言不必编写过多的代码，同时又具有闭包和动态语言中的其他特性。</p>
<p>与 <code>Java</code> 比较</p>
<ul>
<li><p><code>Groovy</code> 完全兼容 <code>Java</code> 的语法</p>
</li>
<li><p>分号是可选的</p>
</li>
<li><p>类、方法默认是 <code>public</code> 的，没有 <code>default</code> 这种访问权限</p>
</li>
<li><p>编译器给属性自动添加getter/setter方法</p>
</li>
<li><p>属性可以直接用点号获取</p>
</li>
<li><p>最后一个表达式的值会被作为返回值</p>
</li>
<li><p>==等同于equals()，不会抛空指针异常</p>
</li>
<li><p>assert语句</p>
</li>
<li><p>弱类型 如def 变量。会自动推断</p>
</li>
<li><p>可选的括号</p>
</li>
<li><p>字符串</p>
<p>单引号：仅仅是字符串</p>
<p>双引号：可以通过${}插入变量</p>
<p>三引号：可以换行</p>
</li>
<li><p>集合API</p>
</li>
<li><p>闭包</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Spring Security</title>
    <url>/2019/08/06/Spring-Security/</url>
    <content><![CDATA[<p>SpringSecurity官方文档笔记：</p>
]]></content>
      <categories>
        <category>Spring Security</category>
      </categories>
  </entry>
  <entry>
    <title>JSP终结者——Thymeleaf</title>
    <url>/2019/08/06/JSP%E7%BB%88%E7%BB%93%E8%80%85%E2%80%94%E2%80%94Thymeleaf/</url>
    <content><![CDATA[<ul>
<li><p>理解Thymeleaf的概念、用法</p>
<ul>
<li>Java模板引擎。能够处理HTML、XML、JavaScript、CSS甚至纯文本。类似JSP、Freemarker</li>
<li>自然模板。原型即页面</li>
<li>语法优雅简单。OGNL、SpringEL表达式</li>
<li>遵从Web标准。支持HTML5</li>
</ul>
<h6 id="Thymeleaf标准方言"><a href="#Thymeleaf标准方言" class="headerlink" title="Thymeleaf标准方言"></a><em>Thymeleaf标准方言</em></h6><ol>
<li><code>&lt;span th:text=&quot;……&quot;&gt;</code>    </li>
<li><code>&lt;span data-th-text=&quot;……&quot;&gt;</code>    data前缀用于自定义属性，可以省去引入命名空间</li>
</ol>
<p>&emsp;&emsp;Both notations are completely equivalent and interchangeable, but for the sake of simplicity and compactness of the code samples, this tutorial will use the <em>namespace notation</em> (<code>th:*</code>). Also, the <code>th:*</code>notation is more general and allowed in every Thymeleaf template mode (<code>XML</code>, <code>TEXT</code>…) whereas the <code>data-</code>notation is only allowed in <code>HTML</code> mode.</p>
<h6 id="Thymeleaf命名空间的引入"><a href="#Thymeleaf命名空间的引入" class="headerlink" title="Thymeleaf命名空间的引入"></a><em>Thymeleaf命名空间的引入</em></h6><p><code>&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</code></p>
</li>
</ul>
<p>例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">"$&#123;name&#125;"</span>&gt;</span></span><br><span class="line">    fskfh</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>运行时，text标签中的内容会覆盖掉p容器标签包含的内容</p>
<p><img src="http://cdn1.hikariblog.cn/%E6%A0%87%E5%87%86%E6%96%B9%E8%A8%80.png" alt="标准方言"></p>
<h5 id="变量表达式"><a href="#变量表达式" class="headerlink" title="变量表达式"></a><em>变量表达式</em></h5><p><strong>语法：${…}</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;book.author.name&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="消息表达式"><a href="#消息表达式" class="headerlink" title="消息表达式"></a><em>消息表达式</em></h5><p><strong>语法：#{…}</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    …</span><br><span class="line">    <span class="comment">&lt;!-- 消息的一个key --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span> <span class="attr">th:text</span>=<span class="string">"#&#123;header.address.city&#125;"</span>&gt;</span>…<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span> <span class="attr">th:text</span>=<span class="string">"#&#123;header.address.country&#125;"</span>&gt;</span>…<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    …</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>也称为文本外部化、国际化或i18n</li>
</ul>
<h5 id="选择表达式"><a href="#选择表达式" class="headerlink" title="选择表达式"></a><em>选择表达式</em></h5><p><strong>语法：*{…}</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:object</span>=<span class="string">"$&#123;book&#125;"</span>&gt;</span></span><br><span class="line">    …</span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"*&#123;title&#125;"</span>&gt;</span>…<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    …</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>与变量表达式区别：它们是在当前选择的对象而不是整个上下文变量影身上执行</li>
</ul>
<h5 id="链接表达式"><a href="#链接表达式" class="headerlink" title="链接表达式"></a><em>链接表达式</em></h5><p><strong>语法：@{…}</strong></p>
<p>链接表达式可以是相对的，在这种情况下，应用程序上下文将不会作为URL的前提</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">"@&#123;../documents/report&#125;"</span>&gt;</span>…<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>也可以是服务器相对（同样，没有应用程序上下文前提）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">"@&#123;~/contents/main&#125;"</span>&gt;</span>…<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>和协议相对（就像绝对URL，但浏览器将使用在显示的页面中使用的相同的HTTP或HTTPS协议）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">"@&#123;//static.mycompany.com/res/initial&#125;"</span>&gt;</span>…<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当然，Link表达式可以是绝对的</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">"http://www.mucompany.com/main"</span>&gt;</span>…<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="分段表达式"><a href="#分段表达式" class="headerlink" title="分段表达式"></a><em>分段表达式</em></h5><p><strong>语法：th:insert或th:replace</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:fragment</span>=<span class="string">"copy"</span>&gt;</span></span><br><span class="line">            <span class="symbol">&amp;copy;</span>2017<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.mucompany.com/main"</span>&gt;</span>ddd<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其他地方通过分段表达式实现重用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:insert</span>=<span class="string">"~&#123;footer::copy&#125;"</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="字面量-文字"><a href="#字面量-文字" class="headerlink" title="字面量(文字)"></a><em>字面量(文字)</em></h5><p><strong>文本:</strong>文本文字只是在<span style="color:red">单引号</span>之间指定的字符串。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    Now you are looking at a <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"'working web applicatio'"</span>&gt;</span>template file<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="Thymeleaf解析器级别的注释块"><a href="#Thymeleaf解析器级别的注释块" class="headerlink" title="Thymeleaf解析器级别的注释块"></a><em>Thymeleaf解析器级别的注释块</em></h6><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--/*--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">th:text</span>=<span class="string">"'加油'"</span>&gt;</span>ddddd<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--*/--&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意<code>&lt;!--/*--&gt;</code>或<code>&lt;!--*/--&gt;</code>里面不能存在空格，如果用于注释文本</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--/* This code will be removed at Thymeleaf parsing time! */--&gt;</span></span><br></pre></td></tr></table></figure>

<p>这种注释文本的情况感觉不如用html自带的<code>&lt;!-- --&gt;</code>,感觉有些鸡肋。</p>
<h6 id="原型注释块与th-block标签"><a href="#原型注释块与th-block标签" class="headerlink" title="原型注释块与th:block标签"></a><em>原型注释块与th:block标签</em></h6><p>&emsp;&emsp;<code>th:block</code>是一个纯粹的属性容器，允许模板开发人员指定他们想要的任何属性，自身没有语义。与原型注释块<code>&lt;!--/*/</code>和<code>/*/--&gt;</code>标记结合时，可用于处理<code>&lt;table&gt;</code>标签中不能包含<code>&lt;div&gt;</code>标签的场景。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--/*/ &lt;th:block th:each="user : $&#123;users&#125;"&gt; /*/--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.login&#125;"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.name&#125;"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"2"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.address&#125;"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--/*/ &lt;/th:block&gt; /*/--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>



<ul>
<li><p>Thymeleaf与Spring Boot集成</p>
<p>修改pom.xml,引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>基本设置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">thymeleaf:</span></span><br><span class="line">    <span class="comment"># 设置Thymeleaf的编码格式</span></span><br><span class="line">    <span class="attr">encoding:</span> <span class="string">UTF-8</span></span><br><span class="line">    <span class="comment"># 热部署静态文件</span></span><br><span class="line">    <span class="attr">cache:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 使用HTML5标准</span></span><br><span class="line">    <span class="attr">mode:</span> <span class="string">HTML5</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Thymeleaf实战</p>
</li>
</ul>
<p>简单用户管理：增删改查</p>
<p>API设计</p>
<ul>
<li>GET/user：返回用于展现用户列表的list.html页面</li>
<li>GET/user/{id}：返回用于展现用户的view.html页面</li>
<li>GET/users/form：返回用于新增或者修改用户的form.html</li>
<li>POST/users：新增或者修改用户，成功重定向到list.html页面</li>
<li>GET/users/delete/{id}：根据id删除相应的用户数据，成功后重定向到list.html页面</li>
<li>GET/users/modify/{id}：根据id获取相应用户的用户数据，并返回form.html页面用来执行修改</li>
</ul>
<p>后台编码</p>
<ul>
<li>实体User</li>
<li>资源库UserRepository</li>
<li>控制器UserController</li>
</ul>
<p>dao层要定义一个接口，然后面向接口编程 </p>
<p>前端编码：</p>
<ul>
<li>list.html：用于展现用户列表</li>
<li>form.html：用于新增或者修改用户资料</li>
<li>view.html：用户查看某个用户的资料</li>
<li>header.html:共用的头部页面</li>
<li>footer.html：共用的底部页面</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>SpringBoot</title>
    <url>/2019/08/05/SpringBoot/</url>
    <content><![CDATA[<ol>
<li><p>介绍Spring Boot</p>
<ul>
<li>为所有Spring开发提供一个更快更广泛的入门体验</li>
<li>开箱即用，不合适时也可以快速抛弃</li>
<li>提供一系列大型项目常用的非功能性特征</li>
<li>零配置（不需要XML配置，遵循“约定大于配置”）</li>
</ul>
<p>抛弃了传统JavaEE 项目繁琐的配置、学习过程，让企业级应用开发过程变得so easy！</p>
<p><img src="http://cdn1.hikariblog.cn/Spring%E5%BA%94%E7%94%A8%E7%9A%84%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B.png" alt="Spring应用开发流程"></p>
<p>让Spring应用开发变得简单粗暴，将之前的框架进行完美整合。</p>
<p><img src="http://cdn1.hikariblog.cn/Spring%20Boot%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B.png" alt="Spring Boot应用开发流程"></p>
<p>Spring Boot核心特性</p>
<ul>
<li>极低的学习成本</li>
<li>可独立运行的Spring项目，最后web项目打成jar包，SpringBoot在构建过程将tomcat内嵌了</li>
<li>“习惯优于配置”，极大的提高了开发效率。</li>
<li>极简的组件依赖，自动发现与自动装配</li>
<li>提供运行时的应用监控</li>
<li>与分布式架构和云计算的天然集成</li>
</ul>
</li>
<li><p>掌握Spring Boot应用的构建方法</p>
</li>
<li><p>讲解SpringBoot执行流程和配置选项</p>
</li>
</ol>
<ul>
<li><p>Spring Boot约定的目录结构（项目初期构建好）</p>
<table>
<thead>
<tr>
<th>/src/main</th>
<th>项目根目录</th>
</tr>
</thead>
<tbody><tr>
<td>/java</td>
<td>Java源代码目录</td>
</tr>
<tr>
<td>/resources</td>
<td>资源目录</td>
</tr>
<tr>
<td>/resources/static</td>
<td>静态资源目录</td>
</tr>
<tr>
<td>/resources/templates</td>
<td>表示层页面目录</td>
</tr>
<tr>
<td>/resources/application.properties</td>
<td>Spring Boot核心配置文件</td>
</tr>
<tr>
<td>/test</td>
<td>测试文件目录</td>
</tr>
</tbody></table>
</li>
<li><p>Spring boot的基础引用</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<code>spring-boot-starter-parent</code> 本身不提供依赖关系，而是提供一些配置的默认值。</p>
</li>
<li><p>真正的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将所有资源打包为一个可独立运行的jar包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>SpringBoot和Spring MVC的开发方式基本是一样的。如何启动SpringBoot呢？我们还需要编写一个入口类，一般情况下，入口类名字（项目名+Application）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">//这个注解说明这是一个SpringBoot应用的入口类，当然也可以使用@EnableAutoConfiguration 这个注解告诉Spring Boot根据你添加的jar依赖关系“猜测”你想要如何配置Spring</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySpringBootApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//启动SpringBoot应用,将入口类作为参数传递进去</span></span><br><span class="line">  SpringApplication.run(MySpringBootApplication<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>右键入口类，run</p>
<p>浏览器输入<a href="http://localhost:8080/out" target="_blank" rel="noopener">http://localhost:8080/out</a>检验</p>
</li>
</ul>
<h3 id="Spring-Initialzr构建Spring-Boot应用（超级赞）"><a href="#Spring-Initialzr构建Spring-Boot应用（超级赞）" class="headerlink" title="Spring Initialzr构建Spring Boot应用（超级赞）"></a>Spring Initialzr构建Spring Boot应用（超级赞）</h3><p>从一开始就选择Initialzr，然后该填的填一路next。</p>
<ol>
<li>自动生成SpringBoot目录结构</li>
<li>自动生成根包+入口类</li>
</ol>
<h3 id="Spring-Boot入口类"><a href="#Spring-Boot入口类" class="headerlink" title="Spring Boot入口类"></a><em>Spring Boot入口类</em></h3><ul>
<li>入口类命名通常以*Application结尾</li>
<li>入口类上增加@SpringBootApplication注解</li>
<li>利用SpringApplication.run()方法启动应用</li>
</ul>
<h3 id="Spring-Boot启动流程"><a href="#Spring-Boot启动流程" class="headerlink" title="Spring Boot启动流程"></a><em>Spring Boot启动流程</em></h3><p><img src="http://cdn1.hikariblog.cn/SpringBoot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png" alt="SpringBoot启动流程"></p>
<h3 id="Spring-Boot内置配置选项"><a href="#Spring-Boot内置配置选项" class="headerlink" title="Spring Boot内置配置选项"></a><em>Spring Boot内置配置选项</em></h3><p>在Application.properties中配置</p>
<p>日志级别：debug-&gt;info-&gt;warn-&gt;error-&gt;fatal</p>
<p>Spring boot启动后的默认级别为info</p>
<h3 id="Spring-Boot支持两种配置文件"><a href="#Spring-Boot支持两种配置文件" class="headerlink" title="Spring Boot支持两种配置文件"></a><em>Spring Boot支持两种配置文件</em></h3><ul>
<li>属性文件：application.properties</li>
<li>YAML格式：application.yml</li>
</ul>
<p>YAML的语法</p>
<p>​    YAML是一种简洁的非标记语言。YAML以数据为中心，使用空白，缩进，分行组织数据，从而使得表示更加简洁易读。相比properties更具可读性</p>
<p>​    YAML语法格式</p>
<ul>
<li>标准格式：key:(空格)value</li>
<li>使用空格代表层级关系，以”:”结束</li>
</ul>
<h3 id="Spring-Boot自定义配置项"><a href="#Spring-Boot自定义配置项" class="headerlink" title="Spring Boot自定义配置项"></a><em>Spring Boot自定义配置项</em></h3><p>&emsp;&emsp;Spring Boot允许我们自定义应用配置项，在程序运行时允许动态加载，这为程序提供了良好的可维护性。</p>
<p>外化文本是从模板文件中提取模板代码的片段，以便它们可以保存在单独的文件（通常是<code>.properties</code>文件）中，并且可以使用其他语言编写的等效文本（称为国际化或简称为<em>i18n</em>）轻松替换它们。外化的文本片段通常称为<em>“消息”</em>。</p>
<p>消息总是有一个标识它们的键，而Thymeleaf允许您指定文本应该与具有以下<code>#{...}</code>语法的特定消息相对应：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mall:</span></span><br><span class="line"> <span class="attr">config:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">博客</span></span><br><span class="line">  <span class="attr">description:</span> <span class="string">这是我的个人博客</span></span><br><span class="line">  <span class="attr">hot-sales:</span> <span class="number">20</span></span><br><span class="line">  <span class="attr">show-advert:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>使用自定义配置项</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;mall.config.name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;mall.config.description&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;mall.config.hot-sales&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer hotSales;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;mall.config.show-advert&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> Boolean showAdvert;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/out"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">out</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"name:%s,description:%s,hot-sales:%s,show-advert:%s"</span>,name,description,hotSales,showAdvert);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="环境配置文件"><a href="#环境配置文件" class="headerlink" title="环境配置文件"></a><em>环境配置文件</em></h3><ul>
<li><p>Spring Boot可针对不同的环境提供不同的Profile文件</p>
</li>
<li><p>Profile文件的默认命名格式为application-{env}.yml</p>
</li>
<li><p>使用spring.profile.active选项来指定不同的profile</p>
<p>对于多环境开发和协同开发极为重要</p>
</li>
</ul>
<h3 id="打包与运行"><a href="#打包与运行" class="headerlink" title="打包与运行"></a><em>打包与运行</em></h3><ul>
<li><p>利用Maven的package命令，生成可独立运行的jar包。（Maven实战中要说到）</p>
<p>mvn package</p>
</li>
<li><p>利用java -jar xxx.jar 命令启动Spring Boot应用</p>
</li>
<li><p>Jar包可自动加载同目录的application配置文件</p>
<p>打包后配置文件也在里面了，我们要指定profile不可能把它解压再修改吧，所以SpringBoot提供了自动解析Jar包同目录配置文件的功能。</p>
</li>
</ul>
<p>三种运行方式</p>
<ul>
<li>使用<code>java -jar</code>命令运行可执行jar包，同时可以使用<code>jar tvf</code>命令查看可执行jar包内的目录结构。</li>
<li>以“java application”运行</li>
<li>构建工具，如maven的启动命令<code>mvn spring-boot:run</code></li>
</ul>
<hr>
<p>@RestController：@Responsebody和@Controller注解的组合</p>
<hr>
<h3 id="Spring-Boot官方文档阅读笔记"><a href="#Spring-Boot官方文档阅读笔记" class="headerlink" title="Spring Boot官方文档阅读笔记"></a><em>Spring Boot官方文档阅读笔记</em></h3><h6 id="通过以下命令检查电脑上的-Java-安装情况"><a href="#通过以下命令检查电脑上的-Java-安装情况" class="headerlink" title="通过以下命令检查电脑上的 Java 安装情况"></a><em>通过以下命令检查电脑上的 <code>Java</code> 安装情况</em></h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>

<h3 id="1-Getting-Started"><a href="#1-Getting-Started" class="headerlink" title="1 Getting Started"></a><em>1 Getting Started</em></h3><p>&emsp;&emsp;The <code>spring-boot-starter-parent</code> is a special starter that peovides useful Maven defaults. The <code>mvn dependency:tree</code> command prints a tree representation of your project dependencies. You can see that <code>spring-boot-starter-parent</code> provides no dependencies by itself. To add the necessary dependencies, edit your <code>pom.xml</code> and add the <code>spring-boot-starter-web</code> dependency immediately below the <code>parent</code>section:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>spring-boot-starter-web</code> including the embed tomcat web server. </p>
<p>内嵌Servlet容器</p>
<p>maven项目依赖的生命周期怎么划分的</p>
]]></content>
  </entry>
  <entry>
    <title>栈和队列</title>
    <url>/2019/07/26/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈 Stack"></a>栈 Stack</h1><ul>
<li><p>栈也是一种线性结构</p>
</li>
<li><p>相比数组，栈对应的操作是数组的子集</p>
</li>
<li><p>只能从一端添加元素，也只能从同一端取出元素</p>
</li>
<li><p>这一端称为栈顶<img src="http://cdn1.hikariblog.cn/%E6%A0%88.png" alt="栈"></p>


</li>
</ul>
<p>栈是一种后进先出的数据结构Last In First Out（LIFO）</p>
<p>在计算机的世界里，栈拥有着不可思议的作用</p>
<p><strong>栈的应用</strong></p>
<ul>
<li><p>无处不在的Undo:<code>ctrl+z</code>、Redo:<code>ctrl+y</code></p>
</li>
<li><p>程序调用的系统栈，在方法里面调用其他的方法</p>
<p>另外，栈还用来存放线程的调用栈帧，那么什么是栈帧呢？如下代码，当我们调用 test() 方法时，就会把<span style="color:red">当前方法的一些信息封装为栈帧</span>(如方法中断执行到跳转其它方法的位置)压入到栈顶，栈顶的栈帧就是活跃的 test 方法。当执行到 say() 方法时就会在栈顶新加一个关于 say() 方法的栈帧，这时候 say() 方法所在栈帧就是活跃栈帧。当 say() 方法执行完毕后，say() 方法所在的栈顶帧就会出栈，这时候栈顶活跃帧就是 test 方法的了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">6</span>;</span><br><span class="line">    say();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>栈的基本实现</strong>(实际底层有多种实现方式)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hogan_Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-07-26 18:17</span></span><br><span class="line"><span class="comment"> * 栈</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出栈</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">E <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取栈顶元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查看栈里面元素个数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断栈是否为空</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>RESTful入门</title>
    <url>/2019/07/26/RESTful%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h2><h3 id="什么是RESTful？"><a href="#什么是RESTful？" class="headerlink" title="什么是RESTful？"></a>什么是RESTful？</h3><p>REST：Representational State Teansfer(表达性状态转移)</p>
<p>REST并不是一种创新技术，它指的是一组架构约束条件和原则</p>
<p>符合REST的约束条件和原则的架构，就称它为RESTful架构。</p>
<h3 id="RESTful核心内容"><a href="#RESTful核心内容" class="headerlink" title="RESTful核心内容"></a>RESTful核心内容</h3><ol>
<li>资源与URI(资源的地址)</li>
<li>资源的表述——JSON、XML等</li>
<li>状态转移</li>
</ol>
<h3 id="RESTful架构特点"><a href="#RESTful架构特点" class="headerlink" title="RESTful架构特点"></a>RESTful架构特点</h3><ol>
<li>统一了客户端访问资源的接口</li>
<li>url更加简洁，易于理解，便于扩展</li>
<li>有利于不同系统之间的资源共享</li>
</ol>
<h4 id="RESTful开发风格"><a href="#RESTful开发风格" class="headerlink" title="RESTful开发风格"></a>RESTful开发风格</h4><p>查询课程：<code>http://localhost:8080/course/id method=&#39;get&#39;</code></p>
<p>添加课程: <code>http://localhost:8080/course methos=&#39;post&#39;</code></p>
<p>删除课程: <code>http://localhost:8080/course/id methos=&#39;delete&#39;</code></p>
<p>修改课程: <code>http://localhost:8080/course/id method=&#39;put&#39;</code></p>
<ol>
<li><p><strong>用URL描述资源。</strong></p>
</li>
<li><p><strong>使用HTTP方法（GET、POST、DELETE、PUT、PATCH等）描述行为。</strong></p>
<p><strong>使用HTTP状态码来表示不同的结果（后台可以通过@ResponseStatus指定自定义异常处理方法的响应状态码、Spring也内置了一些场景的状态码）。</strong></p>
</li>
<li><p><strong>使用JSON交互数据，资源表述。（不一定是JSON，XML等也可以，但是JSON较流行）。</strong></p>
</li>
<li><p><strong>RESTful只是一种风格，并不是强制的标准。</strong></p>
</li>
</ol>
<p><img src="http://cdn1.hikariblog.cn/REST%E6%88%90%E7%86%9F%E5%BA%A6%E6%A8%A1%E5%9E%8B.PNG" alt="REST成熟度模型"></p>
<p>RESTful支持处理GET、POST、PUT、DELETE、PATCH</p>
<p>问题：默认是能处理GET、POST请求的，而PUT和DELETE请求是不能够处理的，通过特殊的方式将POST请求转换为PUT请求或者DELETE请求。</p>
<p>首先在web.xml中配置一个过滤器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- REST风格代码开发过滤器  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>hiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>hiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>





<p>使用Spring MVC开发Restful API.(用户增删改查TDD)</p>
<ul>
<li><p>编写第一个Restful API</p>
<ul>
<li><p><strong>编写针对RestfulAPI的测试用例（自己再去学MockMVC吧，链式编程一脸懵）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">UserControllerTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WebApplicationContext wac;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mockMvc= MockMvcBuilders.webAppContextSetup(wac).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenQuerySuccess</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String result=mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">"/user"</span>)</span><br><span class="line">                .param(<span class="string">"username"</span>,<span class="string">"xiaoming"</span>)</span><br><span class="line">                .contentType(MediaType.APPLICATION_JSON_UTF8))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.status().isOk())</span><br><span class="line">                .andExpect(MockMvcResultMatchers.jsonPath(<span class="string">"$.length()"</span>).value(<span class="number">3</span>))</span><br><span class="line">                .andReturn().getResponse().getContentAsString();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用注解声明RestfulAPI</p>
<p><code>@RestController</code> 标明此Controller提供RestAPI</p>
<p><code>@RequestMapping</code>及其变体。映射http请求url到java方法</p>
<p><code>@RequestParam</code> 映射请求参数到java方法的参数中</p>
<p><code>@PageableDefault</code> 指定分页参数的默认值 这个是SpringData的，我自己一般使用PageHelper插件</p>
</li>
<li><p>在RestfulAPI中传递参数</p>
</li>
</ul>
</li>
<li><p>编写用户详情服务</p>
<ul>
<li><p>相关注解</p>
<p><code>@PathVariable</code> 映射url片段到java方法的参数（路径参数）</p>
<ol>
<li><p>在url声明中使用正则表达式，对路径参数的格式作限定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/user/&#123;id:\\d+&#125;"</span>,method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getInfo</span><span class="params">(@PathVariable(value = <span class="string">"id"</span>)</span>String id)</span>&#123;</span><br><span class="line">    System.out.println(id);</span><br><span class="line">    User user=<span class="keyword">new</span> User();</span><br><span class="line">    user.setUsername(<span class="string">"tom"</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际业务场景可以根据需求撰写更加复杂的正则表达式</p>
</li>
</ol>
<p><code>@JsonView</code> 控制json输出内容。额，这个类似于Jackson的<code>@JsonIgnore</code>注解，但是Jackson的<code>@JsonIgnore</code>注解是一直不显示某一个属性，但是我想的是我想让他显示就显示，不想让他显示就不显示。</p>
<ol>
<li><p>使用接口来声明多个视图</p>
</li>
<li><p>在值对象的get方法上指定视图</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonView;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hogan_Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-11-15 21:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonView</span>(UserSimpleView<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">String</span> <span class="title">getUsername</span>() </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@JsonView</span>(UserDetailView<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">String</span> <span class="title">getPassword</span>() </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserSimpleView</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意：这里继承了UserSimpleView，表示不仅会显示自己的password还会显示simpleview</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDetailView</span> <span class="keyword">extends</span> <span class="title">UserSimpleView</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在Controller方法上指定视图</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonView;</span><br><span class="line">    <span class="keyword">import</span> com.imooc.dto.User;</span><br><span class="line">    <span class="keyword">import</span> org.springframework.web.bind.annotation.*; </span><br><span class="line">    <span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line">    <span class="keyword">import</span> java.util.List;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> Hogan_Lee</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@create</span> 2019-11-15 21:03</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RestController</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">        <span class="meta">@RequestMapping</span>(value = <span class="string">"/user"</span>,method = RequestMethod.GET)</span><br><span class="line">        <span class="meta">@JsonView</span>(User.UserSimpleView<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">        <span class="title">public</span> <span class="title">List</span>&lt;<span class="title">User</span>&gt; <span class="title">query</span>(@<span class="title">RequestParam</span>(<span class="title">defaultValue</span> </span>= <span class="string">"xiao"</span>) String username)&#123;</span><br><span class="line">            System.out.println(username);</span><br><span class="line">            List&lt;User&gt; users=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            users.add(<span class="keyword">new</span> User());</span><br><span class="line">            users.add(<span class="keyword">new</span> User());</span><br><span class="line">            users.add(<span class="keyword">new</span> User());</span><br><span class="line">            <span class="keyword">return</span> users;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="meta">@RequestMapping</span>(value = <span class="string">"/user/&#123;id:\\d+&#125;"</span>,method = RequestMethod.GET)</span><br><span class="line">        <span class="meta">@JsonView</span>(User.UserDetailView<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">        <span class="title">public</span> <span class="title">User</span> <span class="title">getInfo</span>(@<span class="title">PathVariable</span>(<span class="title">value</span> </span>= <span class="string">"id"</span>)String id)&#123;</span><br><span class="line">            System.out.println(id);</span><br><span class="line">            User user=<span class="keyword">new</span> User();</span><br><span class="line">            user.setUsername(<span class="string">"tom"</span>);</span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
</li>
<li><p>处理创建请求</p>
<ul>
<li><p>相关注解</p>
<p><code>@RequestBody</code> 映射请求体到java方法的参数。</p>
<ol>
<li>状态码：405请求的method后台不支持(存在url一致但是method方法不一样的处理器方法)</li>
</ol>
<p>日期类型参数</p>
<p>&emsp;&emsp;类型转换器，”YY-mm-HH”之类的并不适用与前后端分离的app；前后端分离的app可能会有多个前端，每个前端可能对日期的显示格式不一样。传不带格式的时间戳，然后前台再对它进行处理，通过时间戳可以很方便的在前台和后台的时间戳和日期格式进行转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="meta">@PostMapping</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> User <span class="title">create</span><span class="params">(@RequestBody User user)</span></span>&#123;</span><br><span class="line">       System.out.println(user);</span><br><span class="line">       user.setId(<span class="string">"1"</span>);</span><br><span class="line">       <span class="keyword">return</span> user;</span><br><span class="line">    </span><br><span class="line">   &#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenCreateSuccess</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       Date date=<span class="keyword">new</span> Date();</span><br><span class="line">       <span class="comment">//日期格式的对象的时间戳</span></span><br><span class="line">       System.out.println(date.getTime());</span><br><span class="line">    </span><br><span class="line">       <span class="comment">//JSON格式的字符串，作为post请求的内容</span></span><br><span class="line">       String content=<span class="string">"&#123;\"username\":\"tom\",\"password\":null,\"birthday\":"</span>+date.getTime()+<span class="string">"&#125;"</span>;</span><br><span class="line">       String resuslt=mockMvc.perform(MockMvcRequestBuilders.post(<span class="string">"/user"</span>)</span><br><span class="line">               .contentType(MediaType.APPLICATION_JSON_UTF8)</span><br><span class="line">               .content(content))</span><br><span class="line">               .andExpect(MockMvcResultMatchers.status().isOk())</span><br><span class="line">               .andExpect(MockMvcResultMatchers.jsonPath(<span class="string">"$.id"</span>).value(<span class="string">"1"</span>))</span><br><span class="line">               .andReturn().getResponse().getContentAsString();</span><br><span class="line">       System.out.println(resuslt);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<p><img src="http://cdn1.hikariblog.cn/%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%92%8C%E6%97%B6%E9%97%B4%E6%88%B3.PNG" alt="日期格式和时间戳"></p>
<p><code>@Vaild</code>注解和<code>BindingResult</code>验证请求参数的合法性并处理校验结果</p>
<ol>
<li><p>状态码400：请求的格式错误（如参数校验出现错误）</p>
</li>
<li><p><code>@Vaild</code>校验出错就会直接抛出异常，进不到处理器方法中。但是有的时候我们既要校验，又要对校验的结果进行日志记录，单单<code>@Vaild</code>就实现不了了。这时候就要和<code>BindingResult</code>配合使用了，如果校验有错误就会把错误放到<code>BindingResult</code>中，然后继续执行处理器方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">create</span><span class="params">(@RequestBody @Valid User user, BindingResult errors)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(errors.hasErrors())&#123;</span><br><span class="line">        <span class="comment">//lambda表达式</span></span><br><span class="line">        errors.getAllErrors().stream().forEach(error-&gt; System.out.println(error.getDefaultMessage()));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    user.setId(<span class="string">"1"</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><p>开发用户信息修改和删除服务</p>
<ul>
<li><p>数据校验</p>
<p>常用的验证注解</p>
<ol>
<li><p>@NotNull:用在基本数据类型上，不能为Null，但可以为空字符串</p>
</li>
<li><p>@NotEmpty:用在集合类上，不能为null，并且长度必须大于0</p>
</li>
<li><p>@NotBlank:只能作用在String上，不能为Null，而且调用trim()后，长度必须大于0</p>
</li>
<li><p>@NonNull：在方法或构造函数的参数上使用，生成一个空值检查语句</p>
<p><img src="http://cdn1.hikariblog.cn/%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C%E6%B3%A8%E8%A7%A3.PNG" alt="参数校验注解"></p>
<p><img src="http://cdn1.hikariblog.cn/%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C%E6%B3%A8%E8%A7%A31.PNG" alt="参数校验注解"></p>
</li>
</ol>
<p>每一个校验注解都有一个message，可以用于自定义错误消息</p>
<p>自定义校验注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义校验注解</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hogan_Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-11-21 10:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//这个注解可以被用在什么地方</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD,ElementType.METHOD&#125;)</span><br><span class="line"><span class="comment">//运行时注解</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="comment">//指定校验逻辑所在的类</span></span><br><span class="line"><span class="meta">@Constraint</span>(validatedBy = MyConstraintVaildator<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">MyConstraint</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> "</span>&#123;org.hibernate.validator.constraints.NotBlank.message&#125;<span class="string">";</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Class&lt;?&gt;[] groups() default &#123;&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/**</span></span><br><span class="line"><span class="string"> * @author Hogan_Lee</span></span><br><span class="line"><span class="string"> * @create 2019-11-21 10:27</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">//Spring容器能够自动找到这个类，因为实现了~  所以不用我们写@component</span></span><br><span class="line"><span class="string">//两个泛型，其中String说明注解只能放在String类型的域上面</span></span><br><span class="line"><span class="string">public class MyConstraintVaildator implements ConstraintValidator&lt;MyConstraint,String&gt; &#123;</span></span><br><span class="line"><span class="string">    @Override</span></span><br><span class="line"><span class="string">    public void initialize(MyConstraint myConstraint) &#123;</span></span><br><span class="line"><span class="string">        System.out.println("</span>init<span class="string">");</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    //返回值代表检验的结果</span></span><br><span class="line"><span class="string">    @Override</span></span><br><span class="line"><span class="string">    public boolean isValid(String s, ConstraintValidatorContext constraintValidatorContext) &#123;</span></span><br><span class="line"><span class="string">        System.out.println(s);</span></span><br><span class="line"><span class="string">        return false;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>数据校验失败状态码是400</p>
</li>
</ul>
</li>
</ul>
<h4 id="RESTful-API-错误处理"><a href="#RESTful-API-错误处理" class="headerlink" title="RESTful API 错误处理"></a>RESTful API 错误处理</h4><ul>
<li><p>Spring Boot 中默认的错误处理机制</p>
<p>额，默认的异常处理机制也很好用！！</p>
<p>Spring Boot自定义错误页面的存放位置！好像只有2.0以下的是这个样子，尝试了2.0以上的不可以</p>
<p><img src="http://cdn1.hikariblog.cn/%E9%94%99%E8%AF%AF%E9%A1%B5%E9%9D%A2.PNG" alt="错误页面"></p>
</li>
<li><p>自定义异常处理</p>
</li>
</ul>
<h4 id="RESTful-API的拦截"><a href="#RESTful-API的拦截" class="headerlink" title="RESTful API的拦截"></a>RESTful API的拦截</h4><p>需求：记录所有服务的处理时间</p>
<ol>
<li><p><strong>过滤器（Filter）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.web.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hogan_Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-12-03 14:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//加上@Compont之后就生效了，拦截所有的请求</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"time filter init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//doFilter执行整个处理方法的逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"time filter start"</span>);</span><br><span class="line">        <span class="keyword">long</span> start=<span class="keyword">new</span> Date().getTime();</span><br><span class="line">        <span class="comment">//服务处理</span></span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">        System.out.println(<span class="string">"time filter:"</span>+(<span class="keyword">new</span> Date().getTime()-start));</span><br><span class="line">        System.out.println(<span class="string">"time filter finish"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"time filter destroy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三方的Filter加到自己的项目中，在配置类或启动类中加上以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public FilterRegistrationBean timeFilter()&#123;</span><br><span class="line">    FilterRegistrationBean registrationBean&#x3D;new FilterRegistrationBean();</span><br><span class="line">    TimeFilter timeFilter&#x3D;new TimeFilter();</span><br><span class="line">    &#x2F;&#x2F;要使用的过滤器Bean</span><br><span class="line">    registrationBean.setFilter(timeFilter);</span><br><span class="line">    &#x2F;&#x2F;过滤器生效的路径</span><br><span class="line">    List&lt;String&gt; urls&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">    urls.add(&quot;&#x2F;*&quot;);</span><br><span class="line">    registrationBean.setUrlPatterns(urls);</span><br><span class="line">    return registrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span style="color:red">采用J2EE规范来编写的，只能取得request和response两个对象；实际上是由哪个控制器的哪个处理器方法来处理的并不知道。</span></p>
<p>额，如果有很多个过滤器要执行流程是怎么样子的？</p>
</li>
<li><p><strong>拦截器（Interceptor）</strong></p>
<p>注意：PreHandler方法返回的布尔值决定了后面的方法是不是要执行！！！可以拦截处理器方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.web.interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.method.HandlerMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hogan_Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-12-03 14:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//注意这里单单加上@Component还是不生效的，还需要额外的配置</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"preHandler"</span>);</span><br><span class="line">        httpServletRequest.setAttribute(<span class="string">"startTime"</span>, <span class="keyword">new</span> Date().getTime());</span><br><span class="line">        <span class="comment">//相比拦截器多了一个对象</span></span><br><span class="line">        <span class="comment">//打印类命</span></span><br><span class="line">        System.out.println(((HandlerMethod) o).getBean().getClass().getName());</span><br><span class="line">        <span class="comment">//打印处理器方法名字</span></span><br><span class="line">        System.out.println(((HandlerMethod) o).getMethod().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"postHandler"</span>);</span><br><span class="line">        Long start = (Long) httpServletRequest.getAttribute(<span class="string">"startTime"</span>);</span><br><span class="line">        System.out.println(<span class="string">"time interception 耗时"</span> + (<span class="keyword">new</span> Date().getTime() - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不管处理器方法是否抛出异常都会进入到afterCompletion方法中，抛出异常不会进入到postHandler方法</span></span><br><span class="line">    <span class="comment">//注意：控制器通知类比这个类先执行，异常会被控制器通知类偷走了</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AfterCompletion"</span>);</span><br><span class="line">        Long start = (Long) httpServletRequest.getAttribute(<span class="string">"startTime"</span>);</span><br><span class="line">        System.out.println(<span class="string">"time interception 耗时"</span> + (<span class="keyword">new</span> Date().getTime() - start));</span><br><span class="line">        System.out.println(<span class="string">"e is"</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拦截器注册</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.imooc.web.interceptor.TimeInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hogan_Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-12-03 14:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TimeInterceptor timeInterceptor;</span><br><span class="line">    <span class="comment">//拦截器注册器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(timeInterceptor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>切面（Aspect）</strong></p>
</li>
</ol>
<p>使用Spring MVC处理其它web应用常见的需求和场景.</p>
<ul>
<li>如何处理静态资源和异常</li>
<li>如何使用Spring MVC拦截器</li>
<li>如何处理文件的上传下载</li>
<li>如何进行请求的异步开发</li>
</ul>
<p>Restful API开发常用辅助框架</p>
<p>除了查询，如更新，创建等要返回什么</p>
<h2 id="文件的上传和下载"><a href="#文件的上传和下载" class="headerlink" title="文件的上传和下载"></a>文件的上传和下载</h2><h4 id="1、文件上传"><a href="#1、文件上传" class="headerlink" title="1、文件上传"></a>1、文件上传</h4><p>现在前端页面大部分都是单页应用，不会去刷新。不会有表单提交，上传文件的时候也是异步的，只会提交一个文件的路径上来。文件的上传往往都是单做的。</p>
<p>文件上传单元测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenUploadSuccess</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String result=mockMvc.perform(MockMvcRequestBuilders.fileUpload(<span class="string">"/file"</span>)</span><br><span class="line">                                  <span class="comment">//第一个参数和控制器参数名称一致，第二个为file的值，第四个为文件内容的字节流</span></span><br><span class="line">            .file(<span class="keyword">new</span> MockMultipartFile(<span class="string">"file"</span>, <span class="string">"test.txt"</span>, <span class="string">"multipart/form-data"</span>, <span class="string">"hello upload"</span>.getBytes(<span class="string">"UTF-8"</span>))))</span><br><span class="line">            .andExpect(MockMvcResultMatchers.status().isOk())</span><br><span class="line">            .andReturn().getResponse().getContentAsString();</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件上传控制器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/file"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//人家上传过来至少要返回获取文件的路径给他</span></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FileInfo <span class="title">upload</span><span class="params">(MultipartFile file)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">//文件保存的位置</span></span><br><span class="line">        String folder=<span class="string">"G:\\test\\imooc-security\\imooc-security-demo1\\src\\main\\java\\com\\imooc\\web\\controller"</span>;</span><br><span class="line">        File localFile=<span class="keyword">new</span> File(folder,<span class="keyword">new</span> Date().getTime()+<span class="string">".txt"</span>);</span><br><span class="line">        <span class="comment">//将传上来的文件写到自己新建的文件</span></span><br><span class="line">        file.transferTo(localFile);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FileInfo(localFile.getAbsolutePath());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、文件下载"><a href="#2、文件下载" class="headerlink" title="2、文件下载"></a>2、文件下载</h4><p>文件下载控制器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">download</span><span class="params">(@PathVariable String id, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">//try-with-resource</span></span><br><span class="line">    <span class="keyword">try</span>(</span><br><span class="line">            <span class="comment">//输入流</span></span><br><span class="line">            InputStream inputStream=<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(folder,id+<span class="string">".txt"</span>));</span><br><span class="line">            <span class="comment">//输出流</span></span><br><span class="line">            OutputStream outputStream=response.getOutputStream()</span><br><span class="line">    )&#123;</span><br><span class="line">        response.setContentType(<span class="string">"application/x-download"</span>);</span><br><span class="line">        response.addHeader(<span class="string">"Content-Disposition"</span>,<span class="string">"attachment;filename=test.txt"</span>);</span><br><span class="line">        <span class="comment">//commons-io包，这个方法的作用是把输入流拷贝到输出流中</span></span><br><span class="line">        IOUtils.copy(inputStream,outputStream);</span><br><span class="line">        outputStream.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>自动生成接口文档——与前端开发并行工作</p>
<p>&emsp;&emsp;使用swagger自动生成html文档</p>
<p>如果没有这个工具，需要同时维护自己的代码和文档，很繁琐。而swagger可以根据代码实时生成接口文档。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 扫描程序生成文档数据 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 生成最终的可视化界面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后在配置类中添加@EnableSwagger2注解，启动后访问localhost:8060/swagger-ui.html.</p>
<p>Swagger常用API描述注解：</p>
<p>@APIOperation  方法描述</p>
<p>@APIModelProperty  实体类属性描述</p>
<p>@APIParam  方法参数没有封装成对象的属性</p>
<p>&emsp;&emsp;使用WireMock快速伪造RESTful服务</p>
]]></content>
      <categories>
        <category>RESTful</category>
      </categories>
      <tags>
        <tag>RESTful</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>JSP常用标签</title>
    <url>/2019/07/26/JSP%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<p>&emsp;&emsp;JSTL(JavaServer Pages Standard Tag Library)/JSP标准标签库是JSP提供的一个自定义标签库。使用JSTL有利于我们实现JSP页面中的<span style="color:red">代码复用</span>例如用于————的 <code>&lt;c:foreach&gt;&lt;/c:foreach&gt;</code> 标签。</p>
<p>JSTL标签的可分为四大分类</p>
<ul>
<li>核心标签–最常用、最重要</li>
<li>格式化标签</li>
<li>SQL标签</li>
<li>XML标签</li>
</ul>
<p>除此之外，还有JSTL函数也是比较常用的</p>
<h4 id="JSTL的环境搭建"><a href="#JSTL的环境搭建" class="headerlink" title="JSTL的环境搭建"></a>JSTL的环境搭建</h4><p>&emsp;&emsp;JSTL标签和Server及JSP页面有着比较严格的版本对应关系，版本对应不正确很容易抛出异常。</p>
<p>JSTL的jar包下载地址:<a href="https://mvnrepository.com/artifact/javax.servlet/jstl" target="_blank" rel="noopener">https://mvnrepository.com/artifact/javax.servlet/jstl</a></p>
<p>拓展：引入jar包的三种方式：</p>
<ol>
<li>引入jar到WEB-INF/lib文件目录下，然后右键jar包，选择add as library；</li>
<li><code>build path</code>引入jar包在文件系统中的一个外部链接；</li>
<li>使用maven项目通过坐标进行引入进行引入。</li>
</ol>
<h4 id="JSTL的入门Demo"><a href="#JSTL的入门Demo" class="headerlink" title="JSTL的入门Demo"></a>JSTL的入门Demo</h4><p>为了使用JSTL，需要在JSP页面中对其进行声明:</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;!-- 如：引入JSTL的核心标签库 --&gt;</span><br><span class="line">&lt;%@ taglib prefix=<span class="string">"c"</span> uri=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> %&gt;</span><br></pre></td></tr></table></figure>

<p>接下来我们就可以使用JSTL进行开发了，首先让我们按照惯例来输出一个Hello World!</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;%@ taglib prefix=<span class="string">"c"</span> uri=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;$Title$&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;c:out value="Hello World!"&gt;&lt;/c:out&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h4 id="JSTL和EL表达式"><a href="#JSTL和EL表达式" class="headerlink" title="JSTL和EL表达式"></a>JSTL和EL表达式</h4><p>JSTL标签中对常量的值输出是较为简单的，但是对于变量的操作则要借助EL表达式(Expression Language)。</p>
<h5 id="EL表达式的格式"><a href="#EL表达式的格式" class="headerlink" title="EL表达式的格式"></a>EL表达式的格式</h5><ul>
<li><p>用美元符号“$”定界，内容包括在花括号“{}”中</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;${表达式}</p>
</li>
<li><p>“.”与”[]”运算符</p>
<ul>
<li><p>通常情况是通用的<code>${user.sex}</code>等同于<code>${user[&quot;sex&quot;]}</code></p>
</li>
<li><p>“[]”还可以用来进行集合元素中的定位<code>${booklist[0].price}</code></p>
</li>
<li><p>以下两种情况下”.”与”[]”之间存在区别</p>
<ul>
<li><p>包含特殊字符</p>
<p>只能使用”[]”，如<code>${user[&quot;first-name&quot;]}</code></p>
</li>
<li><p>通过变量动态取值</p>
<p>同样只能使用”[]”，如<code>${user[param]}</code>,其中param可以是name or sex or others</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="EL变量"><a href="#EL变量" class="headerlink" title="EL变量"></a>EL变量</h5><table>
<thead>
<tr>
<th>JSP内置对象</th>
<th>EL名称</th>
</tr>
</thead>
<tbody><tr>
<td>Page</td>
<td>PageScope</td>
</tr>
<tr>
<td>Request</td>
<td>RequestScope</td>
</tr>
<tr>
<td>Session</td>
<td>SessionScope</td>
</tr>
<tr>
<td>Application</td>
<td>ApplicationScope</td>
</tr>
</tbody></table>
<p>如果没有指定，则按照PageScope–&gt;RequestScope–&gt;SessionScope–&gt;ApplicationScope的顺序进行逐一查找。</p>
<p><span style="color:red">&gt;如果找不到值为null，但是EL对其进行优化会输出空字符串。</span></p>
<h5 id="EL的自动类型转换"><a href="#EL的自动类型转换" class="headerlink" title="EL的自动类型转换"></a>EL的自动类型转换</h5><p>JSP的getparameter()方法每次获得都是字符串，需要我们手动进行数据类型的转换，当时现在EL表达式可以进行自动数据类型的转换，常见与SpringMVC的数据绑定。</p>
<h5 id="EL隐式对象"><a href="#EL隐式对象" class="headerlink" title="EL隐式对象"></a>EL隐式对象</h5><table>
<thead>
<tr>
<th>隐式对象</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>PageContext</td>
<td>PageContext实例对应于当前页面的处理</td>
</tr>
<tr>
<td>PageScope</td>
<td>与页面作用域的名称和值相关联的Map类</td>
</tr>
<tr>
<td>requestScope</td>
<td>与请求作用域属性的名称和值相关联的Map类</td>
</tr>
<tr>
<td>sessionScope</td>
<td>与会话作用域属性的名称和值相关联的Map类</td>
</tr>
<tr>
<td>applicationScope</td>
<td>与应用程序作用域属性的名称和值相关联的Map类</td>
</tr>
<tr>
<td>param</td>
<td>按名称存储的请求参数的主要值的Map类</td>
</tr>
<tr>
<td>paramValues</td>
<td>按请求参数的所有值作为String数组存储的Map类</td>
</tr>
<tr>
<td>Header</td>
<td>按名称存储请求头主要值的Map类</td>
</tr>
<tr>
<td>headerValue</td>
<td>按请求头的所有值作为String数组存储的Map类</td>
</tr>
<tr>
<td>cookie</td>
<td>按名称存储请求附带的cookie的Map类</td>
</tr>
<tr>
<td>intParam</td>
<td>按名称存储Web应用程序上下文初始化参数的Map类</td>
</tr>
</tbody></table>
<h5 id="EL运算符"><a href="#EL运算符" class="headerlink" title="EL运算符"></a>EL运算符</h5><ul>
<li><p>运算符允许对数据和文字进行组合以及比较</p>
</li>
<li><p>EL运算符：</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>运算符</th>
</tr>
</thead>
<tbody><tr>
<td>算术运算符</td>
<td>+、-、*、/(或div)和%(或mod)</td>
</tr>
<tr>
<td>关系运算符</td>
<td>==(或eq)、!=(或ne)、&lt;(或It)、&gt;(或gt)、&lt;=(或le)和&gt;=(或ge)</td>
</tr>
<tr>
<td>逻辑运算符</td>
<td>&amp;&amp;(或and)、||(或or)和!(或not)</td>
</tr>
<tr>
<td>验证运算符</td>
<td>empty</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="JSTL核心标签库"><a href="#JSTL核心标签库" class="headerlink" title="JSTL核心标签库"></a>JSTL核心标签库</h4><p>JSTL的核心标签库标签共13个，从功能上可以分为4类：</p>
<ul>
<li>表达式控制标签：out set remove catch</li>
<li>流程控制标签：if choose when otherwise</li>
<li>循环标签：forEach forTokens</li>
<li>URL操作标签：import url redirect</li>
</ul>
<h5 id="out标签"><a href="#out标签" class="headerlink" title="out标签"></a>out标签</h5><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;%@ taglib prefix=<span class="string">"c"</span> uri=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;$Title$&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;!-- 使用out标签输出常量 --&gt;</span><br><span class="line">&lt;c:out value="Hello World"&gt;&lt;/c:out&gt;&lt;br/&gt;</span><br><span class="line">&lt;!-- 使用out标签输出变量 --&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    session.setAttribute(<span class="string">"name"</span>, <span class="string">"小明"</span>);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;c:out value="$&#123;sessionScope.name&#125;"&gt;&lt;/c:out&gt;</span><br><span class="line">&lt;!-- 当变量不存在时输出默认值 --&gt;</span><br><span class="line">&lt;c:out value="$&#123;sex&#125;" default="男"&gt;&lt;/c:out&gt;</span><br><span class="line">&lt;!-- 当escapeXML为flase时，转义字符会进行转义，默认为<span class="keyword">true</span> --&gt;</span><br><span class="line">&lt;c:out value="2&amp;nbsp;2/n22" escapeXml="flase"&gt;&lt;/c:out&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h5 id="set标签"><a href="#set标签" class="headerlink" title="set标签"></a>set标签</h5><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;jsp:useBean id="ds" class="user.User"&gt;&lt;/jsp:useBean&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;%@ taglib prefix=<span class="string">"c"</span> uri=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;$Title$&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;!-- 存值到scope当中 --&gt;</span><br><span class="line">&lt;!-- <span class="number">1</span>.值放到value中 --&gt;</span><br><span class="line">&lt;c:set value="today" var="day" scope="session"&gt;&lt;/c:set&gt;</span><br><span class="line">&lt;c:out value="$&#123;day&#125;"&gt;&lt;/c:out&gt;</span><br><span class="line">&lt;!-- 值放到容器标签当中 --&gt;</span><br><span class="line">&lt;c:set var="age" scope="session"&gt;12&lt;/c:set&gt;</span><br><span class="line">&lt;c:out value="$&#123;age&#125;"&gt;&lt;/c:out&gt;</span><br><span class="line">&lt;!-- 存值到JavaBean当中 --&gt;</span><br><span class="line">&lt;c:set target="$&#123;ds&#125;" value="as" property="name"&gt;&lt;/c:set&gt;</span><br><span class="line">&lt;c:out value="$&#123;ds.name&#125;"&gt;&lt;/c:out&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JSP</category>
      </categories>
      <tags>
        <tag>Java Web</tag>
        <tag>JSP</tag>
        <tag>EL</tag>
        <tag>JTSL</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis入门笔记</title>
    <url>/2019/07/25/mybatis%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h4 id="通过自动回复机器人学mybatis基础篇"><a href="#通过自动回复机器人学mybatis基础篇" class="headerlink" title="通过自动回复机器人学mybatis基础篇"></a>通过自动回复机器人学mybatis基础篇</h4><p><strong>案例分析</strong></p>
<p>基本功能：</p>
<ul>
<li>接收发送指令</li>
<li>根据指令回复对应的内容</li>
</ul>
<p>模块划分</p>
<ol>
<li>回复内容维护</li>
<li>对话功能</li>
<li>回复内容列表</li>
<li>回复内容删除</li>
</ol>
<p><strong>version：1.0-SNAPSHOT</strong></p>
<p>相关技术：Jsp+Jdbc+SpringMVC</p>
<p>&emsp;&emsp;页面放在WEB-INF下面，便于控制和管理，如果放在根目录下是可以被用户在浏览器直接访问到的，不安全。放在WEB-INF下必须通过后台进行访问。</p>
<p>&emsp;&emsp;不要写select *,就算可以也不要，机器还得去转换一遍。不要嫌麻烦，自己把需要的列名列出来，否则显得不专业，被老板骂。</p>
<p>&emsp;&emsp;通过PreparedStatement可以防止sql注入。</p>
<p>&emsp;&emsp;where 1==1;然后在sql语句上再加条件</p>
<p>&emsp;&emsp;实际开发中尽量使用复制，别因为打错了，调试半天。</p>
<h6 id="mybatis的概述"><a href="#mybatis的概述" class="headerlink" title="mybatis的概述"></a>mybatis的概述</h6><ul>
<li>ORM(Object Relational Mapping)持久层框架的佼佼者</li>
<li>正真实现了SQL语句与Java代码的分离</li>
<li>优秀的功能：动态SQL、缓存、插件-pageHelper(主要进行物理分页的优秀开源项目)等</li>
</ul>
<p>实际场景中mybatis的应用</p>
<ul>
<li>SQL语句中使用IN的情况，可以使用数组封装IN中的值</li>
<li>批量操作数据的情况，可以把操作的数据封装在数组中</li>
</ul>
<h6 id="mybatis的环境搭建"><a href="#mybatis的环境搭建" class="headerlink" title="mybatis的环境搭建"></a>mybatis的环境搭建</h6><ol>
<li>mybatis的包和源码,链接:<a href="https://github.com/mybatis/mybatis-3/releases" target="_blank" rel="noopener">https://github.com/mybatis/mybatis-3/releases</a></li>
<li>源码中演示版核心配置文件的详细路径：src\test\java\org\apache\ibatis\submitted\complex_property\Configuration.xml；将它复制到项目的资源文件目录中，按照需求修改里面的配置。</li>
<li>MyBatis官方文档:<a href="http://www.mybatis.org/mybatis-3/zh/getting-started.html" target="_blank" rel="noopener">http://www.mybatis.org/mybatis-3/zh/getting-started.html</a></li>
</ol>
<p><strong>在使用Mybatis框架时，主要设计两个核心对象：<code>SqlSessionFactory</code>和<code>SqlSession</code></strong></p>
<ol>
<li><p><em>SqlSessionFactory</em></p>
<p>&emsp;&emsp;<code>SqlSessionFactory</code> 是单个数据库映射关系经过编译后的内存镜像，其主要的作用是创建 <code>SqlSession</code>。下面将通过XML配置文件进行 <code>SqlSessionFactory</code> 实例的构建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取配置文件</span></span><br><span class="line">InputStream inputStream=Resources.getResourceAsStream(<span class="string">"配置文件位置"</span>);</span><br><span class="line"><span class="comment">//根据配置文件构建SqlSessionFactory</span></span><br><span class="line">SqlSessionFactory sqlSessionFactory=<span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<code>SqlSessionFactory</code> 对象是线程安全的，它一旦被创建，在整个应用执行期间都会存在。如果我们多次地创建同一个数据库的 <code>SessionFactory</code>，那么此数据库的资源将很容易被耗尽。为了解决此问题，通常每一个数据库都会只对应一个<code>SqlSessionFactory</code>，所以在构建 <code>SqlSessionFactory</code> 实例时，建议使用单例模式。</p>
</li>
<li><p><em>SqlSession</em></p>
<p>&emsp;&emsp;<code>SqlSession</code> 是应用程序与持久层之间执行交互操作的一个<span style="color:red">单线程对象</span>，其主要作用就是执行持久化操作以及实现数据库事务的控制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过sqlSessionFactory打开一个数据库会话</span></span><br><span class="line">SqlSession sqlSession=sqlSessionFactory.openSession();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//此处执行持久化操作</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;每一个线程都应该有自己的 <code>SqlSession</code> 实例，并且该实例是不能被共享的。同时，<code>SqlSession</code> 实例也是线程不安全的，因此其使用范围最好在一次请求或一个方法中，绝不能将其放在一个类的静态字段、实例字段或任何类型的管理范围（如 <code>Servlet</code> 的 <code>HttpSession</code>）中使用。使用完 <code>SqlSession</code> 对象之后，要及时地关闭它，通常可以在 <code>finally</code> 块中关闭。</p>
<p>&emsp;&emsp;每个方法执行时都需要读取配置文件，并根据配置文件的信息构建 <code>SqlSessionFactory</code> 对象，然后创建 <code>SqlSession</code> 对象，这导致了大量的重复代码。为了简化开发，我们可以把重复代码封装到一个工具类中，然后通过工具类来创建SqlSession。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Reader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hogan_Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-09-06 10:22</span></span><br><span class="line"><span class="comment"> * 工具类：创建SqlSession</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化SqlSessionFactory对象</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//使用Mybatis提供的Resources类加载Mybatis的配置文件</span></span><br><span class="line">            Reader reader = Resources.getResourceAsReader(<span class="string">"mybatis-config.xml"</span>);</span><br><span class="line">            <span class="comment">//构建SqlSessionFactory工厂</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取SqlSession对象的静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h6 id="Sql的基本配置与执行"><a href="#Sql的基本配置与执行" class="headerlink" title="Sql的基本配置与执行"></a>Sql的基本配置与执行</h6><ol>
<li>源码中演示版Sql配置文件的详细路径：src\test\java\org\apache\ibatis\submitted\complex_property\User.xml；将它复制到项目的资源文件目录中，按照需求修改里面的配置。</li>
<li>Sql配置文件作用，配置Sql语句让SqlSession能读到并执行。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"Message"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"entity.Message"</span> <span class="attr">id</span>=<span class="string">"Message"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 主键 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"ID"</span> <span class="attr">jdbcType</span>=<span class="string">"INTEGER"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 普通的列 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- jdbcType为java.sql.Types类中的常量名有一种对应关系 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"COMMAND"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> <span class="attr">property</span>=<span class="string">"command"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"DESCRIPTION"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> <span class="attr">property</span>=<span class="string">"description"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"CONTENT"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> <span class="attr">property</span>=<span class="string">"content"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"allMessage"</span> <span class="attr">resultMap</span>=<span class="string">"Message"</span>&gt;</span></span><br><span class="line">        select ID, COMMAND, DESCRIPTION, CONTENT</span><br><span class="line">        from message</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后通过核心配置文件中的<code>&lt;Mapper&gt;</code>元素引入Sql配置文件。</p>
<h6 id="动态Sql拼接"><a href="#动态Sql拼接" class="headerlink" title="动态Sql拼接"></a>动态Sql拼接</h6><p>动态SQL元素和JSTL或基于类似XML的文本处理器相似。在MyBatis之前的版本中，有很多元素需要花时间了解。MyBatis3大大精简了元素种类，现在只需学习原来一半的元素即可。Mybatis采用功能强大的基于OGNL的表达式来淘汰其它大部分元素。</p>
<p>注意：特殊字符要进行转义</p>
<table>
    <tr>
        <th colspan="4" style="text-align:center">MyBatis中的OGNL表达式</th>
    </tr>
    <tr>
        <td style="text-align:center">取值范围</td>
        <td colspan="3" style="text-align:center">标签的属性中</td>
    </tr>
    <tr>
        <td rowspan="5" style="text-align:center">取值写法</td>
        <td style="text-align:center">String与基本数据类型</td>
        <td style="text-align:center" colspan="2">_parameter</td>
    </tr>
    <tr>
        <td style="text-align:center">自定义类型(Message)</td>
        <td style="text-align:center" colspan="2">属性名(command)</td>
    </tr>
    <tr>
        <td rowspan="3" style="text-align:center">集合</td>
        <td style="text-align:center" colspan="2">数组：array</td>
    </tr>
    <tr>
        <td style="text-align:center" colspan="2">List:list</td>
    </tr>
    <tr>
        <td style="text-align:center" colspan="2">Map:_parameter</td>
    </tr>
    <tr>
        <td rowspan="2" style="text-align:center">操作符</td>
        <td style="text-align:center">java常用操作符</td>
        <td colspan="2" style="text-align:center">+、-、*、/、==、!=、||、&amp;&amp;等</td>
    </tr>
    <tr>
        <td style="text-align:center">自己特有的操作符</td>
        <td colspan="2" style="text-align:center">and、or、mod、in、not in</td>
    </tr>
    <tr>
        <td rowspan="6" style="text-align:center">从集合中取出一条元素</td>
        <td rowspan="2" style="text-align:center">数组</td>
        <td colspan="2" style="text-align:center">array[索引](String[])</td>
    </tr>
    <tr>
        <td colspan="2" style="text-align:center">array[索引].属性名(Message[])</td>
    </tr>
    <tr>
        <td rowspan="2" style="text-align:center">List</td>
        <td colspan="2" style="text-align:center">list[索引](List&lt;String&gt;)</td>
    </tr>
    <tr>
        <td colspan="2" style="text-align:center">list[索引]属性名(List&lt;Message&gt;)</td>
    </tr>
    <tr>
        <td rowspan="2" style="text-align:center">Map</td>
        <td colspan="2" style="text-align:center">_parameter.key(Map&lt;String,String&gt;)</td>
    </tr>
    <tr>
        <td colspan="2" style="text-align:center">key.属性名(Map&lt;String,Message&gt;)</td>
    </tr>
    <tr>
        <td rowspan="4" style="text-align:center">利用foreach标签从集合中取出数据</td>
        <td colspan="3" style="text-align:center">&lt;foreach collection="array" index="i" item="item"&gt;</td>
    </tr>
    <tr>
        <td style="text-align:center">数组</td>
       <td rowspan="2" style="text-align:center">i：索引(下标)</td>
        <td rowspan="3" style="text-align:center">item<br/><br/>item.属性名</td>
    </tr>
    <tr>
        <td style="text-align:center">List</td>
    </tr>
    <tr>
        <td style="text-align:center">Map</td>
        <td style="text-align:center">i：key</td>
    </tr>
</table>

<p>配置示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"allMessage"</span> <span class="attr">resultMap</span>=<span class="string">"Message"</span>&gt;</span></span><br><span class="line">        select ID, COMMAND, DESCRIPTION, CONTENT</span><br><span class="line">        from message</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectWithCondition"</span> <span class="attr">parameterType</span>=<span class="string">"entity.Message"</span> <span class="attr">resultMap</span>=<span class="string">"Message"</span>&gt;</span></span><br><span class="line">        select ID,COMMAND,DESCRIPTION,CONTENT from message where 1=1</span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"command!=null and !<span class="symbol">&amp;quot;</span><span class="symbol">&amp;quot;</span>.equals(command.trim())"</span>&gt;</span>and COMMAND=#&#123;command&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"description!=null and !<span class="symbol">&amp;quot;</span><span class="symbol">&amp;quot;</span>.equals(description.trim())"</span>&gt;</span>and DESCRIPTION like '%'</span><br><span class="line">            #&#123;description&#125; '%'</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="应用log4j调试动态Sql"><a href="#应用log4j调试动态Sql" class="headerlink" title="应用log4j调试动态Sql"></a>应用log4j调试动态Sql</h6><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">log4j.properties</span></span><br><span class="line"><span class="meta">log4j.rootLogger</span>=<span class="string">DEBUG , stdout</span></span><br><span class="line"><span class="meta">log4j.logger.org.mybatis</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.appender.stdout</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout.ConversionPattern</span>=<span class="string">%5p %d %C: %m%n</span></span><br></pre></td></tr></table></figure>

<p><code>properties</code>文件主要采用”key=value”的书写方式，用到的时候通过key找到对应的value。</p>
<p>log4j.rootLogger:使用log4j输出日志时的级别和输出的位置。</p>
<p>级别：debug&lt;info&lt;warn&lt;error,只有级别大于等于配置的才会被输出</p>
<h6 id="删除实现"><a href="#删除实现" class="headerlink" title="删除实现"></a>删除实现</h6><p>增删改和查询不一样，是有事务控制的，需要手动提交；</p>
<p>sqlSession.commit();</p>
<p>mybatis在封装jdbc的增删改操作时将jdbc默认的自动提交事务设置为false</p>
<p><code>conn.setAutoCommit(false)；</code>所以我们要么将它重新设置为true（不建议），要么每一次手动提交。</p>
<p>任务：删除要有提示信息</p>
<p>删除之后检索条件没有保留</p>
<h5 id="以数组为传递参数进行数据的查询"><a href="#以数组为传递参数进行数据的查询" class="headerlink" title="以数组为传递参数进行数据的查询"></a><em>以数组为传递参数进行数据的查询</em></h5><p>实际应用：</p>
<ol>
<li>SQL语句中使用IN的情况，可以使用数组封装IN中的值</li>
<li>批量操作数据的情况，可以把操作的数据封装在数组中</li>
</ol>
<p>重要知识点</p>
<ol>
<li>Mybatis的入参的处理</li>
<li>Mybatis的动态SQL(foreach标签)</li>
</ol>
<p><strong>Mybatis入参处理</strong></p>
<p>参数处理</p>
<ul>
<li><p>传递单个参数的形式（mybatis会自动进行参数的赋值）</p>
<p>不会关注参数的名字</p>
</li>
<li><p>传递多个参数（mybatis会自动封装在Map集合中）</p>
</li>
<li><p>Collection、List、Array作为参数，封装为Map，但是有一定的规则</p>
</li>
</ul>
<p>首先，如果你的数据库支持自动生成主键的字段（比如 MySQL 和 SQL Server），那么你可以设置 useGeneratedKeys=”true”，然后再把 keyProperty 设置到目标属性上就 OK 了。例如，如果上面的 Author 表已经对 id 使用了自动生成的列类型，那么语句可以修改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;insert id&#x3D;&quot;insertAuthor&quot; useGeneratedKeys&#x3D;&quot;true&quot;</span><br><span class="line">    keyProperty&#x3D;&quot;id&quot;&gt;</span><br><span class="line">  insert into Author (username,password,email,bio)</span><br><span class="line">  values (#&#123;username&#125;,#&#123;password&#125;,#&#123;email&#125;,#&#123;bio&#125;)</span><br><span class="line">&lt;&#x2F;insert&gt;</span><br></pre></td></tr></table></figure>

<p>如果不添加这个会不会出现问题？以前使用JDBC也是直接没有添加这一行的</p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>框架</tag>
        <tag>mybatis</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>深入解析HashMap</title>
    <url>/2019/07/22/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90HashMap/</url>
    <content><![CDATA[<p>文章基于Java1.8版本，Java1.8相对于Java1.7版本对 <code>HashMap</code> 进行了一些优化。</p>
<p>&emsp;&emsp;<code>HashMap</code> 最擅长的事情就是<span style="color:#2E8B57">快速索引</span>。</p>
<h3 id="数据结构HashMap"><a href="#数据结构HashMap" class="headerlink" title="数据结构HashMap"></a>数据结构HashMap</h3><p>&emsp;&emsp;<code>HashMap</code>是一个存放数据的容器，<code>HashMap</code> 为了达到它快速索引的目的，利用了数组快速定位的特性。建立插入值和数组所在坐标之间的关系，pos=key%size（key为插入的值，size为数组的长度），假设存在以下长度为10的Integer数组，当key的值为21，求模之后为1，就将它存放在下标为1的位置，以此类推。当求模之后的值一样，则出现哈希冲突。</p>
<p><img src="http://cdn1.hikariblog.cn/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90HashMap_%E5%9B%BE%E7%89%871.png" alt=""></p>
<p>通过扩展单链表来解决冲突</p>
<p><img src="http://cdn1.hikariblog.cn/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90HashMap_%E5%9B%BE%E7%89%872.png" alt=""></p>
<p>当为解决哈希冲突延伸出来的单链表越来越长时，定位的时候首先还是定位到对应的下标，然后遍历单链表进行对比数值，时间复杂度为O(n)。不能满足快速定位的目的。所以JDK1.8又引入了红黑树(一种特殊的二叉树查询效率依赖的树的深度)的数据结构，当单链表过长的时候，将单链表转换为红黑树以提高查询的性能。</p>
<ul>
<li>HashMap的数据结构包括了初始数组、链表、红黑树；</li>
<li>插入数据的时候使用key%size来进行插入数据；</li>
<li>当两个或者两个以上的pos=key的pos相同时而key值不同的时候（发生冲突），就会挂在数组初始化位置的链表后</li>
<li>当节点后出现过多的链表节点的时候，就会转换成红黑树以提高效率。</li>
</ul>
<h3 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h3><p>初始容量为2的倍数</p>
<p>避免空间碎片，提高散列度，避免冲突</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring MVC从入门到忘记</title>
    <url>/2019/07/19/Spring-MVC%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BF%98%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="什么是MVC设计模式？"><a href="#什么是MVC设计模式？" class="headerlink" title="什么是MVC设计模式？"></a>什么是MVC设计模式？</h3><p>&emsp;&emsp;<code>MVC</code> 设计模式指的是我们可以把一个web应用程序分成三层。</p>
<ul>
<li>Controller：负责接受并处理请求，响应客户端。</li>
<li>Model：模型数据，业务逻辑。</li>
<li>View：呈现模型，与用户进行交互。</li>
</ul>
<p><img src="http://cdn1.hikariblog.cn/MVC%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B8%E5%9E%8B%E5%90%88%E4%BD%9C.png" alt="MVC组件之间的典型合作"></p>
<h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><h4 id="SpringMVC的概念"><a href="#SpringMVC的概念" class="headerlink" title="SpringMVC的概念"></a>SpringMVC的概念</h4><p>&emsp;&emsp;<code>SpringMVC</code> 是目前最好的实现 <code>MVC</code> 设计模式的框架，是 <code>Spring</code> 框架的一个后续产品/子模块，二者可以很好的结合使用，不需要整合。</p>
<p><strong>SpringMVC核心组件</strong></p>
<ol>
<li>DispatcherServlet：前置控制器。</li>
<li>Handler：处理器，完成具体的业务逻辑。</li>
<li>HandlerMapping：将请求映射到Handler。</li>
<li>HandlerInterceptor：处理器拦截器。</li>
<li>HandlerExecutionChain：处理器执行链。</li>
<li>HandlerAdapter：处理器适配器。</li>
<li>ModelAndView：装载模型数据和视图信息。</li>
<li>ViewResolver：视图解析器。</li>
</ol>
<p><strong>SpringMVC实现流程</strong></p>
<ol>
<li>客户端请求被DispatcherServlet接收。</li>
<li>DispatcherServlet将请求映射到Handler。</li>
<li>生成Handler以及HandlerInterceptor。</li>
<li>返回HandlerExecutionChain(Handler+HandlerInterceptor)给DispatcherServlet。</li>
<li>DispatcherServlet通过HandlerAdapter执行Handler。</li>
<li>返回一个ModelAndView。</li>
<li>DispatcherServlet通过ViewResolver进行解析。</li>
<li>返回填充了模型数据的View，响应给客户端。</li>
</ol>
<p><img src="http://cdn1.hikariblog.cn/SpringMVC%E6%B5%81%E7%A8%8B.png" alt="SpringMVC流程"></p>
<h4 id="SpringMVC的使用"><a href="#SpringMVC的使用" class="headerlink" title="SpringMVC的使用"></a>SpringMVC的使用</h4><h5 id="传统意义上的配置："><a href="#传统意义上的配置：" class="headerlink" title="传统意义上的配置："></a>传统意义上的配置：</h5><ol>
<li><p>大部分组件由框架提供，开发者只需通过配置进行关联。</p>
</li>
<li><p>开发者只需手动编写Handler，View。</p>
<h6 id="基于XML配置的使用"><a href="#基于XML配置的使用" class="headerlink" title="基于XML配置的使用"></a>基于XML配置的使用</h6></li>
<li><p>SpringMVC基础配置</p>
<ul>
<li><p>导入相关的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- SpringMVC相关的jar包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 导入Servlet相关jar包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>web.xml中配置前置控制器DispatcherServlet</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--web.xml--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">web-app</span> <span class="meta-keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta"> <span class="meta-string">"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"</span></span></span><br><span class="line"><span class="meta"> <span class="meta-string">"http://java.sun.com/dtd/web-app_2_3.dtd"</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定项目配置文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>XML配置Controller，HandlerMapping组件映射。</p>
<p>编写一个控制器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.Controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hogan_Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-07-19 12:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//装载模式数据和逻辑视图</span></span><br><span class="line">        ModelAndView modelAndView=<span class="keyword">new</span> ModelAndView();</span><br><span class="line">        <span class="comment">//添加模型数据</span></span><br><span class="line">        modelAndView.addObject(<span class="string">"name"</span>,<span class="string">"Tom"</span>);</span><br><span class="line">        <span class="comment">//添加逻辑视图</span></span><br><span class="line">        modelAndView.setViewName(<span class="string">"show"</span>);</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第二种控制器编写方式：Model传值，String进行视图解析</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">ModelTest</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">        <span class="comment">//填充模型数据</span></span><br><span class="line">        model.addAttribute(<span class="string">"name"</span>,<span class="string">"Jerry"</span>);</span><br><span class="line">        <span class="comment">//设置逻辑视图</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"show"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第三种控制器编写方式：Map传值，String进行视图解析</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">MapTest</span><span class="params">(Map&lt;String,String&gt; map)</span></span>&#123;</span><br><span class="line">        <span class="comment">//填充模型数据</span></span><br><span class="line">        map.put(<span class="string">"name"</span>,<span class="string">"Cat"</span>);</span><br><span class="line">        <span class="comment">//设置逻辑视图</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"show"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>spring配置文件中配置处理器映射</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置HandlerMapping，将url请求映射到Handler --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"handlerMapping"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置Mapping --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mappings"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"/test"</span>&gt;</span>testHandler<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置Handler --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"testHandler"</span> <span class="attr">class</span>=<span class="string">"io.github.forhcl.MyHandler"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>spring配置文件中XML配置ViewResolver组件映射。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置视图解析器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置前缀 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置后缀 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="基于注解方式的使用"><a href="#基于注解方式的使用" class="headerlink" title="基于注解方式的使用"></a>基于注解方式的使用</h6><p><strong>Handler通过自动扫描进行创建Bean</strong></p>
<p><strong>HandlerMapping通过<code>@RequestMapping(&quot;&quot;)</code>对方法进行注解</strong></p>
</li>
</ol>
<h5 id="新版本的配置（推荐使用，这种方式完全可以将web-xml替代）"><a href="#新版本的配置（推荐使用，这种方式完全可以将web-xml替代）" class="headerlink" title="新版本的配置（推荐使用，这种方式完全可以将web.xml替代）"></a>新版本的配置（推荐使用，这种方式完全可以将web.xml替代）</h5><ol>
<li><p>配置DispatcherServlet。</p>
<p>&emsp;&emsp;通过继承抽象类 <code>AbstractAnnotationConfigDispatcherServletInitializer</code> 重写三个抽象方法来配置 <code>DispatcherServlet</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hogan_Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-07-19 16:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpittrWebAppInitializer</span> <span class="keyword">extends</span> <span class="title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//指定~~的配置类(用来配置ContextLoaderListener创建的应用上下文中的Bean)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Class&lt;?&gt;[]&#123;RootConfig<span class="class">.<span class="keyword">class</span>&#125;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//指定应用的配置类(用来定于DispatcherServlet应用上下文中的Bean)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Class&lt;?&gt;[]&#123;WebConfig<span class="class">.<span class="keyword">class</span>&#125;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将DispatcherServlet映射到“/”</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">"/"</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启用Spring MVC</p>
<p>使用 <code>@EnableWebMvc</code> 注解在注释应用的配置类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.EnableWebMvc;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hogan_Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-07-19 16:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"spitter.web"</span>)</span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line">        <span class="comment">//配置JSP视图解析器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ViewResolver <span class="title">viewResolver</span><span class="params">()</span></span>&#123;</span><br><span class="line">        InternalResourceViewResolver resolver=<span class="keyword">new</span> InternalResourceViewResolver();</span><br><span class="line">        resolver.setPrefix(<span class="string">"/WEB-INF/views/"</span>);</span><br><span class="line">        resolver.setSuffix(<span class="string">".jsp"</span>);</span><br><span class="line">        resolver.setExposeContextBeansAsAttributes(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> resolver;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//配置静态资源的处理</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> </span>&#123;</span><br><span class="line">        configurer.enable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>总结:</strong></p>
<p>&emsp;&emsp;SpringMVC是一个实现MVC模式的框架，对MVC模式进行了封装，让开发人员能够更加方便、快捷地进行基于MVC设计模式的软件开发，同时SpringMVC是Spring框架的一个后续产品，可以和Spring框架很好的结合起来使用，不需要做任何的整合处理。</p>
<h4 id="SpringMVC数据绑定"><a href="#SpringMVC数据绑定" class="headerlink" title="SpringMVC数据绑定"></a>SpringMVC数据绑定</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//编码过滤器，在web.xml中配置解决中文乱码问题</span><br><span class="line">  <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 捕获所有请求 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="SpringMVC数据绑定的原理"><a href="#SpringMVC数据绑定的原理" class="headerlink" title="SpringMVC数据绑定的原理"></a>SpringMVC数据绑定的原理</h5><ul>
<li><p>什么是数据绑定？</p>
<p><span style="color:blue">将HTTP请求中的参数绑定到Handler业务方法的形参列表当中。</span></p>
<!-- JSP是通过创建Servlet(继承于HTTPServlet的类，也是JSPMVC里面的控制器)，重写里面的doGet/doPost方法，由方法的HttpServletRequest类型的参数获得HTTP请求中的参数，从而实现数据的绑定。这种做法有一个缺点，就是传输的数据到最后都是String类型的，需要进行类型的转换 -->

<p>Spring<span style="color:red">自动</span>将信息进行封装,我们可以直接使用封装好的形参完成后续业务方法的逻辑操作。</p>
<p><img src="http://cdn1.hikariblog.cn/SpringMVC%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A.png" alt="SpringMVC数据绑定"></p>
</li>
</ul>
<h5 id="SpringMVC数据绑定的使用"><a href="#SpringMVC数据绑定的使用" class="headerlink" title="SpringMVC数据绑定的使用"></a>SpringMVC数据绑定的使用</h5><ul>
<li><p>常用的数据绑定类型</p>
<ol>
<li><p>基本数据类型</p>
<p>注解：</p>
<p><code>@ResponseBody</code>：可以不经过视图解析器，直接将业务方法的返回值打印到网页中</p>
<p><code>@RequestParam(value=&quot;i&quot;,required=false)</code>：指定HTTP请求要传入的参数名称，用于处理HTTP请求中的参数名称和Handler业务方法的形参名称不一致的情况，进行数据的间接绑定。</p>
<p>GET请求方式：<code>http://localhost:8080/spring_webapp_war_exploded/home?i=8</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/primaryType"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">primaryType</span><span class="params">(@RequestParam(value = <span class="string">"id"</span>)</span> <span class="keyword">int</span> id)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"id:"</span>+id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>包装类</p>
<p>包装类和基本数据类型之间可以自动拆装箱，所以操作和基本数据类型一致。需要注意的如果不传入值，则包装类变量默认为null，而基本数据类型会报错。<span style="color:red">(注意：这里说的没有传入值说的是在请求参数列表中找到对应的参数名但是没有找到值；而<code>defaultValue</code>属性指的是在请求参数列表中连参数名都没有找到)</span><span style="color:blue">可以使用<code>@RequestParam</code>注解的<code>defaultValue</code>属性为形参设置默认值，当参数没有传进来的时候使用默认值。</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/wrapperType"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">wrapperType</span><span class="params">(@RequestParam(value = <span class="string">"id"</span>)</span> Integer id)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"id:"</span>+id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/arrayType"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">arrayType</span><span class="params">(@RequestParam(value = <span class="string">"name"</span>)</span> String[] name)</span>&#123;</span><br><span class="line">    StringBuffer sbf=<span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">for</span>(String item:name)&#123;</span><br><span class="line">        sbf.append(item).append(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sbf.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GET请求方式：<code>&lt;http://localhost:8080/spring_webapp_war_exploded/home?i=2&amp;i=3&gt;</code></p>
<p>注意：数组绑定请求参数列表中多个请求参数名称一致</p>
</li>
<li><p>对象</p>
<p>实体类,可以级联，即对象当中包含对象。</p>
<p>教师类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Author</span></span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">      <span class="keyword">private</span> String name;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> id;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.id = id;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> name;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.name = name;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>课程类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span></span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">      <span class="keyword">private</span> String name;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">      <span class="keyword">private</span> Author author;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> id;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.id = id;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> name;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.name = name;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> price;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.price = price;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> Author <span class="title">getAuthor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> author;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAuthor</span><span class="params">(Author author)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.author = author;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据绑定Demo</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">  <span class="comment">//控制器对应参数</span></span><br><span class="line">  <span class="meta">@RequestMapping</span>(value =<span class="string">"/pojoType"</span> )</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">pojoType</span><span class="params">(Model model,Course course)</span></span>&#123;</span><br><span class="line">          <span class="comment">//将穿过来的course插入到Map中</span></span><br><span class="line">        courseDao.add(course);</span><br><span class="line">          model.addAttribute(<span class="string">"courses"</span>,courseDao.getAll());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//表单中name的书写要求</span></span><br><span class="line">  &lt;form action=<span class="string">"pojoType"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">    请输入课程编号:&lt;input type=<span class="string">"text"</span> name=<span class="string">"id"</span>/&gt;</span><br><span class="line">      请输入课程名称:&lt;input type=<span class="string">"text"</span> name=<span class="string">"name"</span>/&gt;</span><br><span class="line">    请输入课程价格:&lt;input type=<span class="string">"text"</span> name=<span class="string">"price"</span>/&gt;</span><br><span class="line">      请输入教师编号:&lt;input type=<span class="string">"text"</span> name=<span class="string">"author.id"</span>/&gt;</span><br><span class="line">    请输入教师名称:&lt;input type=<span class="string">"text"</span> name=<span class="string">"author.name"</span>/&gt;</span><br><span class="line">      &lt;input type=<span class="string">"submit"</span> value=<span class="string">"提交"</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>



</li>
</ol>
</li>
</ul>
<ol start="5">
<li><p>集合（List，Set，Map）</p>
<p>不能直接为集合进行绑定，需定义一个包装类</p>
<p>List集合通过下标进行绑定List[1].id，Map集合通过key进行绑定Map[key].id</p>
<p>Set集合有些特殊，需要先向集合中添加两个实例，否则无法完成绑定，然后和List集合一样，通过下标进行绑定List[1].id。</p>
</li>
<li><p>JSON</p>
<p>SpringMVC是无法完成JSON格式数据的绑定的，需另外添加Jar包jackson-databind.jar,然后到配置文件中配置一个消息转换器。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;script type="text/javascript" src="js/jquery-1.8.3.min.js"&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"></span><br><span class="line">    $(function()&#123;</span><br><span class="line">        <span class="keyword">var</span> course = &#123;</span><br><span class="line">            <span class="string">"id"</span>:<span class="string">"8"</span>,</span><br><span class="line">            <span class="string">"name"</span>:<span class="string">"SSM框架整合"</span>,</span><br><span class="line">            <span class="string">"price"</span>:<span class="string">"200"</span></span><br><span class="line">        &#125;;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url:<span class="string">"jsonType"</span>,</span><br><span class="line">            data:JSON.stringify(course),</span><br><span class="line">            type:<span class="string">"post"</span>,</span><br><span class="line">            contentType:<span class="string">"application/json;charse=UTF-8"</span>,</span><br><span class="line">            dataType:<span class="string">"json"</span>,</span><br><span class="line">            success:function(data)&#123;</span><br><span class="line">                alert(data.name+<span class="string">"---"</span>+data.price);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<pre><code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/jsonType"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  Course <span class="title">jsonType</span><span class="params">(@RequestBody  Course course)</span></span>&#123;</span><br><span class="line">    course.setPrice(course.getPrice()+<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> course;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h4 id="SpringMVC拦截器"><a href="#SpringMVC拦截器" class="headerlink" title="SpringMVC拦截器"></a>SpringMVC拦截器</h4><p>拦截器起作用的地方：HandlerAdapter—&gt;Handler</p>
<h5 id="SpringMVC的环境配置与安装"><a href="#SpringMVC的环境配置与安装" class="headerlink" title="SpringMVC的环境配置与安装"></a>SpringMVC的环境配置与安装</h5><p>注意：使用maven archetype创建的web.xml内容版本较低，应更新（去别的地方复制粘贴过来）</p>
<h5 id="SpringMVC的拦截器在项目开发中的重要性"><a href="#SpringMVC的拦截器在项目开发中的重要性" class="headerlink" title="SpringMVC的拦截器在项目开发中的重要性"></a>SpringMVC的拦截器在项目开发中的重要性</h5><h5 id="SpringMVC的拦截器和过滤器的区别"><a href="#SpringMVC的拦截器和过滤器的区别" class="headerlink" title="SpringMVC的拦截器和过滤器的区别"></a>SpringMVC的拦截器和过滤器的区别</h5>]]></content>
  </entry>
  <entry>
    <title>数组中重复的数字</title>
    <url>/2019/07/15/%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p>题目一：找出数组中重复的数字</p>
<p>​    在一个长度为n的数组里的所有数字都在0~n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是重复的数字2或者3；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.NoSuchElementException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hogan_Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-07-15 13:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="comment">//暴力解法,直接循环，这样子得到的都是数组中第一个满足条件的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span>||array.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= array.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (array[i] == array[j]) &#123;</span><br><span class="line">                        <span class="keyword">return</span> array[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//很明显应该可以采用查找算法进行优化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试用例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指Offer</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Java</tag>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存模型</title>
    <url>/2019/07/09/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>Java多线程之间进行通信是基于共享内存的。下面我们就来了解以下Java中多线程处理共享变量时的内存模型。</p>
<p>&emsp;&emsp;Java内存模型（Java Memory Model，JMM）和JVM的内存结构完全是两码事，请不要混淆。其实JMM并不像JVM内存结构一样是真实存在的。它只是一个抽象的概念。大多数人一听到JMM，脑海里浮现的就是JVM内存区域的堆、虚拟机栈、本地方法栈、方法区……其实这两者并不是同一层次的内存划分，基本上是没有关系的。唯一的相似点就是都存在共享区域和私有区域</p>
<p><img src="http://cdn1.hikariblog.cn/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%88%92%E5%88%86.jpg" alt=""></p>
<p><span style="color:#2251a3">可以将“内存模型”理解为在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。</span></p>
<p><img src="http://cdn1.hikariblog.cn/%E5%A4%84%E7%90%86%E5%99%A8%E3%80%81%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E3%80%81%E4%B8%BB%E5%86%85%E5%AD%98%E9%97%B4%E7%9A%84%E4%BA%A4%E4%BA%92%E5%85%B3%E7%B3%BB.png" alt=""></p>
<p>但实际上JMM并不是“Java内存区域划分”；JMM是与并发编程相关的，它是一种符合内存模型规范的，屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存效果。目的是解决由于多线程通过共享内存进行通信时，存在的<span style="color:red">原子性、可见性（缓存一致性）以及有序性</span>问题。</p>
<p>&emsp;&emsp;Java内存模型规定了所有的变量（这里的变量包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的）都存放在主存中，当线程使用变量时都是把主存中的变量拷贝到自己的工作内存中，线程读写变量的时候操作的是自己工作内存中的变量。</p>
<p><img src="http://cdn1.hikariblog.cn/%E7%BA%BF%E7%A8%8B%E3%80%81%E4%B8%BB%E5%86%85%E5%AD%98%E3%80%81%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98%E4%B8%89%E8%80%85%E7%9A%84%E4%BA%A4%E4%BA%92%E5%85%B3%E7%B3%BB.png" alt="线程、主内存、工作内存三者的交互关系"></p>
<p><strong>主内存</strong></p>
<ul>
<li>存储Java实例对象</li>
<li>包括成员变量、类信息、常量、静态变量等</li>
<li>属于数据共享的区域，多线程并发操作时会引发线程安全问题</li>
</ul>
<p><strong>工作内存</strong></p>
<ul>
<li>存储当前方法的所有本地变量信息，本地变量对其他线程不可见</li>
<li>字节码行号指示器、Native方法信息</li>
<li>属于线程私有的数据区域，不存在线程安全问题</li>
</ul>
<p><strong>主内存与工作内存的数据存储类型以及操作方式归纳</strong></p>
<ul>
<li>方法里的基本数据类型本地变量将直接存储在工作内存的栈帧结构中</li>
<li>引用类型的局部变量：引用存储在工作内存中，实例存储在主内存中</li>
<li>成员变量(基本数据类型&amp;&amp;引用类型)、static变量、类信息均会被存储在主内存中</li>
<li>主内存共享的方式是线程各拷贝一份数据到工作内存，操作完成后刷新回主内存。</li>
</ul>
<p>&emsp;&emsp;当一个线程操作共享变量的时候，会进行以下三步操作：</p>
<ol>
<li><strong>当前线程首先从主存拷贝共享变量到自己的共享内存；</strong></li>
<li><strong>然后对工作内存里的变量进行处理；</strong></li>
<li><strong>处理完后更新变量值到主存。</strong></li>
</ol>
<hr>
<p>&emsp;&emsp;因为当一个线程操作共享变量的时候是分为三部分操作，而Java采用的是时间片轮转的线程调度算法，可能执行了两步操作后时间片用完就切换给另一个线程执行，故这三步操作不具有原子性，所以会造成共享变量的内存不可见问题，具体是当线程A修改了共享变量，并且还没刷新修改后的值到主存的时候，线程B从主内存获取了修改前的值，这时候线程A修改过的值对线程B来说就是不可见的。</p>
<h3 id="JMM如何解决可见性问题"><a href="#JMM如何解决可见性问题" class="headerlink" title="JMM如何解决可见性问题"></a>JMM如何解决可见性问题</h3><p>指令重排序需要满足的条件</p>
<ul>
<li><p>在单线程环境下不能改变程序运行的结果</p>
</li>
<li><p>存在数据依赖关系的不允许重排序</p>
<p>总结：无法通过happens-before原则推导出来的，才能进行指令的重排序。</p>
</li>
</ul>
<p>A操作的结果需要对B操作可见，则A与B存在happens-before关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i=<span class="number">1</span>;<span class="comment">//线程A执行</span></span><br><span class="line">j=i;<span class="comment">//线程B执行</span></span><br></pre></td></tr></table></figure>

<p><strong>happens-before的八大规则</strong></p>
<ol>
<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；</li>
<li>锁定规则：一个unLock操作先行于后面对同一个锁的lock操作；</li>
<li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；</li>
<li>传递规则：如果操作A先行与操作B，而操作A又先行于操作C，则可以得出操作A先行发生于操作C；</li>
<li>线程启动规则：Thread对象的start()方法先行于此线程的每一个动作。</li>
<li>线程中断规则：对线程interrupt()方法的调用先行发生于被终端线程的代码检测到中断事件的发生；</li>
<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值检测到线程已经终止执行。</li>
<li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始。</li>
</ol>
<p><strong>happens_before的概念</strong></p>
<p>&emsp;&emsp;如果两个操作部满足上述任意一个happens-before规则，那么这两个操作就没有顺序的保障，JVM可以对这两个操作进行重排序；</p>
<p>&emsp;&emsp;如果操作A happens-before操作B，那么操作A在内存上所做的操作对操作B都是可见的。</p>
<p><strong>volatile：JVM提供的轻量级同步机制</strong></p>
<ul>
<li><p>保证被volatile修饰的共享变量对所有线程总是可见的</p>
<p>当写一个volatile变量时，JMM会把该线程对应的工作内存中的共享变量值刷新到主内存中</p>
<p>当读取一个volatile变量时，JMM会把该线程对应的工作内存置为无效。</p>
</li>
<li><p>禁止指令重排序优化</p>
<p>内存屏障</p>
<ol>
<li>保证特定操作的执行顺序</li>
<li>保证某些变量的内存可见性</li>
</ol>
<p>通过插入内存屏障指令禁止在内存屏障前后的指令执行重排序优化。</p>
<p>强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Java内存模型</tag>
        <tag>JVM</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>一篇文章带你入门JUnit4</title>
    <url>/2019/07/06/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E5%85%A5%E9%97%A8JUnit4/</url>
    <content><![CDATA[<p>注：文章内容基于 <code>JUnit4.8</code></p>
<p>额，成为标题党了，以前一直认为写博客要特别严谨:disappointed_relieved:这样子写一遍博客耗费的时间特别长，更新的积极性都没有了，而且太过枯燥大家也是没兴趣看下去。然而又怎样呢？严谨一点总没错😏略略略</p>
<p>&emsp;&emsp;时至今日，<code>JUnit</code> 已成为 <code>Java</code> 中开发单元测试的事实上的标准框架。JUnit官网是这样描述JUnit的：JUnit是用于编写可复用测试的简单框架，是xUnit测试框架的一个子集。xUnit是一套基于测试驱动开发的测试框架。</p>
<p>&emsp;&emsp;<strong>一个典型的单元测试通常可以描述为：“确保方法接受预期范围内的输入，并且为每一次测试输入返回预期的值”。</strong>该描述要求我们通过方法的接口来测试方法的行为。如果我们将 <code>x</code> 值传给方法，那么它会返回 <code>y</code> 值吗？如果我们改为将 <code>z</code> 值传给方法，那么它会正确地抛出异常吗？我们可以了解到，<span style="color:#20B2AA">单元测试通常关注的是一个方法是否遵循它的 <code>API</code> 契约中的条款</span>，也就是方法对外提供的 <code>API</code> 能否达到预期的结果。可以看出，单元测试用来判断方法是否能达到想要的预期结果，但是对于方法内部的逻辑错误无能为力。比如你要测试的是 <code>1+1=2</code>，但是方法内部直接给你 <code>return 2</code> 单元测试的角度看来也是正确的。常年霸占leetcode contest全球排名第一的日本选手uwi，在解答[石子游戏][<a href="https://leetcode-cn.com/problems/stone-game/]一题时就直接" target="_blank" rel="noopener">https://leetcode-cn.com/problems/stone-game/]一题时就直接</a> <code>return true</code>，大家可以膜拜一下，但千万不要模仿，面试官会让你回去等通知的​​😂</p>
<p><em>一个典型的单元测试包含三个步骤：</em></p>
<ol>
<li>准备测试类及数据</li>
<li>执行要测试的行为</li>
<li>检查结果</li>
</ol>
<p>&emsp;&emsp;单元测试的核心原则是“任何没有经过自动测试的程序功能都可以当作不存在”。</p>
<p>&emsp;&emsp;<strong>单元测试框架应该遵循以下几条最佳实践规则。</strong></p>
<ul>
<li><p>每个单元测试都必须独立于其他所有单元测试而运行；单元测试之间不能有任何的依赖。。</p>
</li>
<li><p>框架应该以单个测试为单位来检测和报告错误；</p>
</li>
<li><p>应该易于定义要运行哪些单元测试。</p>
<p><strong>JUnit的设计目标。</strong></p>
</li>
<li><p>框架必须帮助我们编写有用的测试；</p>
</li>
<li><p>框架必须帮助我们创建具有长久价值的测试；</p>
</li>
<li><p>框架必须帮助我们通过复用代码来降低编写测试的成本。</p>
<p><strong>使用JUnit测试</strong></p>
</li>
<li><p>针对每个单元测试，单独测试类实例和类加载器，以避免副作用。</p>
</li>
<li><p>JUnit注解提供了资源初始化和回收方法＠Before 、 ＠BeforeClass、＠After 和 @AfterClass；</p>
</li>
<li><p>各种不同的 assert方法使得检查测试结果更加简单</p>
</li>
<li><p>与各种流行工具（如 Ant 和 Maven ）的整合，以及与流行IDE （如eclipse 、NetBeans、lntelliJ 和 JBuilder ）的整合．</p>
</li>
</ul>
<p><strong>测试类：</strong></p>
<ol>
<li>必须是公共类并且包含一个无参的构造函数。</li>
<li>测试类中至少要有一个测试方法。</li>
<li>最好的做法是按照 <code>XXXTest</code> 模式命名测试类。</li>
</ol>
<p><strong>测试方法：</strong></p>
<ol>
<li>必须使用<code>@Test</code>注解，是公共的，不带任何参数，并且返回void类型。</li>
<li>最好的做法是按照 <code>testXXX</code> 模式命名测试方法。</li>
<li>每个测试方法都必须独立于其他所有测试方法而运行，可以通过右键对应的测试方法单独运行；测试方法之间不能有任何的依赖。</li>
</ol>
<p>一个简单的例子如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> number1,<span class="keyword">double</span> number2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number1+number2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.assertEquals;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertEquals(<span class="number">60</span>, <span class="keyword">new</span> Calculator().add(<span class="number">50</span>, <span class="number">10</span>), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span style="color:red">注意:单元测试代码是不会出现在最终产品当中的。</span>除非开发的产品是类似于 <code>leetcode</code> 之类的在线评测系统，所以我们应该新建一个测试代码目录_test_来存放单元测试，测试代码目录_test_和被测试代码目录的包保持一致。在产品发布时再将测试代码文件夹_test_删除。</p>
<hr>
<p>&emsp;&emsp;<span style="color:red"><code>JUnit</code> 在调用（执行）每个 <code>@Test</code> 方法之前，为测试类创建一个新的实例</span>，这有助于提供测试方法之间的独立性，并且避免在测试代码中产生意外的副作用。<span style="color:#20B2AA">因为每个测试方法都运行于一个新的测试类实例上，所以我们就不能在测试方法之间重用各个实例变量值。</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.assertEquals;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertEquals(<span class="number">60</span>, <span class="keyword">new</span> Calculator().add(<span class="number">50</span>, <span class="number">10</span>), <span class="number">0</span>);</span><br><span class="line">        System.out.println(a++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testXXX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>以上例子的两个输出都是0。</p>
<p>JUnit采用断言机制，对运行结果作一个预期判断，从而实现测试的目的。</p>
<p>静态导入断言方法，进行测试验证，具体的断言方法查看帮助文档。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br></pre></td></tr></table></figure>

<p><strong>JUnit的运行流程：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XXXTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@BeforeClass</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setUpBeforeClass</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Method with @BeforeClass annotation"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterClass</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tearDownClass</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Method with @AfterClass annotation"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Method with @Before annotation"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Method with @After annotation"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Test method--test1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Test method--test2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<img src="http://cdn1.hikariblog.cn/Junit_%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt="运行结果"></p>
<ol>
<li><code>@BeforeClass</code> 修饰的方法会在所有方法被调用前执行，而且该方法是静态的，所以当测试类被加载后接着就会运行它。而且在内存中它只会存在一份实例，它比较适合加载配置文件。</li>
<li><code>@AfterClass</code> 所修饰的方法通常用来对资源的清理，如关闭数据库的连接</li>
<li><code>@Before</code> 会在每个测试方法运行前执行一次。</li>
<li><code>@After</code> 会在每个测试方法运行后执行一次。</li>
</ol>
<p><strong>JUnit常用注解:</strong></p>
<p><code>@Test</code> 将一个普通的方法修饰成为一个测试方法</p>
<p>​    <code>@Test(expected=异常类)</code> 预期会抛出什么异常</p>
<p>​    <code>@Test(timeout=毫秒)</code> 限定测试运行的时间，超出时间自动终止运行。</p>
<p><code>@Ignore</code> 所修饰的测试方法会被测试运行器忽略。</p>
<p><code>@RunWith</code> 可以更改测试运行器 <code>org.junit.runner.Runner</code></p>
<p><strong>测试失败的两种情况：</strong></p>
<ol>
<li><code>Failure</code> 一般由单元测试使用的断言方法判断失败所引起的，表示程序输出的结果和我们预期的结果不一样。</li>
<li><code>Error</code> 是由代码异常引起的，它可以产生于测试代码本身的错误，也可能是被测试代码中的一个隐藏的 <code>bug</code>。</li>
<li><span style="color:red">测试用例不是用来证明你是对的，而是用来证明你没有错。</span></li>
</ol>
<p>&emsp;&emsp;当你需要一次运行多个测试用例时，你就要创建另一个叫做测试套件/测试集（test suite或Suite）的对象。你的测试套件也是一个特定的测试运行器（或者Runner），因此可以像运行测试用例那样运行它。一旦你理解了测试用例，Suite与Runner是如何工作的，你就可以编写你所需要的任何测试了。这3个对象形成了JUnit框架的核心。</p>
<p>&emsp;&emsp;在日常工作中，你只需要编写测试类与测试集，其他类会在幕后帮你完成测试。</p>
<ul>
<li>测试用例/测试类（<code>Test class</code>或<code>TestCase</code>或<code>test case</code>）——一个包含一个或者多个测试（测试方法）的类，而这些测试就是指那些用 <code>@Test</code> 注释的方法。使用一个测试用例，可以把具有公共行为的测试归为一组。<span style="color:red">通常在生产类和测试类之间都存在着一对一的对应关系</span>。</li>
<li>测试套件/测试集（ <code>Suite</code> 或 <code>test suite</code>）——一组测试，测试套件是一种把多个相关测试用例归入一组的便捷方式。比如，如果你没有为测试类定义一个测试套件，那么JUnit会自动提供一个测试套件，包含测试类中的所有的测试。<span style="color:red">一个测试套件通常将同一个包中的测试类归为一组</span>。</li>
<li>测试运行器（ <code>Runner</code> 或 <code>test runner</code> ）——执行测试套件的程序。JUnit提供了多种运行器来执行你的测试。</li>
</ul>
<hr>
<h3 id="参数化测试-RunWith-Paramterized-class"><a href="#参数化测试-RunWith-Paramterized-class" class="headerlink" title="参数化测试@RunWith(Paramterized.class)"></a>参数化测试@RunWith(Paramterized.class)</h3><p>&emsp;&emsp;<span style="color:red">Paramterized（参数化）的测试运行器允许你使用不同的参数多次运行同一个测试。</span>通常在测试中需要考虑多种情况的发生，这时候参数化测试就非常有效。例子如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.junit.runners.Parameterized;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.assertEquals;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hogan_Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> -07-12 8:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RunWith</span>(value = Parameterized<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">CalculatorTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> expected;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> valueOne;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> valueTwo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CalculatorTest</span><span class="params">(<span class="keyword">double</span> expected, <span class="keyword">double</span> valueOne, <span class="keyword">double</span> valueTwo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.expected = expected;</span><br><span class="line">        <span class="keyword">this</span>.valueOne = valueOne;</span><br><span class="line">        <span class="keyword">this</span>.valueTwo = valueTwo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Parameterized</span>.Parameters</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Collection&lt;Integer[]&gt; getTestParameters() &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(<span class="keyword">new</span> Integer[][]&#123;</span><br><span class="line">                &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                &#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertEquals(expected, <span class="keyword">new</span> Calculator().add(valueOne, valueTwo), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;要使用Parameterized的测试运行器来运行一个测试用例，那就必须要满足以下要求：</p>
<ol>
<li><p>测试用例必须使用 <code>@RunWith</code> 注解，并且要将 <code>Parameterized</code> 类作为它的参数。也就是将测试运行器更改为  <code>RunWith(Parameterized.class)</code> </p>
</li>
<li><p>声明测试中使用到的实例变量。同时提供一个 <code>@Parameterized</code> 注解的方法。这个方法的修饰符和返回值必须是 <code>@Parameters public static java.util.Collection</code>,无任何参数。 <code>Collection</code> 元素必须是相同长度的数组，这个数组的长度必须要和这个唯一的公共构造函数的参数数量相匹配。</p>
</li>
<li><p>注意：该测试用例没有无参数的构造函数，而有一个可以为测试接受参数的构造函数。</p>
</li>
<li><p>调用提供的参数编写一个 <code>@Test</code> 注解的测试。</p>
</li>
</ol>
<p>&emsp;&emsp;这里我们逐步分析上面例子的JUnit的运行过程：首先，JUnit调用了静态方法 <code>getTestParameters</code>。接下来，JUnit为 <code>getTestParameters</code> 集合中的每个数组进行循环。然后，JUnit调用唯一的公共构造函数。如果存在多个公共构造函数，JUnit就会抛出一个断言错误。JUnit使用由数组元素构成的一系列参数来调用构造函数。在这个示例中，JUnit使用数组中的第一个元素调用有3个参数的构造函数，而这个元素本身就是一个数组：{2,1,1}.然后JUnit会像平时一样调用 <code>@Test</code> 方法。JUnit会为 <code>getTestParameters</code> 集合中的下一个数组重复以上的过程。</p>
<blockquote>
<p>如果没有显式指定测试运行器，则默认由JUnit的facade决定使用哪个运行器来运行你的测试。</p>
</blockquote>
<hr>
<h3 id="测试套件-RunWith-Suite-class"><a href="#测试套件-RunWith-Suite-class" class="headerlink" title="测试套件@RunWith(Suite.class)"></a>测试套件@RunWith(Suite.class)</h3><p>&emsp;&emsp;用Suite(测试套件 )来组合测试用例。Suite是一个容器，用来将一个或多个测试用例归在一起，并把它们作为一个集合<span style="color:red">一起运行</span>。用注解 <code>@RunWith</code> 和 <code>@SuiteClasses</code> 注释类，作为测试套件的入口类，这个类中不能包含其它的方法。</p>
<p><code>@RunWith(Suite.class)</code> 指定测试运行器 <code>Suite.class</code>。</p>
<p><code>@SuiteClasses</code> 列出我们想要在这个测试集中包含的所有测试类，这些测试类中的所有 <code>@Test</code> 方法都将包含到该 <code>Suite</code> 中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.junit.runners.Suite;</span><br><span class="line"><span class="meta">@RunWith</span>(Suite<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">Suite</span>.<span class="title">SuiteClasses</span>(<span class="title">value</span></span>=&#123;CalculatorTest<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">AllTest</span> </span>&#123;</span><br><span class="line">  <span class="comment">// the class remains empty,</span></span><br><span class="line">  <span class="comment">// used only as a holder for the above annotations</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面展示了如何将多个测试用例组合成测试套件，同理也能将多个测试套件组合成一个主测试套件。<span style="color:blue">除了JUnit的Suite之外，各种构建工具和IDE也提供了运行指定的多组测试用例和测试套件的功能。</span>大家可以根据实际工作需要再做扩展学习。</p>
<h3 id="单元测试的必要性"><a href="#单元测试的必要性" class="headerlink" title="单元测试的必要性"></a>单元测试的必要性</h3><p>单元测试的主要目的就是验证你的应用程序可以按照预期的方式正常运行，以及尽早地发现错误。</p>
<p><strong>带来更高的测试覆盖率</strong></p>
<p>&emsp;&emsp;功能测试应该是任何应用程序所采用的首选测试类型。功能测试可以覆盖大约70%的应用程序代码，相比之下，单元测试能够提供更高的测试覆盖率，以及更容易地模拟错误条件。</p>
<p><strong>提高团队效率</strong></p>
<p>&emsp;&emsp;单元测试相比其他类型的测试所测试的单位较小，对每一个方法进行测试，而不必等到其他所有的组件都完成以后。</p>
<p><strong>监测衰退和减少调试</strong></p>
<p>&emsp;&emsp;单元测试会告诉你那个方法出错了，而不必每次都去慢慢调试程序，为找出错误所在的地方而耗费大量的时间。</p>
<p><strong>自信地重构</strong></p>
<p>&emsp;&emsp;重构之后的代码能在优化的同时继续通过单元测试，类似于测试驱动开发TDD了，但是重构是为了更好的实现，而不是从零开始。单元测试框架xUnit的流行推动了敏捷开发</p>
<p><strong>改进实现</strong></p>
<p>&emsp;&emsp;良好的代码实现应该是易于测试的，如果测试代码太长或者笨拙，则说明带测试代码本身的设计不够灵活。</p>
<p><strong>将预期的行为文档化</strong></p>
<p>&emsp;&emsp;单元测试本身就是展示方法API最好的示例。</p>
<h3 id="对输出语句-System-out-println-进行单元测试。"><a href="#对输出语句-System-out-println-进行单元测试。" class="headerlink" title="对输出语句 System.out.println() 进行单元测试。"></a>对输出语句 <code>System.out.println()</code> 进行单元测试。</h3><p><a href="https://stefanbirkner.github.io/system-rules/index.html" target="_blank" rel="noopener">System Rules库</a>中存在一个JUnit规则 <code>StandardOutputStreamLog</code> 能够基于控制台的输出编写断言。样例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Rule;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.contrib.java.lang.system.SystemOutRule;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hogan_Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-07-20 10:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintlnTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Rule</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> SystemOutRule systemOutRule = <span class="keyword">new</span> SystemOutRule().enableLog();</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPrintln</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Playing"</span>);</span><br><span class="line">        assertEquals(<span class="string">"Playing\r\n"</span>, systemOutRule.getLog());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>单元测试</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>单元测试</tag>
        <tag>JUnit</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring框架</title>
    <url>/2019/06/26/Spring%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="Spring的核心"><a href="#Spring的核心" class="headerlink" title="Spring的核心"></a>Spring的核心</h1><p>&emsp;&emsp;<code>Spring</code>的成功来自于<span style="color:blue">理念</span>，而不是技术，它最为核心的理念是<code>IoC</code>(控制反转)和<code>AOP</code>(面向切面编程)，其中<code>IoC</code>是<code>Spring</code>的基础，而<code>AOP</code>则是其重要的功能，最为典型的当属<u>数据库事务</u>的使用。</p>
<h3 id="一、开发步骤"><a href="#一、开发步骤" class="headerlink" title="一、开发步骤"></a>一、开发步骤</h3><h5 id="1-以maven依赖的形式引入Spring开发jar包"><a href="#1-以maven依赖的形式引入Spring开发jar包" class="headerlink" title="1. 以maven依赖的形式引入Spring开发jar包"></a>1. 以maven依赖的形式引入Spring开发jar包</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-beans --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-expression --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-expression<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/commons-logging/commons-logging --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="2-理解IOC控制反转和DI依赖注入"><a href="#2-理解IOC控制反转和DI依赖注入" class="headerlink" title="2. 理解IOC控制反转和DI依赖注入"></a>2. 理解IOC控制反转和DI依赖注入</h5><p>&emsp;&emsp;<code>IOC(Inverse of Control)</code> 反转控制的概念，就是将原本在程序中手动创建对象的控制权，交由 <code>Spring</code> 框架管理；简单说，就是创建对象控制权被反转到了 <code>Spring</code> 框架。我们通过描述(XML或者注解)并通过IoC容器去产生或获取特定对象的方式。</p>
<p>&emsp;&emsp;<code>DI(Dependency Injection)</code> 依赖注入的概念，就是在 <code>Spring</code> 创建这个对象的过程中，将这个对象所依赖的属性（也可能是自定义<span style="color:#e7a791">引用类型</span>的属性）注入进去，<span style="color:rgb(255, 68, 68)">从而实现应用对象之间协作关系的协调，让相互协作的软件组件保持松散耦合。</span></p>
<p><img src="http://cdn1.hikariblog.cn/Spring.png" alt="Spring"></p>
<h5 id="3-编写Spring的核心配置文件"><a href="#3-编写Spring的核心配置文件" class="headerlink" title="3. 编写Spring的核心配置文件"></a>3. 编写Spring的核心配置文件</h5><p>&emsp;&emsp;Spring默认的配置文件名字 <code>applicationContext.xml</code>，在配置文件中用 <code>&lt;bean&gt;&lt;/bean&gt;</code> 标签<span style="color:#0000EE">装配Bean</span>。</p>
<p>注意：Eclipse中可以通过安装sts插件实现自动生成配置文件和Spring相关代码提示的功能。</p>
<h5 id="4-在程序中读取Spring的配置文件，通过Spring框架获得Bean，完成相应的操作"><a href="#4-在程序中读取Spring的配置文件，通过Spring框架获得Bean，完成相应的操作" class="headerlink" title="4. 在程序中读取Spring的配置文件，通过Spring框架获得Bean，完成相应的操作"></a>4. 在程序中读取Spring的配置文件，通过Spring框架获得Bean，完成相应的操作</h5><p>&emsp;&emsp;在类中通过应用上下文<span style="color:#0000EE">创建和组装对象</span>，如下操作获得类实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext applicationContext=<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">		Userservice userService=(Userservice)applicationContext.getBean(<span class="string">"userService"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="二、SpringBean管理"><a href="#二、SpringBean管理" class="headerlink" title="二、SpringBean管理"></a>二、SpringBean管理</h3><h4 id="1-Spring的工厂类"><a href="#1-Spring的工厂类" class="headerlink" title="1. Spring的工厂类"></a>1. Spring的工厂类</h4><p>&emsp;&emsp;Spring IoC容器的设计主要是基于<code>BeanFactory</code>和<code>ApplicationContext</code>两个接口，其中<code>ApplicationContext``是BeanFactory</code>的子接口之一，换句话说<code>BeanFactory</code>是Spring IoC容器所定义的最底层接口，而<code>ApplicationContext</code>是其高级接口之一，并且对<code>BeanFactory</code>功能做了许多有用的扩展，所以在绝大部分的工作场景虾，都会使用<code>ApplicationContext</code>作为Spring IoC容器。</p>
<h4 id="2-Spring的Bean管理（XML方式）"><a href="#2-Spring的Bean管理（XML方式）" class="headerlink" title="2. Spring的Bean管理（XML方式）"></a>2. Spring的Bean管理（XML方式）</h4><h6 id="2-1-使用类构造器实例化（默认无参数）"><a href="#2-1-使用类构造器实例化（默认无参数）" class="headerlink" title="2.1 使用类构造器实例化（默认无参数）"></a>2.1 使用类构造器实例化（默认无参数）</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Bean1.java</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bean1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件中Bean的装配：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- applicationContext.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean1"</span> <span class="attr">class</span>=<span class="string">"Bean1"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="2-2-使用静态工厂方法实例化（简单工厂模式）"><a href="#2-2-使用静态工厂方法实例化（简单工厂模式）" class="headerlink" title="2.2 使用静态工厂方法实例化（简单工厂模式）"></a>2.2 使用静态工厂方法实例化（简单工厂模式）</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Bean2.java</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean2</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Bean2Factory.java</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean2Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bean2 <span class="title">createBean2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Bean2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件中Bean的装配：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- applicationContext.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean2"</span> <span class="attr">class</span>=<span class="string">"BeanFactory"</span> <span class="attr">fatory-method</span>=<span class="string">"createBean2"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="2-3-使用实例工厂方法实例化（工厂方法模式）"><a href="#2-3-使用实例工厂方法实例化（工厂方法模式）" class="headerlink" title="2.3 使用实例工厂方法实例化（工厂方法模式）"></a>2.3 使用实例工厂方法实例化（工厂方法模式）</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Bean3.java</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean3</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Bean3Factory.java</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean3Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bean3 <span class="title">createBean3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Bean3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件中Bean的装配：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- applicationContext.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean3Factory"</span> <span class="attr">class</span>=<span class="string">"Bean3Factory"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean3"</span> <span class="attr">factory-bean</span>=<span class="string">"bean3Factory"</span> <span class="attr">factory-method</span>=<span class="string">"createBean3"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>Bean的配置</strong></p>
<ul>
<li><strong>id和name</strong><ul>
<li>一般情况下，装配一个 <code>Bean</code> 时，通常指定一个 <code>id</code> 属性作为 <code>Bean</code> 的名称。</li>
<li><code>id</code> 属性在 <code>IOC</code> 容器中必须是唯一的，当然使用过程中也要保证 <code>name</code> 唯一（额，还像看其它的书说可以不唯一）。</li>
<li><span style="color:red">如果 <code>Bean</code> 的名称中含有特殊字符，就需要使用 <code>name</code> 属性</span>，其他情况 <code>name</code> 等同于 <code>id</code> 。</li>
</ul>
</li>
<li><strong>class</strong><ul>
<li><code>class</code> 用于设置一个类的<span style="color:red">完全路径</span>名称，主要作用是<code>IOC</code>容器生成类的实例。</li>
</ul>
</li>
</ul>
<p><strong>Bean的作用域</strong>（用scope属性指定）</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>singleton</td>
<td>在SpringIOC容器中仅存在一个Bean实例，Bean以单实例的方式存在（如果没用指定时默认为singleton)</td>
</tr>
<tr>
<td>prototype</td>
<td>每次调用getBean()时都会返回一个新的实例</td>
</tr>
<tr>
<td>request</td>
<td>每次HTTP请求都会创建一个新的Bean，该作用域仅适用于WebApplicationContext环境</td>
</tr>
<tr>
<td>session</td>
<td>同一个HTTP Session共享一个Bean，不同的HTTP Session使用不同的Bean。该作用域仅适用于WebApplicationContext环境</td>
</tr>
</tbody></table>
<p>可以用<code>==</code>对比两个对象变量的引用，由此判断是不是同一个对象。</p>
<p><strong>Spring容器中Bean的生命周期</strong></p>
<p>spring初始化bean或销毁bean时，有时需要做一些处理工作，因此spring可以在创建和销毁bean的时候调用bean的两个生命周期方法。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"xxx"</span> <span class="attr">class</span>=<span class="string">"...Yoo"</span> <span class="attr">init-method</span>=<span class="string">"init"</span> <span class="attr">destory-method</span>=<span class="string">"destory"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>当然初始化和销毁时的方法应该在Bean里面，方法的名字可以自定义。</p>
<p>销毁时的方法有条件，必须是 <code>scope=singleton</code> 的情况下才会调用。</p>
<p>调用close()方法销毁应用上下文就可以销毁对象。</p>
<img  src=http://www.plantuml.com/plantuml/svg/uoekIImguU8g09AP9PdvUGfEgObvJoUiVzgrGg6Qo-hfkdbFzdK_xPbcpGNaB5pzjBNrwSPvpngMW_WlDZG_dx82fC4lCJVLiJonAFNvh9RYr1AOa8RcisaxdssUYghOBJ6v9B-e4aqzL1HJYsD1GKvcSYB8SSxvUIMf5IL8EZ4biTaOa5zS4b2KdvnQN9nV1DJuSb7BquwvJvU3F8QktZCF60w9EPbLcNdf8Br0vObf9Qb5GFq5gS10IYqEJYt1TEMBzbLFryrwihCJg1wdsTZS0bVyT48VN7qjUeoydDBmR7qZC4PWHhba5XVa5oScvQH27PcIMemz_91T1Z46sPhKl1Gk0000>



<h4 id="3-Spring的属性注入（XML方式）"><a href="#3-Spring的属性注入（XML方式）" class="headerlink" title="3. Spring的属性注入（XML方式）"></a>3. Spring的属性注入（XML方式）</h4><ul>
<li><p>对于类成员变量，注入方式有三种：</p>
<ol>
<li><span style="color:red">构造方法注入</span></li>
<li><span style="color:red">设值注入</span></li>
<li>接口注入</li>
</ol>
</li>
<li><p><span style="color:red">Spring支持前两种</span></p>
<h5 id="构造方法注入"><a href="#构造方法注入" class="headerlink" title="构造方法注入"></a>构造方法注入</h5><p>&emsp;&emsp;通过构造方法注入Bean的属性值或依赖的对象，它保证了Bean实例在实例化后就可以使用。</p>
<p>&emsp;&emsp;构造器注入到 <code>&lt;constructor-arg&gt;</code> 元素里声明的属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name,Integer age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"张三"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"23"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="c-名称空间"><a href="#c-名称空间" class="headerlink" title="c-名称空间"></a>c-名称空间</h6><p><span style="color:red">c:&lt;属性名&gt;=”xxx” 引入常量值</span></p>
<p><span style="color:red">c:&lt;属性名&gt;-ref=”xxx”  引入其它Bean对象</span></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"User"</span> <span class="attr">c:age</span>=<span class="string">"23"</span> <span class="attr">c:name</span>=<span class="string">"张三"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="属性setter方法注入"><a href="#属性setter方法注入" class="headerlink" title="属性setter方法注入"></a>属性setter方法注入</h5><p>&emsp;&emsp;使用setter方法注入，在Spring配置文件中，通过 <code>&lt;property&gt;</code> 设置注入属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Cat cat;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCat</span><span class="params">(Cat cat)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cat=cat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"Cat"</span> <span class="attr">id</span>=<span class="string">"cat"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"ketty"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"Person"</span> <span class="attr">id</span>=<span class="string">"person"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cat"</span> <span class="attr">ref</span>=<span class="string">"cat"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"李四"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"32"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="p-名称空间-属性注入"><a href="#p-名称空间-属性注入" class="headerlink" title="p-名称空间 属性注入"></a>p-名称空间 属性注入</h6><p><span style="color:red">p:&lt;属性名&gt;=”xxx” 引入常量值</span></p>
<p><span style="color:red">p:&lt;属性名&gt;-ref=”xxx”  引入其它Bean对象</span></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"Cat"</span> <span class="attr">id</span>=<span class="string">"cat"</span> <span class="attr">p:name</span>=<span class="string">"ketty"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"Person"</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">p:cat-ref</span>=<span class="string">"cat"</span> <span class="attr">p:name</span>=<span class="string">"李四"</span> <span class="attr">p:age</span>=<span class="string">"32"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="构造方法和Setter方法属性注入通用"><a href="#构造方法和Setter方法属性注入通用" class="headerlink" title="构造方法和Setter方法属性注入通用"></a>构造方法和Setter方法属性注入通用</h5><h6 id="复杂类型的属性注入"><a href="#复杂类型的属性注入" class="headerlink" title="复杂类型的属性注入"></a>复杂类型的属性注入</h6><ul>
<li><p>数组类型的属性注入</p>
<p>同List集合类型的属性注入</p>
</li>
<li><p>List集合类型的属性注入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloWorldBean"</span> <span class="attr">class</span>=<span class="string">"io.github.forhcl.spring.HelloWorldBean"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>12<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>33<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Set集合类型的属性注入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloWorldBean"</span> <span class="attr">class</span>=<span class="string">"io.github.forhcl.spring.HelloWorldBean"</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">value</span>&gt;</span>12<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">value</span>&gt;</span>33<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Map集合类型的属性注入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloWorldBean"</span> <span class="attr">class</span>=<span class="string">"io.github.forhcl.spring.HelloWorldBean"</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"12"</span> <span class="attr">value</span>=<span class="string">"23"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Properties类型的属性注入(属性类型)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloWorldBean"</span> <span class="attr">class</span>=<span class="string">"io.github.forhcl.spring.HelloWorldBean"</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"username"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"password"</span>&gt;</span>123<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<h6 id="SpEL-Spring-expression-language-属性注入"><a href="#SpEL-Spring-expression-language-属性注入" class="headerlink" title="SpEL(Spring expression language) 属性注入"></a>SpEL(Spring expression language) 属性注入</h6><ul>
<li><p>SpEL：spring expression language，spring表达式语言，对依赖注入进行简化</p>
</li>
<li><p>语法：#{表达式}</p>
</li>
<li><p><code>value=&quot;#{表达式}&quot;</code></p>
<p>​    SpEL表达式语言</p>
<p>​        语法：#{}</p>
<p>​        #{‘hello’}:使用字符串</p>
<p>​        #{beanID}:使用另一个Bean</p>
<p>​        #{beanId.content.toUpperCase()}:使用指定名属性，并使用方法</p>
<p>​        #{T(java.lang.Math).PI}:使用静态字段或方法</p>
</li>
</ul>
<h4 id="4-Spring的Bean管理（注解方式）"><a href="#4-Spring的Bean管理（注解方式）" class="headerlink" title="4. Spring的Bean管理（注解方式）"></a>4. Spring的Bean管理（注解方式）</h4><p>&emsp;&emsp;</p>
<h4 id="5-Spring的属性注入（注解方式）"><a href="#5-Spring的属性注入（注解方式）" class="headerlink" title="5. Spring的属性注入（注解方式）"></a>5. Spring的属性注入（注解方式）</h4><h4 id="6-自动化装配"><a href="#6-自动化装配" class="headerlink" title="6. 自动化装配"></a>6. 自动化装配</h4><p>&emsp;&emsp;<code>Spring</code> 从两个角度来实现自动化装配：</p>
<ul>
<li><p>组件扫描（component scanning）：<code>Spring</code> 会自动发现应用上下文中所创建的 <code>bean</code>。</p>
<h6 id="相关注解"><a href="#相关注解" class="headerlink" title="相关注解"></a>相关注解</h6><p><code>@Component</code> ：表明该类会作为组件类，并告知 <code>Spring</code> 要为这个类创建 <code>bean</code>。</p>
<p>&emsp;&emsp;除了 <code>@Component</code> （通用）外，<code>Spring</code> 提供了3个功能基本和 <code>@component</code> 等效的注解：</p>
<ul>
<li>@Repository 用于对DAO实现类进行标注</li>
<li>@Service 用于对Service实现类进行标注</li>
<li>@Controller 用于对Controller实现类进行标注</li>
</ul>
<p><code>@ComponentScan</code>：会扫描与配置类相同的包，查找带有 <code>@Component</code> 注解的类，为其创建一个 <code>bean</code>。</p>
</li>
<li><p>自动装配：<code>Spring</code> 自动满足 <code>bean</code> 之间的依赖。</p>
<h6 id="相关注解-1"><a href="#相关注解-1" class="headerlink" title="相关注解"></a>相关注解</h6><p><code>@ContextConfiguration</code> 加载配置</p>
<p><code>@RunWith()</code>测试运行器，在测试开始时自动创建Spring的应用上下文</p>
<p><code>@Value(&quot;param&quot;)</code> 注入常量值</p>
<p><code>@Autowired</code> 引入其它的Bean对象，默认<u>按照Java类型匹配</u>；如果存在两个Bean类型相同，则<u>按照名称注入</u>。</p>
<p><code>@Autowired</code>和<code>@Qualifier(&quot;name&quot;)</code><span style="color:red">一起使用</span>按指定名称注入其它Bean对象。等同于<code>@Rresource(name=&quot;~&quot;)</code></p>
<h6 id="其它注解"><a href="#其它注解" class="headerlink" title="其它注解"></a>其它注解</h6><p>生命周期注解：</p>
<ul>
<li>@PostConstruct——初始化，相当于XML装配Bean时的init-method属性。当Bean被载入到容器的时候调用。</li>
<li>@preDestroy——销毁，相当于XML装配Bean时的destory-method属性。当Bean从容器中删除的时候调用（scope=singleton有效）。</li>
</ul>
<p>Bean的作用范围：</p>
<ul>
<li>使用组件扫描的Bean和 <code>&lt;bean&gt;</code> 配置的一样，默认作用范围都是singleton。</li>
<li>@Scope注解用于指定Bean的作用范围。</li>
</ul>
</li>
</ul>
<h4 id="7-Spring的XML和注解整合开发"><a href="#7-Spring的XML和注解整合开发" class="headerlink" title="7.Spring的XML和注解整合开发"></a>7.Spring的XML和注解整合开发</h4><ul>
<li><p>XML方式的优势</p>
<ul>
<li>结构清晰，易于阅读</li>
</ul>
</li>
<li><p>注解方式的优势</p>
<ul>
<li>开发便捷，属性注入方便</li>
</ul>
</li>
<li><p>XML与注解的整合开发(用XML管理类，JavaConfig进行依赖的注入)</p>
<ul>
<li>1、引入context命名空间</li>
</ul>
</li>
</ul>
<ul>
<li>2、在配置文件中添加 <code>context:annotation-config</code> 标签</li>
</ul>
<hr>
<h1 id="Spring事务管理"><a href="#Spring事务管理" class="headerlink" title="Spring事务管理"></a>Spring事务管理</h1><p>Java事务导引</p>
<ul>
<li><p>什么是事务？</p>
<ul>
<li>事务是<span style="color:red">正确执行</span>一系列的操作（或动作），使得<u>数据库</u>从一种状态转换成另一种状态，且保证操作<span style="color:red">全部成功</span>，或者<span style="color:red">全部失败</span>。</li>
</ul>
</li>
<li><p>事务的原则性内容</p>
<ul>
<li>事务必须服从ISO/IEC所制定的ACID原则。</li>
<li><span style="color:red">ACID</span>原则的具体内涵如下：<ul>
<li>原子性(Atomicity):即不可分割性，事务要么全部被执行，要么就全部不被执行。</li>
<li>一致性(Consistency):事务的执行使得数据库从一种正确状态转换成另一种正确状态。</li>
<li>隔离性(Isolation):在事务正确提交之前，它可能的结果不应显示给任何其他事务。</li>
<li>持久性(Durability):事务正确提交后，其结果将永久保存在数据库中。</li>
</ul>
</li>
</ul>
</li>
<li><p>事务与Java的关系</p>
<p>Java事务的产生</p>
<ul>
<li>程序操作数据库的需要。在Java编写的程序或系统中，实现ACID的操作。</li>
</ul>
<p>Java事务实现范围</p>
<ul>
<li>通过JDBC相应方法间接来实现对数据库的增、删、改、查，把事务转移到Java程序代码中进行控制；</li>
<li>确保事务——要么全部执行成功，要么撤销不执行。</li>
</ul>
<p><span style="color:red">总结：</span>Java事务机制和原理就是确保数据库操作的ACID特性。</p>
</li>
<li><p>Java事务实现模式</p>
<ul>
<li>JDBC：Connection对象控制，包括手动模式和自动模式；</li>
<li>JTA（Java Transaction API）事务：<span style="color:red">与实现无关，与协议无关的API</span></li>
<li>容器事务：应用服务器提供的，且大多是基于JTA完成(通常基于JNDI的，相当复杂的API实现)</li>
</ul>
<p>三种事务的差异</p>
<ul>
<li>JDBC事务：控制的局限在一个数据库连接内，但是其使用简单。</li>
<li>JTA事务：功能强大，可跨越多个数据库或多个DAO，使用比较复杂。</li>
<li>容器事务：主要指的是J2EE应用服务器提供的事务管理，局限于EJB</li>
</ul>
</li>
</ul>
<p>Spring事务核心接口</p>
<ul>
<li><p>编程式事务管理</p>
</li>
</ul>
<p>声明式事务管理</p>
<p>事务的最佳实践</p>
<h1 id="后端中的Spring"><a href="#后端中的Spring" class="headerlink" title="后端中的Spring"></a>后端中的Spring</h1><h3 id="一、JDBC-Template（简化持久化技术）"><a href="#一、JDBC-Template（简化持久化技术）" class="headerlink" title="一、JDBC Template（简化持久化技术）"></a>一、JDBC Template（简化持久化技术）</h3><h4 id="课程介绍"><a href="#课程介绍" class="headerlink" title="课程介绍"></a>课程介绍</h4><ul>
<li>了解Spring组件JDBC Template</li>
<li>能使用JDBC Template进行持久化操作</li>
<li>帮助自己学习Hibernate、MyBatis等ORM框架</li>
</ul>
<h4 id="JDBC-Template概念"><a href="#JDBC-Template概念" class="headerlink" title="JDBC Template概念"></a>JDBC Template概念</h4><ul>
<li><p>为了简化持久化操作，Spring在JDBC API之上提供了JDBC Template组件，对JDBC API进行二次封装。</p>
<p><img src="http://cdn1.hikariblog.cn/JDBC.png" alt="JDBC"></p>
</li>
<li><p>JDBC Template提供统一的模板方法，在<span style="color:red">保留代码灵活性</span>的基础上，尽量减少持久化代码。（利用模板消除样板式编程）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//JDBC API</span></span><br><span class="line">Statement statement=conn.createStatement();</span><br><span class="line">ResultSet resultSet=statememt.executeQuery(<span class="string">"select count(*) COUNT from student"</span>);</span><br><span class="line"><span class="keyword">if</span>(resultSet.next())&#123;</span><br><span class="line">    Integer count=resultSet.getInt(<span class="string">"COUNT"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//JDBC Template</span></span><br><span class="line">Integer count=jt.queryForObject(<span class="string">"select count(*) from student"</span>,Integer<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h4><ul>
<li><p>Maven</p>
<ul>
<li><p>Mysql驱动</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.44<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Spring组件（<code>core</code> <code>beans</code> <code>context</code> <code>aop</code>）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 基于AspectJ的AOP环境 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>aopalliance<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aopalliance<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Spring四个核心包 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-beans --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-expression --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-expression<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 单元测试的两个包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>JDBC Template（jdbc、tx）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-tx --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Spring配置</p>
<ul>
<li><p>数据源（可以根据生产环境需要选择不同的开源数据源）</p>
</li>
<li><p>JDBC Template</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.sc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.DriverManagerDataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hogan_Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-07-20 17:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DriverManagerDataSource ds=<span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">        ds.setDriverClassName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        ds.setUsername(<span class="string">"root"</span>);</span><br><span class="line">        ds.setPassword(<span class="string">"mysql"</span>);</span><br><span class="line">        ds.setUrl(<span class="string">"jdbc:mysql://localhost:3306/customer?useUnicode=true&amp;amp;characterEncoding=utf-8"</span>);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcTemplate <span class="title">jdbcTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcTemplate(dataSource());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p>注意:url中的&amp;为特殊字符，需要写成<code>&amp;amp;</code>;</p>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><ul>
<li><p>execute方法</p>
<p>可以执行任何sql语句，实际应用中主要用来执行DDL语句。实际应用中用的不多。</p>
</li>
<li><p><span style="color:red">update与batchUpdate方法</span></p>
<p>对数据进行增删改操作（DML操作）。</p>
<ul>
<li><p>update方法:对数据进行增 <code>insert</code> 删 <code>delete</code> 改 <code>update</code> 操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回值:影响的数据行数</span></span><br><span class="line"><span class="comment">//Object[] args参数:对sql语句中的占位符进行填充</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(String sql,Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(String sql,Object... args)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>batchUpdate方法:批量增删改操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] batchUpdate(String[] sql)</span><br><span class="line"><span class="comment">//执行同构sql语句，每次执行的占位符不同</span></span><br><span class="line"><span class="keyword">int</span>[] batchUpdate(String sql,List&lt;Object[]&gt; args)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><span style="color:red">query与queryXXX方法</span></p>
<p>对数据进行查询</p>
<ul>
<li><p>查询简单数据项</p>
<ul>
<li><p>获取一个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">T <span class="title">queryForObject</span><span class="params">(String sql,Class&lt;T&gt; type)</span></span></span><br><span class="line"><span class="function">T <span class="title">queryForObject</span><span class="params">(String sql,Object[] args,Class&lt;T&gt; type)</span></span></span><br><span class="line"><span class="function">T <span class="title">queryForObject</span><span class="params">(String sql,Class&lt;T&gt; type,Object... arg)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取多个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;T&gt; <span class="title">queryForList</span><span class="params">(String sql,Class&lt;T&gt; type)</span></span></span><br><span class="line"><span class="function">List&lt;T&gt; <span class="title">queryForList</span><span class="params">(String sql,Object[] args,Class&lt;T&gt; type)</span></span></span><br><span class="line"><span class="function">List&lt;T&gt; <span class="title">queryForList</span><span class="params">(String sql,Class&lt;T&gt; type,Object... arg)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>查询复杂对象（封装为Map）</p>
<ul>
<li><p>获取一个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Map <span class="title">queryForMap</span><span class="params">(String sql)</span></span></span><br><span class="line"><span class="function">Map <span class="title">queryForMap</span><span class="params">(String sql,Object[] args)</span></span></span><br><span class="line"><span class="function">Map <span class="title">queryForMap</span><span class="params">(String sql,Object... arg)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取多个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Map&lt;String,Object&gt;&gt; queryForList(String sql)</span><br><span class="line">List&lt;Map&lt;String,Object&gt;&gt; queryForList(String sql,Object[] args)</span><br><span class="line">List&lt;Map&lt;String,Object&gt;&gt; queryForList(String sql,Object...arg)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>查询复杂对象（封装为实体对象）</p>
<ul>
<li>RowMapper接口</li>
<li>获取一个</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">T <span class="title">queryForObject</span><span class="params">(String sql,RowMapper&lt;T&gt; mapper)</span></span></span><br><span class="line"><span class="function">T <span class="title">queryForObject</span><span class="params">(String sql,Object[] args,RowMapper&lt;T&gt; mapper)</span></span></span><br><span class="line"><span class="function">T <span class="title">queryForObject</span><span class="params">(String sql,RowMapper&lt;T&gt; mapper,Object... arg)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>获取多个</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;T&gt; <span class="title">query</span><span class="params">(String sql,RowMapper&lt;T&gt; mapper)</span></span></span><br><span class="line"><span class="function">List&lt;T&gt; <span class="title">query</span><span class="params">(String sql,Object[] args,RowMapper&lt;T&gt; mapper)</span></span></span><br><span class="line"><span class="function">List&lt;T&gt; <span class="title">query</span><span class="params">(String sql,RowMapper&lt;T&gt; mapper,Object... arg)</span></span></span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li><p>call方法</p>
<p>调用存储过程</p>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.imooc.sc.User;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.RowMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hogan_Lee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-07-18 11:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ContextConfiguration</span>(<span class="title">locations</span> </span>= <span class="string">"classpath:applicationContext.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@org</span>.junit.Test</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">textExcute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        jdbcTemplate.execute(<span class="string">"create table user1(id int,name varchar(20))"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@org</span>.junit.Test</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">"update user1 set name='5' where id=?"</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@org</span>.junit.Test</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBatchUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String[] sqls = &#123;</span><br><span class="line">                <span class="string">"insert into user1(id,name) value(2,'7')"</span>,</span><br><span class="line">                <span class="string">"update user1 set name='9' where id=2"</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        jdbcTemplate.batchUpdate(sqls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@org</span>.junit.Test</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBatchUpdate1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">"insert into user1(id,name) value(?,?)"</span>;</span><br><span class="line">        List&lt;Object[]&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> Object[]&#123;<span class="number">7</span>, <span class="string">"8"</span>&#125;);</span><br><span class="line">        list.add(<span class="keyword">new</span> Object[]&#123;<span class="number">5</span>, <span class="string">"6"</span>&#125;);</span><br><span class="line">        jdbcTemplate.batchUpdate(sql, list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@org</span>.junit.Test</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQuerySimple1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">"select count(*) from user1"</span>;</span><br><span class="line">        <span class="keyword">int</span> count = jdbcTemplate.queryForObject(sql, Integer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@org</span>.junit.Test</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQuerySimple2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">"select name from user1 where id=1"</span>;</span><br><span class="line">        List&lt;String&gt; names = jdbcTemplate.queryForList(sql, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(names);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@org</span>.junit.Test</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryMap1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">"select * from user1 where id=?"</span>;</span><br><span class="line">        Map&lt;String, Object&gt; user7 = jdbcTemplate.queryForMap(sql, <span class="number">7</span>);</span><br><span class="line">        System.out.println(user7);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@org</span>.junit.Test</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryMap2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">"select * from user1 where id=?"</span>;</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; user1 = jdbcTemplate.queryForList(sql, <span class="number">1</span>);</span><br><span class="line">        System.out.println(user1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@org</span>.junit.Test</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryEntity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">"select * from user1 where id=?"</span>;</span><br><span class="line">        User user = jdbcTemplate.queryForObject(sql, <span class="keyword">new</span> UserRowMapper(), <span class="number">7</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@org</span>.junit.Test</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQuery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">"select * from user1 where id=?"</span>;</span><br><span class="line">        List&lt;User&gt; users = jdbcTemplate.query(sql, <span class="keyword">new</span> UserRowMapper(), <span class="number">1</span>);</span><br><span class="line">        System.out.println(users);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRowMapper</span> <span class="keyword">implements</span> <span class="title">RowMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> User <span class="title">mapRow</span><span class="params">(ResultSet resultSet, <span class="keyword">int</span> i)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">            User user = <span class="keyword">new</span> User();</span><br><span class="line">            user.setId(resultSet.getInt(<span class="string">"id"</span>));</span><br><span class="line">            user.setName(resultSet.getString(<span class="string">"name"</span>));</span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="JDBC-Template持久层示例"><a href="#JDBC-Template持久层示例" class="headerlink" title="JDBC Template持久层示例"></a>JDBC Template持久层示例</h4><ul>
<li>实体类entity：定义属性和对应的getter和setter方法</li>
<li>DAO：继承统一的接口，实现增删改查。实现对象的持久化<ul>
<li>注入JDBC Template</li>
<li>声明RowMapper，查询的时候映射为对象。</li>
</ul>
</li>
</ul>
<h4 id="优缺点介绍"><a href="#优缺点介绍" class="headerlink" title="优缺点介绍"></a>优缺点介绍</h4><ul>
<li>优点：<ul>
<li>简单</li>
<li>灵活</li>
</ul>
</li>
<li>缺点<ul>
<li>SQL与Java代码参杂</li>
<li>功能不丰富</li>
</ul>
</li>
</ul>
<p>所以实际应用当中还需要使用更加完善的ORM框架，如mybatis或者hibernate。</p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>框架</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>静态域和静态方法是否可以被继承?是否可以被重写?以及原因</title>
    <url>/2019/06/23/%E9%9D%99%E6%80%81%E5%9F%9F%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E7%BB%A7%E6%89%BF%EF%BC%9F%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E9%87%8D%E5%86%99%EF%BC%9F%E4%BB%A5%E5%8F%8A%E5%8E%9F%E5%9B%A0/</url>
    <content><![CDATA[<blockquote class="blockquote-center"><p><strong>“Talk is cheap.Show me the code”——Linus Torvalds</strong></p>
</blockquote>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SuperDemo.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a=<span class="number">5</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"父类中的静态方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//SonDemo.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SonDemo</span> <span class="keyword">extends</span> <span class="title">SuperDemo</span> </span>&#123; &#125;</span><br><span class="line"><span class="comment">//Run.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SonDemo.print();</span><br><span class="line">        System.out.println(<span class="string">""</span>+SonDemo.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://cdn1.hikariblog.cn/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C1.png" alt="运行结果"></p>
<p>可见，静态域和静态方法是可以被继承的。当然前提是非private的。</p>
<p>利用多态下的方法的动态绑定来说明static域和方法能否被重写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SuperDemo.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a=<span class="number">5</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"父类中的静态方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//SonDemo.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SonDemo</span> <span class="keyword">extends</span> <span class="title">SuperDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a=<span class="number">6</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子类中的静态方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Run.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SuperDemo one=<span class="keyword">new</span> SonDemo();</span><br><span class="line">        one.print();</span><br><span class="line">        System.out.println(<span class="string">""</span>+one.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>&emsp;&emsp;重写和隐藏的区别是：”重写”后子类的优先级要高于父类的优先级，但是“隐藏”是没有这个优先级之分的。</p>
<p>&emsp;&emsp;静态域、静态方法和非静态域都可以被继承和隐藏而不能被重写，因此不能实现多态，不能实现父类的引用可以指向子类的对象时的动态绑定。非静态方法可以被继承和重写，因此可以实现多态。</p>
<p>总结：</p>
<ul>
<li>静态域和静态方法可以被继承。</li>
<li>静态方法和静态域不可以被重写，不能实现多态。</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>a=a+b与a+=b有什么区别？</title>
    <url>/2019/06/23/a=a+b%E4%B8%8Ea+=b%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    <content><![CDATA[<p>从<span style="color:red">执行效率</span>和<span style="color:red">类型转换</span>两个方面来比较<code>a=a+b</code>和<code>a+=b</code>之间的区别</p>
<h4 id="执行效率"><a href="#执行效率" class="headerlink" title="执行效率"></a>执行效率</h4><p>&emsp;&emsp;不考虑编译器的优化的话，<code>a=a+b</code>的执行效率是低于<code>a+=b</code>的，因为它多进行了一步中间变量的操作，而且会多占用一个变量的空间。而Java编译器默认对其进行了优化，优化之后两条语句都当做<code>a+=b</code>来执行了，所以实际上是没有任何区别的。</p>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>我们通过一个例子来说明两者的区别</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TestDemo.java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">float</span> b=<span class="number">6</span>;</span><br><span class="line">        a+=b;</span><br><span class="line">        <span class="comment">//a=a+b;</span></span><br><span class="line">        a= (<span class="keyword">int</span>) (a+b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在执行<code>a=a+b</code>时，当使用a和b两个数值进行二元操作时（例如上面的<code>a+b</code>，a是整数，b是浮点数），先要将两个操作数转换成同一种类型，然后再进行运算。数值类型之间的合法转换如图所示，可见a会被转换成<code>float</code>类型。</p>
<p><img src="http://cdn1.hikariblog.cn/%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%90%88%E6%B3%95%E8%BD%AC%E6%8D%A2.png" alt=""></p>
<p>&emsp;&emsp;此时，再将<code>a+b</code>的运算结果赋值给a，明显是非法的、编译器会报错。在<code>Java</code>中，允许进行这种数值之间的类型转换。当然，有可能会丢失一些信息。在这种情况下，需要通过强制类型转换（cast）实现这个操作。强制类型转换的语法格式是在圆括号中给出想要转换的目标类型，后面紧跟待转换的变量名。所以我们对<code>(a+b)</code>进行强制类型装换操作。但是为什么<code>a+=b</code>没有报错呢？我们对TestDemo.class进行<span style="color:blue">反编译</span>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TestDemo.java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">float</span> b = <span class="number">6.0F</span>;</span><br><span class="line">        <span class="keyword">int</span> a = (<span class="keyword">int</span>)((<span class="keyword">float</span>)a + b);</span><br><span class="line">        <span class="keyword">int</span> a = (<span class="keyword">int</span>)((<span class="keyword">float</span>)a + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>明显可以看出，<code>a=(int)(a+b)</code>等同于<code>a+=b</code>，它们编译后的结果是一样的。编译器在编译时会默认为<code>a+=b</code>进行强制类型转换。</p>
<p><span style="color:red">总结：<code>a=a+b</code>和<code>a+=b</code>的区别主要体现在<code>a=a+b</code>需要进行强制类型转换的时候。其它情况下基本是没有差别的。</span></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>常见的HTTP状态码和原因短语</title>
    <url>/2019/06/21/%E5%B8%B8%E8%A7%81%E7%9A%84HTTP%E7%8A%B6%E6%80%81%E7%A0%81%E5%92%8C%E5%8E%9F%E5%9B%A0%E7%9F%AD%E8%AF%AD/</url>
    <content><![CDATA[<p>&emsp;&emsp;谈到HTTP状态码，可能很多人会想起让自己抓狂的404页面。没错404也是一个状态码，当你请求服务器上不存在的资源的，404错误页面就会出现。当然，除了404以外还有其它的状态码。</p>
<p>&emsp;&emsp;实际上，请求过程中会有很多状态码快速的发生着变化，且看不出这些状态码是如何变化的，除非像打断点似的操作一步停一下，因此导致在服务器响应过程中，很多状态码我们是看不到的。下面介绍一下如何查看当前页面的状态码。</p>
<ol>
<li><p>打开要查看的页面，按F12；然后点击network（或网络），再点击Doc。</p>
<p><img src="http://cdn1.hikariblog.cn/%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7.jpg" alt="开发者工具"></p>
</li>
<li><p>按F5刷新，就可以看到“Status”一栏下的页面返回状态码了。</p>
<p><img src="http://cdn1.hikariblog.cn/%E7%8A%B6%E6%80%81%E7%A0%81%E6%9F%A5%E7%9C%8B.jpg" alt="状态码查看"></p>
</li>
</ol>
<p>&emsp;&emsp;HTTP状态码负责表示客户端HTTP请求的返回结果、标记服务器端的处理是否正常、通知出现的错误等工作。状态码的数量多达60余种，下面我们了解一下常见的14种。首先我们对状态码进行简单的分类：</p>
<table>
<thead>
<tr>
<th></th>
<th>类别</th>
<th>原因短语</th>
</tr>
</thead>
<tbody><tr>
<td>1XX</td>
<td>Informational（信息性状态码）</td>
<td>接收的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>Success（成功状态码）</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection（重定向状态码）</td>
<td>需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error（客户端错误状态码）</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error（服务器错误状态码）</td>
<td>服务器处理请求出错</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;下面分别对每一类状态信息进行总结：</p>
<h2 id="1xx-信息"><a href="#1xx-信息" class="headerlink" title="1xx: 信息"></a>1xx: 信息</h2><table>
<thead>
<tr>
<th align="left">消息:</th>
<th align="left">描述:</th>
</tr>
</thead>
<tbody><tr>
<td align="left">100 Continue</td>
<td align="left">服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。</td>
</tr>
<tr>
<td align="left">101 Switching Protocols</td>
<td align="left">服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。</td>
</tr>
</tbody></table>
<h2 id="2xx-成功"><a href="#2xx-成功" class="headerlink" title="2xx: 成功"></a>2xx: 成功</h2><table>
<thead>
<tr>
<th align="left">消息:</th>
<th align="left">描述:</th>
</tr>
</thead>
<tbody><tr>
<td align="left">200 OK</td>
<td align="left">请求成功（其后是对GET和POST请求的应答文档。）</td>
</tr>
<tr>
<td align="left">201 Created</td>
<td align="left">请求被创建完成，同时新的资源被创建。</td>
</tr>
<tr>
<td align="left">202 Accepted</td>
<td align="left">供处理的请求已被接受，但是处理未完成。</td>
</tr>
<tr>
<td align="left">203 Non-authoritative Information</td>
<td align="left">文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝。</td>
</tr>
<tr>
<td align="left">204 No Content</td>
<td align="left">没有新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。</td>
</tr>
<tr>
<td align="left">205 Reset Content</td>
<td align="left">没有新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。</td>
</tr>
<tr>
<td align="left">206 Partial Content</td>
<td align="left">客户发送了一个带有Range头的GET请求，服务器完成了它。</td>
</tr>
</tbody></table>
<h2 id="3xx-重定向"><a href="#3xx-重定向" class="headerlink" title="3xx: 重定向"></a>3xx: 重定向</h2><table>
<thead>
<tr>
<th align="left">消息:</th>
<th align="left">描述:</th>
</tr>
</thead>
<tbody><tr>
<td align="left">300 Multiple Choices</td>
<td align="left">多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。</td>
</tr>
<tr>
<td align="left">301 Moved Permanently</td>
<td align="left">所请求的页面已经转移至新的url。</td>
</tr>
<tr>
<td align="left">302 Found</td>
<td align="left">所请求的页面已经临时转移至新的url。</td>
</tr>
<tr>
<td align="left">303 See Other</td>
<td align="left">所请求的页面可在别的url下被找到。</td>
</tr>
<tr>
<td align="left">304 Not Modified</td>
<td align="left">未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。</td>
</tr>
<tr>
<td align="left">305 Use Proxy</td>
<td align="left">客户请求的文档应该通过Location头所指明的代理服务器提取。</td>
</tr>
<tr>
<td align="left">306 <em>Unused</em></td>
<td align="left">此代码被用于前一版本。目前已不再使用，但是代码依然被保留。</td>
</tr>
<tr>
<td align="left">307 Temporary Redirect</td>
<td align="left">被请求的页面已经临时移至新的url。</td>
</tr>
</tbody></table>
<h2 id="4xx-客户端错误"><a href="#4xx-客户端错误" class="headerlink" title="4xx: 客户端错误"></a>4xx: 客户端错误</h2><table>
<thead>
<tr>
<th align="left">消息:</th>
<th align="left">描述:</th>
</tr>
</thead>
<tbody><tr>
<td align="left">400 Bad Request</td>
<td align="left">服务器未能理解请求。</td>
</tr>
<tr>
<td align="left">401 Unauthorized</td>
<td align="left">被请求的页面需要用户名和密码。</td>
</tr>
<tr>
<td align="left">402 Payment Required</td>
<td align="left">此代码尚无法使用。</td>
</tr>
<tr>
<td align="left">403 Forbidden</td>
<td align="left">对被请求页面的访问被禁止。</td>
</tr>
<tr>
<td align="left">404 Not Found</td>
<td align="left">服务器无法找到被请求的页面。</td>
</tr>
<tr>
<td align="left">405 Method Not Allowed</td>
<td align="left">请求中指定的方法不被允许。</td>
</tr>
<tr>
<td align="left">406 Not Acceptable</td>
<td align="left">服务器生成的响应无法被客户端所接受。</td>
</tr>
<tr>
<td align="left">407 Proxy Authentication Required</td>
<td align="left">用户必须首先使用代理服务器进行验证，这样请求才会被处理。</td>
</tr>
<tr>
<td align="left">408 Request Timeout</td>
<td align="left">请求超出了服务器的等待时间。</td>
</tr>
<tr>
<td align="left">409 Conflict</td>
<td align="left">由于冲突，请求无法被完成。</td>
</tr>
<tr>
<td align="left">410 Gone</td>
<td align="left">被请求的页面不可用。</td>
</tr>
<tr>
<td align="left">411 Length Required</td>
<td align="left">“Content-Length” 未被定义。如果无此内容，服务器不会接受请求。</td>
</tr>
<tr>
<td align="left">412 Precondition Failed</td>
<td align="left">请求中的前提条件被服务器评估为失败。</td>
</tr>
<tr>
<td align="left">413 Request Entity Too Large</td>
<td align="left">由于所请求的实体的太大，服务器不会接受请求。</td>
</tr>
<tr>
<td align="left">414 Request-url Too Long</td>
<td align="left">由于url太长，服务器不会接受请求。当post请求被转换为带有很长的查询信息的get请求时，就会发生这种情况。</td>
</tr>
<tr>
<td align="left">415 Unsupported Media Type</td>
<td align="left">由于媒介类型不被支持，服务器不会接受请求。</td>
</tr>
<tr>
<td align="left">416</td>
<td align="left">服务器不能满足客户在请求中指定的Range头。</td>
</tr>
<tr>
<td align="left">417 Expectation Failed</td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="5xx-服务器错误"><a href="#5xx-服务器错误" class="headerlink" title="5xx: 服务器错误"></a>5xx: 服务器错误</h2><table>
<thead>
<tr>
<th align="left">消息:</th>
<th align="left">描述:</th>
</tr>
</thead>
<tbody><tr>
<td align="left">500 Internal Server Error</td>
<td align="left">请求未完成。服务器遇到不可预知的情况。</td>
</tr>
<tr>
<td align="left">501 Not Implemented</td>
<td align="left">请求未完成。服务器不支持所请求的功能。</td>
</tr>
<tr>
<td align="left">502 Bad Gateway</td>
<td align="left">请求未完成。服务器从上游服务器收到一个无效的响应。</td>
</tr>
<tr>
<td align="left">503 Service Unavailable</td>
<td align="left">请求未完成。服务器临时过载或当机。</td>
</tr>
<tr>
<td align="left">504 Gateway Timeout</td>
<td align="left">网关超时。</td>
</tr>
<tr>
<td align="left">505 HTTP Version Not Supported</td>
<td align="left">服务器不支持请求中指明的HTTP协议版本。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>反射</title>
    <url>/2019/06/16/%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><p>下面的官方文档对Class类的说明</p>
<p><img src="http://cdn1.hikariblog.cn/%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3-Class%E7%B1%BB%E7%9A%84%E8%AF%B4%E6%98%8E.png" alt="官方文档-Class类的说明"></p>
<ol>
<li><p>在面向对象的世界里，万事万物皆对象。八种基本类型不是对象，但是Java为他们提供了相对应的包装类。<span style="color:red">类也是对象</span>，是<code>java.lang.Class</code>的实例对象。<span style="color:blue">官网将<code>java.lang.Class</code>的实例对象称为其对应类的类类型。</span><code>java.lang.Class</code>类的构造器是私有，不能通过<code>new</code>关键字创建该类的实例对象，只能由虚拟机进行创建。下面为<code>java.lang.Class</code>类的构造器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Private constructor. Only the Java Virtual Machine creates Class objects.</span></span><br><span class="line"><span class="comment"> * This constructor is not used and prevents the default constructor being</span></span><br><span class="line"><span class="comment"> * generated.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Class</span><span class="params">(ClassLoader loader)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Initialize final field for classLoader.  The initialization value of non-null</span></span><br><span class="line">    <span class="comment">// prevents future JIT optimizations from assuming this final field is null.</span></span><br><span class="line">    classLoader = loader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那我们应该怎么去获得<code>java.lang.Class</code>类的实例对象呢？假设现在有一个自定义类<code>Demo</code>，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>和以往一样，<code>Demo</code>类的实例对象的表示为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Demo demo=<span class="keyword">new</span> Demo()；</span><br></pre></td></tr></table></figure>

<p><span style="color:red">而<code>java.lang.Class</code>类的实例对象<code>Demo</code>有以下三种表示方式：</span></p>
<p>我们需要注意的是一个类只能是Class的一个实例变量，无论哪种方式获得都是指向同一实例变量的引用，它们是相等的。</p>
<ul>
<li><p>第一种表示方式，则任何一个类都有一个隐含的静态成员变量<code>class</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class c1=Demo<span class="class">.<span class="keyword">class</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二种表达方式，使用Demo类的对象通过<code>getClass()</code>获得</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class c2=demo.getClass();</span><br></pre></td></tr></table></figure>
</li>
<li><p>第三种表达方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class c3=<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	c3=Class.forName(<span class="string">"Demo"</span>);<span class="comment">//如果有包还要加上包名</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">	<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Class.forName(&quot;类的全称&quot;)</code></p>
<ul>
<li>不仅表示了类的类类型，还代表了动态加载类。</li>
<li>请大家区分编译、运行</li>
<li>编译时刻加载类是静态加载类、运行时刻加载类是动态加载类。</li>
</ul>
<p><strong>下面有一个例子，来说明动态加载类。</strong></p>
<ul>
<li>静态加载类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Office</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//new创建对象是静态加载类，在编译时刻就需要加载所有的可能使用到的类</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="string">"Word"</span>.equals(args))&#123;</span><br><span class="line">			Word w=<span class="keyword">new</span> Word();</span><br><span class="line">			w.start();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="string">"Excel"</span>.equals(args))&#123;</span><br><span class="line">			Excel e=<span class="keyword">new</span> Excel();</span><br><span class="line">			e.start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Word</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"worrd start..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显，<code>Excel</code>类都不存在，故编译无法通过。</p>
<ul>
<li>动态加载类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Office</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="string">"Word"</span>.equals(args))&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Class s=Class.forName(<span class="string">"Word"</span>);</span><br><span class="line">				Word d=<span class="keyword">null</span>;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					d = (Word)s.newInstance();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">					<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">					<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				d.start();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="string">"Excel"</span>.equals(args))&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Class s=Class.forName(<span class="string">"Excel"</span>);</span><br><span class="line">				Excel e=<span class="keyword">null</span>;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					e = (Excel)s.newInstance();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">					<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">					<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				e.start();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Word</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"worrd start..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样子即使<code>Excel</code>类不存在也可以编译，很明显，上面有重复性的代码，可以给<code>Word</code>和<code>Excel</code>定义一个统一标准的接口进行优化。这里不做过多描述。<span style="color:red">功能性的类尽量使用动态加载！！！</span></p>
</li>
</ul>
<p><span style="color:blue">我们完全可以通过类的类类型创建该类的对象实例（前提必须有无参数的构造器），如通过c1、c2、c3创建Demo的实例。</span>通过<code>newInstance</code>方法获得的对象是Object类型的，需向下转型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	Demo demo1=(Demo)c3.newInstance();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">	<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">	<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="获取方法的信息"><a href="#获取方法的信息" class="headerlink" title="获取方法的信息"></a>获取方法的信息</h2><p>基本数据类型有没有对应的类类型呢？答案是有的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class c1=<span class="keyword">int</span><span class="class">.<span class="keyword">class</span></span>;<span class="comment">//int数据类型的类类型</span></span><br><span class="line">Class c2=<span class="keyword">double</span><span class="class">.<span class="keyword">class</span></span>;<span class="comment">//double数据类型的类类型</span></span><br><span class="line">Class c3=<span class="keyword">void</span><span class="class">.<span class="keyword">class</span></span>;<span class="comment">//void关键字的类类型</span></span><br></pre></td></tr></table></figure>

<h6 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.带包名的类名称</span><br><span class="line">getName()</span><br><span class="line">2.不带包名的类名称</span><br><span class="line">getSimpleName()</span><br></pre></td></tr></table></figure>

<h6 id="获取方法的信息-1"><a href="#获取方法的信息-1" class="headerlink" title="获取方法的信息"></a>获取方法的信息</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//要获取类的信息，首先要获取类的类类型</span></span><br><span class="line">Class c=obj.getClass();<span class="comment">//传递的是哪个子类的对象，就是该子类的类类型。</span></span><br><span class="line"><span class="comment">//获取类的名称</span></span><br><span class="line">System.out.println(<span class="string">"类的名称是:"</span>+c.getName());</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 方法也是对象，是Method类的实例对象</span></span><br><span class="line"><span class="comment"> * 一个成员方法就是一个Method对象</span></span><br><span class="line"><span class="comment"> * getMethods()方法获取的是所有的public的函数，包括父类继承而来的</span></span><br><span class="line"><span class="comment"> * getDeclaredMethods()获取的是所有该类自己声明的方法，不问访问权限</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Method[] ms=c.getMethods();</span><br><span class="line">c.getDeclaredMethods();</span><br><span class="line"><span class="keyword">for</span>(Method m:ms)&#123;</span><br><span class="line">	<span class="comment">//得到方法的返回值的类类型</span></span><br><span class="line">	Class returnType=m.getReturnType();</span><br><span class="line">	System.out.println(returnType.getName());</span><br><span class="line">	<span class="comment">//得到方法的名称</span></span><br><span class="line">	System.out.println(m.getName());</span><br><span class="line">	<span class="comment">//获取参数类型</span></span><br><span class="line">	Class[] paramTypes=m.getParameterTypes();</span><br><span class="line">	<span class="keyword">for</span>(Class class1:paramTypes)&#123;</span><br><span class="line">		System.out.println(class1.getName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>成员变量的反射</p>
<p>构造函数的反射</p>
<p>Java类加载机制</p>
<p>反射相关面试题</p>
<ul>
<li>反射的原理，反射创建类实例的三种方式是什么。</li>
<li>说说你对Java反射的理解</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>守护线程</title>
    <url>/2019/06/16/%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>在Java线程中有两种线程，一种是<span style="color:red">用户线程</span>，另外一种就是<span style="color:blue">守护（Deamon）线程</span>。默认我们创建的线程都是用户线程。</p>
<h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;概念：守护线程是一种特殊的线程，它的特性有陪伴的含义，当进程中不存在用户线程时，则守护线程会自动销毁。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;典型的守护线程就是垃圾回收线程GC，当进程中没有用户线程，则垃圾回收线程GC也没有存在的必要了，自动销毁。</p>
<p>使用守护线程需要注意什么？</p>
<ol>
<li><p>既然默认我们创建的线程都是用户线程，那我们要怎么创建守护线程呢？或者说应该如何把用户线程装换为守护线程？如下代码，调用<code>java.lang.Thread</code>提供的实例方法<code>setDaemon(true)</code>进行用户线程和守护线程的切换，<span style="color:red">这一方法必须在线程启动前进行调用</span>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">	Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">   </span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">			System.out.println(<span class="string">"启动线程"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">   </span><br><span class="line">	&#125;);</span><br><span class="line">	thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>在Daemon线程中产生的新线程也是Daemon的。</p>
</li>
<li><p>守护线程不能用于去访问固有资源，比如读写操作或者计算逻辑。因为它会在任何时候甚至在一个操作的中间发生中断。</p>
</li>
<li><p>Java自带的多线程框架，比如ExecutorService，会将守护线程转换为用户线程，所以如果要使用后台线程就不能用Java的线程池。</p>
</li>
</ol>
<p>应用场景：</p>
<p>如GC等后台线程</p>
<p>相关面试题目：</p>
<ul>
<li>什么是Daemon线程？它有什么意义？</li>
<li>在java中守护线程和本地线程区别？</li>
</ul>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>进程、线程和协程</title>
    <url>/2019/06/15/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B/</url>
    <content><![CDATA[<p>相关面试题：</p>
<h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><h4 id="进程和线程的由来"><a href="#进程和线程的由来" class="headerlink" title="进程和线程的由来"></a>进程和线程的由来</h4><img  src=http://www.plantuml.com/plantuml/svg/ux9wicFJYuKzJvUqF9_GPit5PVMiSoU2ysB_xEShka6ivxlsWra0>

<ul>
<li>初期的计算机智能串行执行任务，并且需要长时间等待用户输入。</li>
<li>预先将用户的指令集中成清单，批量串行处理用户指令，仍然无法并发执行。</li>
<li>进程独占内存空间，保存各自的运行状态，相互间不干扰且可以互相切换，为并发处理任务提供了可能。</li>
<li>共享进程的内存资源，相互间切换更快速，支持更细粒度的任务控制，使进程内的子任务得以并发执行。</li>
</ul>
<h4 id="进程和线程的区别-1"><a href="#进程和线程的区别-1" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h4><p><strong>进程是系统资源分配和调度的最小单位，线程是CPU调度的最小单位。</strong></p>
<ol>
<li>线程不能看做独立的应用，而进程可看做独立应用。</li>
<li>进程有独立的地址空间，相互不影响（其中一个进程挂了不影响程序），线程只是进程的不同执行路径（其中一个线程挂了，所在进程也就挂了），线程共享进程的内存空间。</li>
<li>线程没有独立的地址空间，多进程的程序比多线程程序健壮。</li>
<li>进程的切换比线程的切换开销大。效率低。</li>
<li>进程是代码+数据集合，是代码在数据集合上的运行活动。</li>
<li>进程是运行中的程序，而线程则是进程中的一个执行路径。</li>
</ol>
<h4 id="Java进程和线程的关系"><a href="#Java进程和线程的关系" class="headerlink" title="Java进程和线程的关系"></a>Java进程和线程的关系</h4><p><img src="http://cdn1.hikariblog.cn/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%88%92%E5%88%86.jpg" alt="进程和线程的内存结构划分"></p>
<p>如上图所示，Thread1到ThreadN这N个线程共享进程的堆和方法区资源，但是每个线程有自己的程序计数器（PC）和栈（stack）区域。</p>
<ul>
<li><p>其中PC计数器本质上是一块内存区域，用来记录线程当前要执行的指令地址，CPU一般是使用时间片轮转方式让线程轮询占用的，因此当前线程CPU时间片用完后，要让出CPU，这时PC计数器就会记录下当前线程下次要执行的命令的地址，等到下次轮到该线程占有CPU执行时，就从PC计数器获取自己将要执行的命令的地址继续执行。</p>
</li>
<li><p>每个线程有自己的栈资源，用于存储该线程的局部变量，这些局部变量时该线程私有的，其它线程是访问不了的。另外，栈还用来存放线程的调用栈帧，如下代码，当我们调动test()方法时，就会把当前方法的一些信息封装为栈帧压入到栈顶，栈顶的栈帧就是活跃的test方法。当执行到say()方法时就会在栈顶新加一个关于say()方法的栈帧，这时候say()方法所在的栈帧就是活跃栈帧。当say()方法执行完毕后，say()方法所在栈顶帧就会出栈，这时候栈顶活跃帧就是test方法的了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">6</span>;</span><br><span class="line">    say();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>堆（heap）是一个进程中最大的一块内存，是进程创建时候创建的，堆是被进程中的所有线程共享的。堆里面主要存放使用<span style="color:blue">new 操作创建的对象实例和基本类型的成员变量</span>，如下操作就是在堆上创建了一个 ArrayList 对象，这里需要注意的是，<span style="color:red">指向堆对象的 list 变量本身是在线程的栈上保存的</span>，只是 list 指向了堆上的 ArrayList 的地址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void test(int x,int y) &#123;</span><br><span class="line">    List&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法区（method area）用来存放 JVM 加载的类信息、常量、静态变量等信息，也是线程共享的。</p>
</li>
</ul>
<ol>
<li>Java对操作系统提供的功能进行封装，包括进程和线程。</li>
<li>运行一个程序会产生一个进程，进程至少包括一个线程；线程必须依托进程而存在，线程本身是不会独立存在的。</li>
<li>每个进程对应一个JVM实例，多个进程共享JVM里的堆。</li>
<li>Java采用单线程编程模型，程序会自动创建主线程。</li>
<li>主线程可以创建子线程，原则上要后于子线程完成执行。</li>
</ol>
<h2 id="说说进程，线程，协程之间的区别"><a href="#说说进程，线程，协程之间的区别" class="headerlink" title="说说进程，线程，协程之间的区别"></a>说说进程，线程，协程之间的区别</h2><h2 id="为什么要有线程，而不是仅仅用进程？"><a href="#为什么要有线程，而不是仅仅用进程？" class="headerlink" title="为什么要有线程，而不是仅仅用进程？"></a>为什么要有线程，而不是仅仅用进程？</h2>]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Cookie和Session</title>
    <url>/2019/06/14/Cookie%E5%92%8CSession/</url>
    <content><![CDATA[<p><code>HTTP</code>是无状态协议，它不对之前发生过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理。但是很多情况下，我们需要保持访问用户与后端服务器的交互状态，如购物网站需要保持用户的登录状态。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>计算机网络</tag>
        <tag>Java Web</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JSP静态包含和动态包含的区别</title>
    <url>/2019/06/14/JSP%E9%9D%99%E6%80%81%E5%8C%85%E5%90%AB%E5%92%8C%E5%8A%A8%E6%80%81%E5%8C%85%E5%90%AB%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>&emsp;&emsp;<code>JSP</code>静态包含和动态包含作用都是为了在<code>JSP</code>页面内某处整体嵌入一个文件，从而实现代码的复用；如多个<code>JSP</code>页面共享同一个导航栏文件。下面我们来看看这两种方式有什么具体的区别？</p>
<ul>
<li>实现形式</li>
</ul>
<p>&emsp;&emsp;静态包含使用<code>include</code>指令标记，如下：</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ include file=<span class="string">"文件的URL"</span> %&gt;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;动态包含采用<code>include</code>动作标记，如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;jsp:include page=<span class="string">"文件的URL"</span>/&gt;</span><br><span class="line">或</span><br><span class="line">&lt;jsp:include page=<span class="string">"文件的URL"</span>&gt;</span><br><span class="line">    param子标记</span><br><span class="line">&lt;/jsp:include&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>生成字节码文件</li>
</ul>
<p>&emsp;&emsp;静态包含是将两个文件合二为一，然后生成一个<code>Servlet</code>和对应的字节码文件。</p>
<p>&emsp;&emsp;动态包含是两个页面<span style="color:red">各自</span>生成自己的<code>Servlet</code>和对应的字节码文件。</p>
<ul>
<li>传参</li>
</ul>
<p>&emsp;&emsp;动态包含可以借助<code>param</code>动作标记作为子标记进行传参。而静态包含不可以。如下：</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;!-- myfile/target.jsp --&gt;</span><br><span class="line">String sideA=request.getParameter(<span class="string">"sideA"</span>);</span><br><span class="line">String sideB=request.getParameter(<span class="string">"sideB"</span>);</span><br></pre></td></tr></table></figure>

<p>将<code>myfile/target.jsp</code>文件动态包含到<code>JSP</code>页面，并传入参数<code>sideA</code>和<code>sideB</code>。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;jsp:include page=<span class="string">"myfile/target.jsp"</span>&gt;</span><br><span class="line">    &lt;jsp:param name=<span class="string">"sideA"</span> value=<span class="string">"12"</span>/&gt;</span><br><span class="line">    &lt;jsp:param name=<span class="string">"sideB"</span> value=<span class="string">"15"</span>/&gt;</span><br><span class="line">&lt;/jsp:include&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>发生时间</li>
</ul>
<p>&emsp;&emsp;静态包含发生在<code>JSP</code>——&gt;<code>Servlet</code>期间。</p>
<p>&emsp;&emsp;动态包含发生在执行<code>class</code>文件期间，执行到<code>include</code>动作指令时才加载包含的文件。</p>
<p>需要注意的：</p>
<ul>
<li>静态包含和动态包含的内置对象<code>request</code>是一样使用的，不会有所差别。</li>
<li>静态包含的两个页面的<code>&lt;%@ page contentType=&quot;text/html;charset=gb2312&quot;%&gt;</code>应保持一致。</li>
</ul>
<p>&emsp;&emsp;静态包含（include指令标记）是在编译阶段就处理所需要的文件，被处理的文件在逻辑和语法上依赖于当前的JSP页面，其优点是页面的执行速度快；而动态包含（include动作标记）是在JSP页面运行时才处理文件，被处理的文件在逻辑和语法上独立于当前JSP页面，其优点是可以使用param子标记更灵活地处理所需要的文件。</p>
]]></content>
      <categories>
        <category>JSP</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Java</tag>
        <tag>JSP</tag>
      </tags>
  </entry>
  <entry>
    <title>数组</title>
    <url>/2019/06/14/%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>&emsp;&emsp;数组是一种数据结构，它将数据码成一排进行存放。在<code>Java</code>中，数组中的元素必须是相同数据类型的，而对于一些弱类型的语言，数组可以存放不同数据类型的数据，如<code>JavaScript</code>。</p>
<p>&emsp;&emsp;数组采用以0开始的索引标识数组中的每一个元素。即在一个存放<code>n</code>个元素的数组中，第一个元素的索引为<code>0</code>，第n个元素的索引为<code>n-1</code>；我们可以通过整型下标索引随机访问数组中的值。例如，如果<code>array</code>是一个数组，<code>array[i]</code>就是数组中索引为<code>i</code>的元素。</p>
<ul>
<li>优点：连续的内存，通过下标可以快速寻址；即可通过一个整型下标随机访问数组中的值。</li>
</ul>
<ul>
<li>缺点：插入/删除节点困难，如果节点处于中间位置，在插入之前或删除之后需要移动后面的节点。</li>
</ul>
<hr>
<h3 id="Java中的数组"><a href="#Java中的数组" class="headerlink" title="Java中的数组"></a>Java中的数组</h3><h6 id="数组变量的声明"><a href="#数组变量的声明" class="headerlink" title="数组变量的声明"></a>数组变量的<span style="color:red">声明</span></h6><p><code>Java</code>提供了两种数组变量的声明方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*1.数据元素类型 数组变量的名字[]；*/</span></span><br><span class="line"><span class="keyword">int</span> a[];</span><br><span class="line"><span class="comment">/*2.数据元素类型[] 数组变量的名字；*/</span></span><br><span class="line"><span class="keyword">int</span>[] a;</span><br></pre></td></tr></table></figure>

<h6 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的<span style="color:red">初始化</span></h6><p>&emsp;&emsp;数组变量的声明只声明了数组变量，并没有将数组变量初始化为一个真正的数组。所以需要对数组变量进行初始化操作，<code>Java</code>提供了几种初始化数组的方式：</p>
<ol>
<li><span style="color:blue">默认初始值的初始化</span></li>
</ol>
<p>&emsp;&emsp;在<code>Java</code>除了八种数据类型不是对象，万物皆对象。故数组也是对象，可以通过<code>new</code>关键字初始化数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组变量的声明和初始化操作分开执行</span></span><br><span class="line"><span class="keyword">int</span>[] array; or <span class="keyword">int</span> array[];</span><br><span class="line">array=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//数组变量的声明和初始化操作一起执行</span></span><br><span class="line"><span class="keyword">int</span>[] array=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; or <span class="keyword">int</span> array[]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在<code>Java</code>中，不像<code>C</code>语言一样要求数组长度为常量：<code>new int[n]</code>会创建一个长度为<code>n</code>的数组,第一个元素的索引为<code>0</code>，第n个元素的索引为<code>n-1</code>；一旦创建了数组就不可以更改数组的大小。</p>
<p><span style="color:red">警告：如果创建了一个100个元素的数组，并且视图访问元素a[100]（或任何在0~99之外的下标），程序就会引发”array index out of bounds”非受查异常而终止执行。</span></p>
<p>&emsp;&emsp;初始化数组（无论在类中还是在方法中初始化）之后，数组中所有元素都会默认初始化为对应数据类型变量作为成员变量时的初始值。故初始化后的数组长度<code>a.length</code>就等于声明长度，例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*创建一个包含五个int类型元素的数组，每个元素的值都为0*/</span></span><br><span class="line"><span class="keyword">int</span>[] a=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p><code>Java</code>数据类型和对应初始值如下：</p>
<p>基本数据类型</p>
<ul>
<li>数值类型<ul>
<li>整型：包括<code>byte</code>，<code>int</code>，<code>short</code>初始值为0；<code>long</code>初始值为<code>0L</code>。</li>
<li>浮点型：<code>float</code>初始值为<code>0.0f</code>；<code>double</code>初始值为<code>0.0d</code>。</li>
</ul>
</li>
<li>字符类型：<code>char</code>初始值为<code>&#39;\u0000&#39;</code>。</li>
<li>布尔类型：<code>boolean</code>初始值为<code>false</code>；</li>
</ul>
<p>引用类型</p>
<ul>
<li>默认初始值为<code>null</code>。</li>
</ul>
<ol start="2">
<li><span style="color:blue">赋予初始值的初始化</span></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] array=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>





<p>下面是草稿</p>
<hr>
<p>索引可以有语义，也可以没有语义。比如索引和学生的学号一一对应。</p>
<p>数组最大的优点：快速查询。score[2];</p>
<p>数组最好应用于“索引有语义”的情况。</p>
<p>但并非所有有语义的索引都适用于数组。如身份证号码</p>
<p><span style="color:red">本章主要处理“索引没有语义”的情况数组的使用。</span></p>
<p><img src="http://cdn1.hikariblog.cn/%E7%B4%A2%E5%BC%95%E6%97%A0%E8%AF%AD%E4%B9%89%E6%95%B0%E7%BB%84.png" alt="索引无语义数组"></p>
<p>&emsp;&emsp;如果索引没有语义，那么数组就是一个暂存数据的空间。此时我们应该如何去表示还没有存放数据的元素呢，因为数组的大小是从一开始就指定的，所以有一些空间在实际应用上是还没有存放数据的，但是它们可以被访问，从用户的角度看来，它们是非法的。</p>
<p>如何添加元素？如何删除元素？数组越界？</p>
<p>Java提供的数组没有提供这种实际应用的功能的？</p>
<p><strong>自定义数组</strong></p>
<p><img src="http://cdn1.hikariblog.cn/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E7%BB%84.png" alt="自定义数组"></p>
<p>自定义数组里面的封装的成员变量，需要维护</p>
<p>数组data，实际存放元素个数size，数组的大小capacity(可以直接使用data.length获得，没必要声明)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] data;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure>

<p> 构造函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Array</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">	data=<span class="keyword">new</span> <span class="keyword">int</span>[capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义数组:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//注意：泛型T不可以是基本数据类型，只能是类对象</span></span><br><span class="line">    <span class="comment">//数据结构与数据库的区别，数据结构是在内存中处理的</span></span><br><span class="line">    <span class="comment">//自定义数组类——CURD操作</span></span><br><span class="line">    <span class="keyword">private</span> T[] data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数传入数组的容量capacity构造Array</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> capacity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Array</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//注意：因为历史遗留问题，Java不支持泛型数组。所以得绕一个弯进行泛型数组的创建</span></span><br><span class="line">        data = (T[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无参数的构造函数</span></span><br><span class="line"><span class="comment">     * 默认数组的容量capacity=10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Array</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询数组中的元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取数组的容量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回数组是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在所有元素前添加一个新元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addfirst</span><span class="params">(T e)</span> </span>&#123;</span><br><span class="line">        add(<span class="number">0</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在所有元素后添加一个新元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(T e)</span> </span>&#123;</span><br><span class="line">        add(size, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进行数组空间的扩容</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">        T[] newData = (T[]) <span class="keyword">new</span> Object[newCapacity];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            newData[i] = data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        data = newData;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在第index个位置插入一个新元素e,注意这里的index是数组的下标，而不是第几个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, T e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断用户传进来的索引是否合法</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Add failed.Require index&gt;=0 and index&lt;=size."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行数组空间的扩容</span></span><br><span class="line">        <span class="keyword">if</span> (size == data.length) &#123;</span><br><span class="line">            resize(<span class="number">2</span> * data.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将索引为index后的所有元素往后移，注意后移的起始位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt;= index; i--) &#123;</span><br><span class="line">            data[i + <span class="number">1</span>] = data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        data[index] = e;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取index索引位置的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断用户传进来的索引是否合法</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Add failed.Require index&gt;=0 and index&lt;size."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改index索引位置的元素为e</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, T e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断用户传进来的索引是否合法</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Add failed.Require index&gt;=0 and index&lt;size."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        data[index] = e;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从数组中删除元素e，如果数组中没有</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeElement</span><span class="params">(T e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = find(e);</span><br><span class="line">        <span class="keyword">while</span> (index != -<span class="number">1</span>) &#123;</span><br><span class="line">            remove(index);</span><br><span class="line">            index = find(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从数组中删除index位置的元素，返回删除的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断用户传进来的索引是否合法</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Add failed.Require index&gt;=0 and index&lt;size."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        T ret = data[index];</span><br><span class="line">        <span class="comment">//将索引为index后的所有元素往前移,注意前移的起始位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index + <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">            data[i - <span class="number">1</span>] = data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="comment">//最后的那个元素，还指着一个引用。所以不会被Java的内存回收机制回收</span></span><br><span class="line">        data[size] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//缩小数组容量</span></span><br><span class="line">        <span class="keyword">if</span> (size == data.length / <span class="number">2</span>)</span><br><span class="line">            resize(data.length / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从数组中删除第一个元素，返回删除的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">removefirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从数组中删除最后一个元素，返回删除的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> remove(size - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询数组中的所有元素,通过字符串拼接把数组输出</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        str.append(String.format(<span class="string">"array.Array:size=%d,capacity=%d\n"</span>, size, data.length));</span><br><span class="line">        str.append(<span class="string">"["</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            str.append(data[i]);</span><br><span class="line">            <span class="keyword">if</span> (i != size - <span class="number">1</span>)</span><br><span class="line">                str.append(<span class="string">","</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        str.append(<span class="string">"]"</span>);</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找数组中是否有元素e</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(T e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[i].equals(e)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找数组中第一个值为e的元素所在的索引，如果不存在元素e，则返回-1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(T e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[i] == e) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态数组扩容实现：</p>
<ol>
<li>新创建一个比原来数组容量更大的数组</li>
<li>把原数组的内容拷贝到新数组中</li>
<li>把数组变量指向新数组，然后原来的数组就会被自动回收</li>
</ol>
<h6 id="简单的-渐进-时间复杂度分析"><a href="#简单的-渐进-时间复杂度分析" class="headerlink" title="简单的(渐进)时间复杂度分析"></a>简单的(渐进)时间复杂度分析</h6><ul>
<li><p>O(1),O(n),O(lgn),O(nlogn),O(n^2)</p>
</li>
<li><p>大O描述的是算法的运行时间和输入数据之间的关系</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">        sum+=num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子的时间复杂度为O(n),n是nums中的元素个数。算法和n呈线性关系。</p>
<p>为什么要用大O，叫做O(n)?   忽略常数，实际时间T=c1*n+c2</p>
<p><span style="color:red">O(n)描述的是渐进时间复杂度：描述n趋近于无穷的情况。通常是考虑最坏的情况的时间复杂度</span></p>
<p>有些情况下可以利用参数较小的情况用于提高性能。如数组较小时采用插入排序提高性能</p>
</li>
</ul>
<p>自定义数组的时间复杂度</p>
<ul>
<li><p>增 O(n)</p>
</li>
<li><p>删 O(n)</p>
<p>如果只对最后一个元素操作，依然是O(n)?因为resize？</p>
</li>
<li><p>改 已知索引O(1);未知索引O(n)</p>
</li>
</ul>
<p>所以说数组最好适用于下标有语义的情况。</p>
<h6 id="均摊时间复杂度和防止时间复杂度震荡"><a href="#均摊时间复杂度和防止时间复杂度震荡" class="headerlink" title="均摊时间复杂度和防止时间复杂度震荡"></a>均摊时间复杂度和防止时间复杂度震荡</h6><p>一个耗时比较大的操作，但是不会每次都触发，就可以均摊到其它情况中。</p>
<hr>
<h2 id="数组类算法"><a href="#数组类算法" class="headerlink" title="数组类算法"></a><em>数组类算法</em></h2><p>&emsp;&emsp;如经典的排序问题，二分搜索……</p>
<p>如何判断重复？</p>
<p>很明显，将每个元素只出现一次的一次进行前移</p>
<p>给定的是一个排序的数组，证明值相同的元素都在一起</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Java</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>创建线程的方式</title>
    <url>/2019/06/13/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>经过对多线程的逐步了解，创建线程的方式有好多种，它们各有优劣。下面我来对这些创建方式做一个总结。</p>
<h3 id="一、实现Runnable接口"><a href="#一、实现Runnable接口" class="headerlink" title="一、实现Runnable接口"></a><span style="color:#4682B4">一、实现Runnable接口</span></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*MyThread*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		S  ystem.out.println(<span class="string">"实现Runnable接口创建的线程"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*Run.java*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		MyThread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(t);</span><br><span class="line">		t1.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二、继承Thread类"><a href="#二、继承Thread类" class="headerlink" title="二、继承Thread类"></a><span style="color:#4682B4">二、继承Thread类</span></h3> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*MyThread.java*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">super</span>.run();</span><br><span class="line">		System.out.println(<span class="string">"继承Thread创建的线程"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*Run.java*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		MyThread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">		t1.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>异常处理</title>
    <url>/2019/06/12/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>Java使用一种称为<strong>异常处理</strong>（exception handing）的错误捕获机制处理异常。</p>
<h4 id="一-异常分类"><a href="#一-异常分类" class="headerlink" title="一. 异常分类"></a>一. 异常分类</h4><img  src=http://www.plantuml.com/plantuml/svg/uqhEIImkLd2jI4ujACdCp-E2y4CoYlBB4vDoKg5yrwAY_28eEwWqhoGpDnLTYwS_GeGBhb_1faPN5ybuT0cmkN1fY2261MZoo3O10000>

<p>在<code>Java</code>程序设计语言中，异常对象都是派生于<code>Throwable</code>类的一个实例。但在下一层立即分解为两个分支：<code>Error</code>和<code>Exception</code>。</p>
<ol>
<li><p><code>Error</code>是在应用程序的控制和处理能力之外的系统错误，编译器不做检查，属于<span style="color:red">JVM</span>需要承担的责任。如内存不足等问题</p>
</li>
<li><p><code>Exception</code>是程序可以处理的异常。异常处理通常指针对这种异常类型的处理。</p>
<ul>
<li>RuntimeException：<span style="color:red">程序</span>应该负担的责任。</li>
<li>IOException：<span style="color:red">Java编译器</span>应该负担的责任。<span style="color:blue">只有这一种异常编译器会提示。</span></li>
</ul>
</li>
</ol>
<p>Java语言规范将派生于Error类或RuntimeException类的所有异常称为非受查（unchecked）异常，所有其他的异常称为受查（checked）异常。</p>
<p>当一个方法当中出现错误引发的异常之后，方法会创建异常对象，并且交付给运行时系统处理。</p>
<p>异常对象中一般会包括异常类型、以及异常出现时程序的状态。</p>
<p>当运行时系统捕获到异常，就进入捕获环节，运行时系统就会寻找合适的循环处理器。找到时执行相关操作后妥善退出，找不到就直接中止。</p>
<p>受查异常必须捕获或者声明抛出。</p>
<p>允许忽略非受查异常，不进行相关处理编译器也不会报错。</p>
<p>Java的<strong>异常处理机制</strong>通过五个关键字来实现：<code>try</code>、<code>catch</code>、<code>finally</code>、<code>throws</code>、<code>throws</code>。</p>
<p><img src="http://cdn1.hikariblog.cn/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%85%B3%E9%94%AE%E5%AD%97.png" alt=""></p>
<p>try必须和finally或者（0或多个）catch一起执行，try、catch、finally不可以单独执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnCheckedExceptionDemo</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number1;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number2;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">			System.out.print(<span class="string">"请输入整数1:"</span>);</span><br><span class="line">			number1 = scanner.nextInt();</span><br><span class="line">			System.out.print(<span class="string">"请输入整数2:"</span>);</span><br><span class="line">			number2 = scanner.nextInt();</span><br><span class="line">			System.out.println(<span class="string">"两个数的商为"</span> + (number1 / number2));</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"除数为0，出错"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在控制台输入number2的值为0，就会出现算术异常<code>java.lang.ArithmeticException</code>，该异常类继承于<code>RuntimeException</code>，属于非受查异常。catch捕获到异常，执行语句块输出异常信息，执行finally语句块</p>
<p><img src="http://cdn1.hikariblog.cn/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86_%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt=""></p>
<p>多重catch语句</p>
<p>return关键字在异常处理中的作用（返回值，程序终止）</p>
<p>注意到一个有趣的地方，当异常处理块中没有return语句时，还会继续执行下面的语句。</p>
<p>当return中有return语句时，会先执行finally中的语句再执行return语句</p>
<h5 id="再次抛出异常和异常链"><a href="#再次抛出异常和异常链" class="headerlink" title="再次抛出异常和异常链"></a>再次抛出异常和异常链</h5><ul>
<li>有时候我们会捕获一个异常后在抛出另一个异常，改变异常的类型（在catch语句块中有throw关键字抛出新异常）</li>
<li>顾名思义就是：将异常发生的原因一个传一个串起来，即把底层的异常信息传给上层，这样逐层抛出。</li>
</ul>
<p>异常处理的有关面试题：</p>
<ol>
<li><p>简述Java的异常体系。</p>
</li>
<li><p>什么是异常链？</p>
</li>
<li><p>throw和throws的区别？</p>
<p>throw是在方法体中明确地抛出一个异常。而throws是在方法声明时抛出抛出未被try-catch语句块捕获处理的异常。抛到调用该方法的方法中，由它来对异常进行进一步的处理。继续抛出，或者try-catch处理 。</p>
</li>
<li><p>final，finally，finalize的区别</p>
</li>
<li><p>Error和Exception的区别</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Java基础知识</tag>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title>包装类</title>
    <url>/2019/06/11/%E5%8C%85%E8%A3%85%E7%B1%BB/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;<code>Java</code>是一种面向对象语言，<code>Java</code>中的类把方法与数据连接在一起，构成了<strong>自包含式的处理单元</strong>。但是<code>Java</code>中不能定义基本类型对象，在对基本类型数据进行操作时便会出现大量重复的自定义方法。为了能将基本类型视为对象进行处理，并连接相关的方法，Java为所有的基本类型都提供一个与之对应的包装类（<code>wrapper</code>）。Java中所有的包装类都存在于<code>java.lang</code>包中。</p>
<p>对于包装类，有以下两点需要注意：</p>
<ul>
<li><span style="color:red">包装类为<code>final</code>类，不允许扩展，因此不能定义它们的子类。</span></li>
<li><span style="color:red">包装类中包装的基本类型的数据为常量，一旦构造了包装类，就不允许更改包装在其中的值。</span></li>
</ul>
<table>
    <caption>基本类型-对应包装器</caption>
    <tr>
        <th>基本类型</th>
        <td style="color:#0000CD">byte</td>
        <td style="color:#0000CD">short</td>
        <td style="color:#0000CD">int</td>
        <td style="color:#0000CD">long</td>
        <td style="color:#0000CD">float</td>
        <td style="color:#0000CD">double</td>
        <td>char</td>
        <td>boolean</td>
    </tr>
    <tr>
        <th>对应的包装类</th>
        <td style="color:#0000CD">Byte</td>
        <td style="color:#0000CD">Short</td>
        <td style="color:#0000CD">Integer</td>
        <td style="color:#0000CD">Long</td>
        <td style="color:#0000CD">Float</td>
        <td style="color:#0000CD">Double</td>
        <td>Character</td>
        <td>Boolean</td>
    </tr>
</table>

<p>&nbsp;&nbsp;&nbsp;&nbsp;其中，六种数值类型（四个整型，两个浮点型）对应的包装类都派生于公共的超类<span style="color:#0000CD"><code>java.lang.Number</code></span>。<code>Number</code>为抽象类，没有具体的方法实现。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;另外，除了以上基本类型对应的包装类。Java还提供<code>BigInteger</code>、<code>BigDecimal</code>这两个包装类，它们没有对相对应的基本类型，主要应用于高精度的运算，<code>BigInteger</code>支持任意精度的整数，<code>BigDecimal</code>支持任意精度带小数点的运算。</p>
<h4 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h4><p><strong>基本类型数据转换成对应包装类对象称为装箱；</strong></p>
<p><strong>包装类对象转换成对应基本类型数据称为拆箱。</strong></p>
<p>下面通过<code>int</code>类型和对应包装类<code>Integer</code>演示装箱、拆箱操作：</p>
<ol>
<li><p>装箱</p>
<ul>
<li>自动装箱</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">3</span>;</span><br><span class="line">Integer t=a;</span><br></pre></td></tr></table></figure>

<ul>
<li>手动装箱</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">3</span>;</span><br><span class="line">Integer t=<span class="keyword">new</span> Integer(a);</span><br></pre></td></tr></table></figure>
</li>
<li><p>拆箱</p>
<ul>
<li>自动拆箱</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer b=<span class="keyword">new</span> Integer(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">int</span> t=b;</span><br></pre></td></tr></table></figure>

<ul>
<li>手动拆箱</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer b=<span class="keyword">new</span> Integer(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">int</span> t=b.intValue();</span><br></pre></td></tr></table></figure>

<p>对自动装箱和自动拆箱操作进行反编译，得出下图结果：</p>
<p><img src="http://cdn1.hikariblog.cn/String%E4%B8%AD%E6%AF%94%E8%BE%83%E5%88%86%E6%9E%90%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt=""></p>
</li>
</ol>
<p>   &nbsp;&nbsp;&nbsp;&nbsp;由此可知，<span style="color:red">自动拆箱操作其实是隐式地执行<code>int t=b.intValue()</code>；自动装箱操作其实是隐式地执行<code>Integer t=Integer.valueOf(a)</code>。</span></p>
<p>   <code>Integer.valueOf()</code>方法的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>IntegerCache的</code>实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注意：为了避免频繁的创建和销毁对象而影响系统性能，自动装箱规范要求<code>boolean</code>、<code>byte</code>、<code>char</code>&lt;=127，介于[-128,127]之间的<code>short</code>和<code>int</code>被包装到固定的对象中，存储在一个缓存空间（称为对象常量池）中，从而实现了对象的共享。故<span style="color:red">当参数介于[-128,127]之间时</span>会直接引用对象常量池中的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer three=<span class="number">100</span>;</span><br><span class="line">System.out.println(<span class="string">"three==100的结果:"</span>+(three==<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">Integer four=<span class="number">100</span>;</span><br><span class="line">System.out.println(<span class="string">"three==four的结果:"</span>+(three=four));</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="http://cdn1.hikariblog.cn/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C_%E5%8C%85%E8%A3%85%E7%B1%BB.png" alt=""></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;第一个结果<code>true</code>是因为包装类对象<code>three</code>进行了自动拆箱，从而变成了两个基本类型数据100和100之间的比较。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;第二个<code>true</code>是因为<code>Java</code>对象常量池的实现，从而使three和four引用了对象常量池中的同一个对象。</p>
<p>注意：<span style="color:red">八种基本数据类型中，只有<code>float</code>和<code>double</code>对应的包装类没有应用对象常量池这个概念。</span><code>Java</code>的这种实现提高了效率，但是可能会让<code>==</code>得出我们不希望的结果，所以在对于两个包装类对象的比较时应调用<code>equals</code>方法。如果两个或其中一个包装类对象都是通过手动装箱（显式使用<code>new</code>关键字）创建的，那它们的存储地址肯定不一样，<code>==</code>比较的结果也为<code>false</code>；因为引用类型，<code>==</code>比较的是两个变量存储的对象引用是否相等，则实例对象的存储地址是否一致。</p>
<p>String中的==和equals的区别</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		String a = <span class="string">"abc"</span>;</span><br><span class="line">		String b = <span class="string">"abc"</span>;</span><br><span class="line">		String c = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">		System.out.println(<span class="string">"a和b的内容是否相同:"</span> + a.equals(b));</span><br><span class="line">		System.out.println(<span class="string">"a和c的内容是否相同:"</span> + b.equals(c));</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">"a和b的地址是否相同:"</span> + (a == b));</span><br><span class="line">		System.out.println(<span class="string">"a和c的地址是否相同:"</span> + (b == c));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="http://cdn1.hikariblog.cn/String%E4%B8%AD%E6%AF%94%E8%BE%83%E5%88%86%E6%9E%90%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt=""></p>
<p>这令我不能不想到包装类的对象常量池概念，但是字符串那么多组合方式感觉又不大可能。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;第一种方式是在常量池中拿对象，如果找不到就在常量池中创建一个字符串；第二种方式是直接在堆内存空间创建一个新的对象。目前获得的信息暂时是这样子，进一步了解之后再来更新。</p>
<h4 id="基本数据类型和字符串之间的装换"><a href="#基本数据类型和字符串之间的装换" class="headerlink" title="基本数据类型和字符串之间的装换"></a>基本数据类型和字符串之间的装换</h4><ol>
<li><p>基本数据类型转换成字符串。采用静态方法toString()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> t1=<span class="number">2</span>;</span><br><span class="line">String t2=Integer.toString(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串转换为基本数据类型。</p>
<ul>
<li><p>采用静态方法parseInt()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> t3=Integer.parseInt(t2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>采用静态方法valueOf()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> t4=Integer.valueOf(t2);</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ol>
<h4 id="包装类与基本数据类型的区别"><a href="#包装类与基本数据类型的区别" class="headerlink" title="包装类与基本数据类型的区别"></a>包装类与基本数据类型的区别</h4><p>主要可以从以下几个方面来说明：</p>
<p><strong>显而易见的区别：</strong></p>
<p>Java中只有八种基本类型不是对象，其余都是对象（包括包装类）。</p>
<p><strong>声明方式的不同：</strong></p>
<ol>
<li>基本类型无需通过<code>new</code>关键字来创建。</li>
<li>包装类对象需要通过<code>new</code>关键字来创建；即便是自动装箱操作，其底层原理也是通过<code>new</code>关键字创建的对象。</li>
</ol>
<p><strong>作为成员变量时的默认初始值：</strong></p>
<ol>
<li><p>基本数据类型</p>
<ul>
<li><p>数值类型</p>
<ul>
<li>整型：包括<code>byte</code>，<code>int</code>，<code>short</code>初始值为0；<code>long</code>初始值为0L。</li>
<li>浮点型：<code>float</code>初始值为0.0f；<code>double</code>初始值为0.0d。</li>
</ul>
</li>
<li><p>字符类型：<code>char</code>初始值为<code>&#39;\u0000&#39;</code>。</p>
</li>
<li><p>布尔类型：<code>boolean</code>初始值为<code>false</code>；</p>
</li>
</ul>
</li>
<li><p>包装类</p>
<ul>
<li>与其他的引用类型一样，默认初始值为<code>null</code>。</li>
</ul>
</li>
</ol>
<p><strong>使用上的不同：</strong></p>
<p>集合等泛型机制中的类型变量只能是包装类或其他引用类型，而不能是基本数据类型。</p>
<p><strong>存储方式及位置的不同：</strong></p>
<ol>
<li>基本类型变量是直接存储变量的值保存在栈中，能高效地进行存取。</li>
<li>包装类变量需要通过引用指向实例，具体的实例保存在堆中。</li>
</ol>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>包装类相关面试题目：</p>
<ol>
<li><p><code>int</code>和<code>Integer</code>的区别。</p>
</li>
<li><p><code>String</code> 转换成<code>Integer</code>的方式及原理。 </p>
</li>
<li><p><code>Integer</code>转换成<code>String</code>的方式和原理。</p>
<p>主要有以下三种方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer a=<span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//方式一、Integer类中的实例方法toString()</span></span><br><span class="line">String b=a.toString();</span><br><span class="line"><span class="comment">//方式二、Integer类中的静态方法Integer.toString(int i),Integer对象自动拆箱</span></span><br><span class="line">String c=Integer.toString(a);</span><br><span class="line"><span class="comment">//方式三、String类中的静态方法valueOf(Object obj)</span></span><br><span class="line">String d=String.valueOf(a);</span><br></pre></td></tr></table></figure>

<p>通过查看源码来分析其原理，方式一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> toString(value);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>很明显调用了方式二，故原理同方式二：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == Integer.MIN_VALUE)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"-2147483648"</span>;</span><br><span class="line">    <span class="keyword">int</span> size = (i &lt; <span class="number">0</span>) ? stringSize(-i) + <span class="number">1</span> : stringSize(i);</span><br><span class="line">    <span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[size];</span><br><span class="line">    getChars(i, size, buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里当<code>Integer</code>如果是<code>null</code>的话就会报空指针异常，因为会触发自动拆箱，调用<code>intValue</code>方法。</p>
<p>方式三：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (obj == <span class="keyword">null</span>) ? <span class="string">"null"</span> : obj.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：这里返回的是字符串<code>&quot;null&quot;</code>而不是<code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>



</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>包装类</tag>
        <tag>Java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>run和start方法的区别</title>
    <url>/2019/06/10/run%E5%92%8Cstart%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h5 id="面试题：run和start方法的区别"><a href="#面试题：run和start方法的区别" class="headerlink" title="面试题：run和start方法的区别"></a>面试题：<code>run</code>和<code>start</code>方法的区别</h5><p><code>run</code>方法和<code>start</code>方法是<code>java.lang.Thread</code>类中的两个方法。我们通过一个例子来分析它们的不同之处。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		Test a = <span class="keyword">new</span> Test() &#123;</span><br><span class="line">			<span class="comment">//重写Thread类的run方法，输出当前线程</span></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">				<span class="keyword">super</span>.run();</span><br><span class="line">				System.out.println(<span class="string">"current thread is:"</span> + Thread.currentThread().getName());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">//调用run方法</span></span><br><span class="line">		a.run();</span><br><span class="line">		<span class="comment">//中断执行4秒</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//调用start方法</span></span><br><span class="line">		a.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下图：</p>
<p><img src="http://cdn1.hikariblog.cn/run%E5%92%8Cstart%E6%96%B9%E6%B3%95.png" alt="run和start方法"></p>
<p><code>run</code>方法在主线程中执行，和普通的方法调用一样；而<code>start</code>方法在非<code>main</code>线程中执行，这中间发生了什么？</p>
<p>start方法的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * This method is not invoked for the main method thread or "system"</span></span><br><span class="line"><span class="comment">         * group threads created/set up by the VM. Any new functionality added</span></span><br><span class="line"><span class="comment">         * to this method in the future may have to also be added to the VM.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * A zero status value corresponds to state "NEW".</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Notify the group that this thread is about to be started</span></span><br><span class="line"><span class="comment">         * so that it can be added to the group's list of threads</span></span><br><span class="line"><span class="comment">         * and the group's unstarted count can be decremented. */</span></span><br><span class="line">        group.add(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            start0();</span><br><span class="line">            started = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                    group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">                <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">                  it will be passed up the call stack */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>主要内容就在于<code>start0</code>方法的调用，查看<code>start0</code>方法源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>native</code>关键字：使用native关键字说明这个方法是原生函数，也就是这个方法是用C/C++语言实现的，并且被编译成了DLL，由java去调用。其对应的源码可以到OpenJDK网站查看。</p>
<p>关于start0这里不做过多介绍，毕竟我不懂cpp，看了头痛。<code>start0</code>方法的主要任务的如下：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Thread#start()方法调用Thread#start0()方法，调用JVM_StartThread方法，创建一个子线程，然后在子线程中调用Thread#run()方法。</p>
<p><strong><span style="color:red">调用<code>start</code>方法会创建一个新的子线程并启动，在子线程中进行<code>run</code>方法的调用。</span></strong></p>
<p><strong><span style="color:red"><code>run</code>方法只是<code>Thread</code>的一个普通方法调用，还是在主线程中执行。</span></strong></p>
<h4 id="关于start方法的拓展"><a href="#关于start方法的拓展" class="headerlink" title="关于start方法的拓展"></a>关于start方法的拓展</h4><p>Java的线程是不允许启动两次的，当线程执行完<code>run</code>方法或主线程执行完<code>main</code>方法进入死亡状态就不能复生了。</p>
<p><img src="http://cdn1.hikariblog.cn/Java%E4%B8%AD%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.jpg" alt="Java线程状态"></p>
<p>故如果多次调用<code>start</code>方法，则会出现异常<code>Exception in thread &quot;main&quot; java.lang.IllegalThreadStateExceprion</code>。如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">				System.out.println(<span class="string">"线程启动"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		thread.start();</span><br><span class="line">		thread.start();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如图</p>
<p><img src="http://cdn1.hikariblog.cn/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt=""></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中==和equals和hashCode的区别</title>
    <url>/2019/06/10/Java%E4%B8%AD==%E5%92%8Cequals%E5%92%8ChashCode%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h4 id="运算符"><a href="#运算符" class="headerlink" title="==运算符"></a><span style="color:#CD0000">==运算符</span></h4><p>两种情况：</p>
<p>1）基本类型数据：比较两个变量中存储的值是否相等。</p>
<p>2）引用类型：比较两个变量存储的对象引用是否相等，则实例对象的存储地址是否一致。</p>
<h4 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a><span style="color:#CD0000">equals方法</span></h4><h5 id="Object类中的equals方法"><a href="#Object类中的equals方法" class="headerlink" title="Object类中的equals方法"></a>Object类中的equals方法</h5><p>​    <strong><code>Object</code>类中的<code>equals</code>方法用于检测一个对象是否等于另外一个对象。</strong>源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    分析可知，<code>Object</code>类中的<code>equals</code>方法判断两个对象是否具有相同的引用，如果两个对象有相同的引用，则判定它们相等；如果它们们存储的对象引用（对象的存储地址）一样，则它们指向同一个实例对象。这种比较是完全没有实际意义的，就像证明“你妈是你妈”一样荒唐。<span style="color:#00008B">实际情况下，对象的比较应该由内容导出，当两个对象中存储的指定内容一样。就判定它们相等。所以当需要进行对象的比较时，应该在自定义类中根据实际需求去重写<code>Object</code>类中的<code>equals</code>方法。</span></p>
<h5 id="以下情景没有重写equals方法的必要："><a href="#以下情景没有重写equals方法的必要：" class="headerlink" title="以下情景没有重写equals方法的必要："></a>以下情景没有重写equals方法的必要：</h5><ol>
<li>类的每一个实例都是固定唯一的，例如 <code>Thread</code> 这种代表活动实体而不是值的类。</li>
<li>类的实例之间没有比较内容相等的需要，则无需重写 <code>equals</code> 方法。</li>
<li>父类已经重写equals方法，且父类的 <code>equals</code> 方法实现适用于子类。</li>
<li>类是私有的或包级私有的，以及你可以确定它的 equals 方法永远不会被调用时。</li>
</ol>
<h5 id="完美equals方法的重写建议"><a href="#完美equals方法的重写建议" class="headerlink" title="完美equals方法的重写建议"></a>完美equals方法的重写建议</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 显式参数命名为otherObject，稍后需要将它转换成另一个叫做other的变量。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object otherObject)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 检测this和otherObject是否引用同一个对象，这条语句只是一个优化。实际上，这是一种经常采用的形式。因为计算这个等式要一个一个地比较类中的域所付出的代价小得多。 */</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>==otherObject)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 检测otherObject是否为null，如果为null，返回false。这项检测是很必要的。</span></span><br><span class="line">    <span class="keyword">if</span>(otherObject==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">/* optional:比较this与otherObject是否属于同一个类。如果equals的语义在每个子类中有所改变，就使用getClass检测: */</span></span><br><span class="line">    <span class="keyword">if</span>(getClass()!=otherObject.getClass())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">/* optional:如果所有的子类都拥有统一的语义，就使用instanceof检测: */</span></span><br><span class="line">    <span class="keyword">if</span>(!(otherObject <span class="keyword">instanceof</span> ClassName))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 将otherObject装换成相应的类类型变量：向下转型</span></span><br><span class="line">    ClassName other=（ClassName）otherObject；</span><br><span class="line"><span class="comment">/* 现在开始对所有需要比较的域进行比较了。使用==比较基本类型域，使用Objects.equals()比较对象域。如果所有的域都匹配，就返回true；否则返回false */</span></span><br><span class="line">    <span class="keyword">return</span> field1==other.field1&amp;&amp;Object.equals(field2,other.field2)&amp;&amp;···;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//提示：对于数组类型的域，可以使用静态的Array.equals方法检测相应的数据元素是否相等。为了防备field2和other.fiield2可能为null的情况，需要使用Objects.equals方法。如果两个参数都为null，Objects.equals(a,b)调用将返回true；如果其中一个参数为null，则返回false；否则，如果两个参数都不为null，则调用a.equals(b)。</span></span><br></pre></td></tr></table></figure>



<h4 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a><span style="color:#CD0000">hashCode方法</span></h4><p><strong>散列码（hash code）是由对象导出的一个整型值。</strong><code>Object</code>中的<code>hashCode</code>方法是由对象的存储地址导出的。所以和<code>equals</code>方法一样，当需要进行对象的比较时，应该在自定义类中根据实际需求去重写<code>Object</code>类中的<code>hashCode</code>方法。</p>
<h4 id="hashCode方法和equals方法的区别和使用场景"><a href="#hashCode方法和equals方法的区别和使用场景" class="headerlink" title="hashCode方法和equals方法的区别和使用场景"></a><span style="color:#CD0000">hashCode方法和equals方法的区别和使用场景</span></h4><h6 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h6><p>既然两个方法最后的作用都是用于对象的比较，那为什么还要同时存在呢？可以从两方面进行说明</p>
<ol>
<li><p>性能</p>
<p><strong><code>hashCode</code>效率高，<code>equals</code>效率低。</strong></p>
<p><code>equals</code>方法中封装着比较全面复杂的算法步骤，每次比较都需要进入方法中执行这些算法步骤，效率低下。</p>
<p><code>hashCode</code>方法则导出一个整型的散列码，将对象的比较转化成整型值的比较，效率较高。</p>
</li>
<li><p>可靠性</p>
<p><strong><code>equals</code>可靠，<code>hashCode</code>不可靠。</strong></p>
<p>用<code>equals</code>方法比较的两个对象相等，则这两个对象通过<code>hashCode</code>方法导出的散列码一样。</p>
<p>而当两个对象通过<code>hashCode</code>方法导出的散列码一致时，由<code>equals</code>方法判断两个对象不一定相等。</p>
</li>
</ol>
<h6 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h6><ol>
<li>当进行比较的对象的数量不多时，则直接使用<code>equals</code>方法进行比较。</li>
<li>当进行比较的对象的数量较多时，则先使用<code>hashCode</code>方法进行比较，如果散列码不相等，则两个对象肯定不相等，当散列码相等时，再调用<code>equals</code>进行比较，如果<code>equals</code>比较的出两个对象相等，则这两个对象就真的相等了。如不允许重复的集合在添加数据时，则会 执行这一步！！</li>
</ol>


<p><img src="http://cdn1.hikariblog.cn/%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8F%92%E5%85%A5.jpg" alt="不可重复集合对象的插入"></p>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a><span style="color:#CD0000">扩展</span></h4><p>阿里巴巴开发规范中明确规定：</p>
<p><img src="http://cdn1.hikariblog.cn/%E5%85%B3%E4%BA%8EhashCode%E5%92%8Cequals%E7%9A%84%E5%A4%84%E7%90%86.jpg" alt="关于hashCode和equals的处理"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven之仓库</title>
    <url>/2019/06/10/Maven%E4%B9%8B%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>防止数据库连接池泄露</title>
    <url>/2019/06/10/%E9%98%B2%E6%AD%A2%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%B3%84%E9%9C%B2/</url>
    <content><![CDATA[<p>官方文档：<a href="http://tomcat.apache.org/tomcat-8.5-doc/jndi-datasource-examples-howto.html#Preventing_database_connection_pool_leaks" target="_blank" rel="noopener">JDBC DataSources</a></p>
<p><img src="http://cdn1.hikariblog.cn/%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%96%87%E6%A1%A3.png" alt="连接池文档"></p>
<p>Web应用程序必须显式关闭ResultSet、Statement和Connection。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">free</span><span class="params">(ResultSet resultSet,Statement statemen,Connection connection)</span></span>&#123;   </span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(resultSet != <span class="keyword">null</span>)</span><br><span class="line">                resultSet.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(statemen != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    statemen.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(connection != <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            connection.close();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JDBC</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>Pro git</title>
    <url>/2019/06/05/Pro-git/</url>
    <content><![CDATA[<p>参考资料：<a href="http://iissnan.com/progit/" target="_blank" rel="noopener" title="Pro Git 简体中文版">Pro git</a></p>
<p><code>Git</code>仓库中的名为<code>.git</code>的目录，存放着所有<code>Git</code>需要的数据和资源。</p>
<p><code>README</code>文件：项目介绍文档（写给对项目有兴趣的人看的）</p>
<h4 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h4><p>&emsp;&emsp;版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。可对任何类型的文件进行版本控制。</p>
<p>&emsp;&emsp;分布式版本控制系统（ Distributed Version Control System，简称 DVCS ）面世了。在这类系统中，像 Git，Mercurial，Bazaar 以及 Darcs 等，客户端并不只提取最新版本的文件快照，<span style="color:red">而是把代码仓库完整地镜像下来</span>。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的提取操作，实际上都是一次对代码仓库的完整备份。</p>
<p>&emsp;&emsp;需要在 Windows 命令行中使用 Git 的用户，必须注意：在参数中间有空格的时候，必须使用双引号将参数括起来（在 Linux 中是单引号）；另外，如果扬抑符（^）作为参数的结尾，并且作为这一行的最后一个字符，则这个参数也需要用双引号括起来。因为扬抑符在 Windows 命令行中表示续行（译注：即下一行为这一行命令的继续）。</p>
<h4 id="一、取得项目的Git仓库"><a href="#一、取得项目的Git仓库" class="headerlink" title="一、取得项目的Git仓库"></a>一、取得项目的Git仓库</h4><p>&emsp;&emsp;有两种取得Git仓库的方法。第一种是在现存的目录下，通过导入所有所有文件来创建新的 Git 仓库。第二种是从已有的 Git 仓库克隆出一个新的镜像仓库来。</p>
<h6 id="在工作目录中初始化新仓库"><a href="#在工作目录中初始化新仓库" class="headerlink" title="在工作目录中初始化新仓库"></a>在工作目录中初始化新仓库</h6><p>&emsp;&emsp;对<u>现有的某个项目</u>开始用Git管理，只需到此项目所在的目录，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;初始化后，在当前目录下会生成一个名为<code>.git</code>的目录。</p>
<p>&emsp;&emsp;目前仅仅是按照既有的结构框架初始化好了里面所有的文件和目录，但我们还没有开始跟踪管理项目中的任何一个文件。</p>
<p>&emsp;&emsp;如果当前目录下有几个文件想要<strong>纳入版本控制</strong>，需要先用 <code>git add</code> 命令告诉 Git 开始对这些文件进行跟踪，然后提交：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add *.c</span><br><span class="line">$ git add README</span><br><span class="line">$ git commit -m <span class="string">'initial project version'</span></span><br></pre></td></tr></table></figure>

<hr>
<p>&emsp;&emsp;应用场景，如Blog向github备份项目每次都要执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">'~'</span>（项目版本）</span><br><span class="line">$ git push origin ~(要把项目提交到的分支名称)</span><br></pre></td></tr></table></figure>

 <!-- 因为github上面没有创建对应的远程仓库，所以先不研究git push命令 -->

<h6 id="从现有仓库克隆"><a href="#从现有仓库克隆" class="headerlink" title="从现有仓库克隆"></a>从现有仓库克隆</h6><p><strong>初次克隆某个仓库时，工作目录中的所有文件都属于已跟踪文件，且状态为未修改</strong></p>
<p>格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> [url]  [指定/新建的项目目录]</span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git://github.com/schacon/grit.git</span><br></pre></td></tr></table></figure>

<p>在当前目录下创建一个名为<code>grit</code>的目录，其中包含一个 <code>.git</code> 的目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git://github.com/schacon/grit.git mygrit</span><br></pre></td></tr></table></figure>

<p>在当前目录下创建一个名为<code>mygrit</code>的目录，其中包含一个<code>.git</code>的目录。</p>
<hr>
<p>&emsp;&emsp;Git 支持许多数据传输协议。之前的例子使用的是 <code>git://</code> 协议，不过你也可以用 <code>http(s)://</code> 或者 <code>user@server:/path.git</code> 表示的 SSH 传输协议。</p>
<h4 id="二、记录每次更新到仓库"><a href="#二、记录每次更新到仓库" class="headerlink" title="二、记录每次更新到仓库"></a>二、记录每次更新到仓库</h4><p>&emsp;&emsp;<code>git add</code> 的潜台词就是把目标文件快照放入暂存区域，也就是 add file into staged area，同时未曾跟踪过的文件标记为需要跟踪。</p>
<p>使用 Git 时的文件状态变化周期:</p>
<p><img src="http://cdn1.hikariblog.cn/Git-%E6%96%87%E4%BB%B6%E7%8A%B6%E6%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="File Statue Lifecycle"></p>
<p>相关的英语单词：</p>
<ol>
<li>track：跟踪</li>
<li>modify：修改</li>
<li>stage：暂存</li>
</ol>
<p>注意：已跟踪的文件，在修改后要提交需要再次执行<code>git add</code>将文件放进暂存区。</p>
<p>&emsp;&emsp;<code>git add</code> 命令（这是个多功能命令，根据目标文件的状态不同，此命令的效果也不同：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等）</p>
<p>注意：每次提交时<code>commit</code>对象保存的是已放进暂存区的文件，所以每次提交的时候尽量使用<code>git status</code>命令查看是否有将要保存的文件放入暂存区。</p>
<h6 id="忽略某些文件"><a href="#忽略某些文件" class="headerlink" title="忽略某些文件"></a>忽略某些文件</h6><p>&emsp;&emsp;一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。我们可以创建一个名为 <code>.gitignore</code> 的文件，列出要忽略的文件模式。</p>
<p>编写<code>.gitignore</code>文件的具体语法：<a href="http://iissnan.com/progit/html/zh/ch2_2.html" target="_blank" rel="noopener">http://iissnan.com/progit/html/zh/ch2_2.html</a></p>
<h6 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h6><p><code>git rm</code> ：将文件从已跟踪文件清单中移除（确切地说，是从暂存区域移除），<span style="color:red">并连带从工作目录中删除指定的文件。</span>如果不想删除目录中的文件而被老板炒鱿鱼，慎用。可通过配置<code>.gitignore</code>来忽略文件纳入版本管理。</p>
<h6 id="查看已暂存和未暂存的更新"><a href="#查看已暂存和未暂存的更新" class="headerlink" title="查看已暂存和未暂存的更新"></a>查看已暂存和未暂存的更新</h6><p><code>git diff</code>：工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。</p>
<p><code>git diff --staged</code>：已经暂存起来的文件和上次提交时的快照之间的差异。</p>
<h6 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h6><p>git commit`：将当前暂存区中的文件实际保存到仓库的历史记录中。</p>
<p>有以下两种提交方式：</p>
<ul>
<li>记述一行提交信息</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit -m <span class="string">"提交信息"</span></span><br></pre></td></tr></table></figure>

<ul>
<li>记述详细的提交信息</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit</span><br></pre></td></tr></table></figure>

<p>​    在<code>vim</code>编辑器中记述提交信息的格式如下：</p>
<p>​        第一行：用一行文字简述提交的更改内容。</p>
<p>​        第二行：空行。</p>
<p>​        第三行以后：记述更改的原因和详细内容。</p>
<p>​    这种情况如果将提交信息留空并直接关闭编辑器，这次提交就会被中止。</p>
<p>&emsp;&emsp;<code>Git</code> 提供了一个跳过使用暂存区域的方式，只要在提交的时候，给 <code>git commit</code> 加上 <code>-a</code> 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤。</p>
<h6 id="重命名文件"><a href="#重命名文件" class="headerlink" title="重命名文件"></a>重命名文件</h6><p><code>git mv [oldName] [newName]</code></p>
<h6 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h6><p>在输入 Git 命令的时候可以敲两次跳格键（Tab），就会看到列出所有匹配的可用命令建议。</p>
<p>一次跳格键（Tab）如果只有一个符合会自动补全。</p>
<h6 id="Git命令别名"><a href="#Git命令别名" class="headerlink" title="Git命令别名"></a>Git命令别名</h6><hr>
<h4 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a><code>Git</code>分支</h4><p>&emsp;&emsp;<span style="color:#d12573"><code>Git</code>保存的不是文件差异或者变化量，而只是一系列文件快照。</span>这句话有点不明白，如果是将文件整个保存，岂不是占大量存储空间，是不是还有将内容进行压缩？</p>
<p>&emsp;&emsp;<code>Pro Git</code>中是这样定义分支的，分支本质上仅仅是个指向<code>commit</code>对象的可变指针。切换分支之前，留心你的暂存区或者工作目录里，那些还没有提交的修改，它会和你即将检出的分支产生冲突从而阻止<code>Git</code>为你切换分支。切换分支的时候最好保持一个清洁的工作区域。通过<code>stashing</code> 和 <code>commit amending</code>两种方法之一可以绕过切换分支前对未提交内容的提交。</p>
<p>&emsp;&emsp;<code>Git</code>中通过<code>HEAD</code>指针指向你正在工作中的本地分支（译注：将<code>HEAD</code>想象为当前分支的别名。</p>
<p>创建一个新的分支：</p>
<p><code>git branch [branchName]</code></p>
<p>切换分支：</p>
<p><code>git checkout [branchName]</code></p>
<p>创建并切换到新分支：</p>
<p><code>git checkout -b [branchName]</code></p>
<p>合并指定分支到当前分支：</p>
<p><code>git merge [branchName]</code></p>
<p>&emsp;&emsp;如果顺着一个分支走下去可以到达另一个分支的话，那么 <code>Git</code> 在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为快进（<code>Fast forward</code>）。</p>
<p>删除指定分支：</p>
<p><code>git branch -d [branchname]</code></p>
<p>&emsp;&emsp;当出现合并冲突时，<code>Git</code>会在发生冲突的文件内容上自动作出标记，可以手动打开文件进行冲突处理。处理完冲突后使用<code>git add</code> 将把它们标记为已解决状态（译注：实际上就是来一次快照保存到暂存区域。），确认所有冲突都已解决，也就是进入了暂存区，就可以用 <code>git commit</code> 来完成这次合并提交。当然我们也可以安装一些处理合并冲突的<code>Git</code>插件。</p>
<p>显示所有的分支：</p>
<p><code>git branch</code></p>
<p>查看各个分支最后一个提交对象的信息：</p>
<p><code>git branch -v</code></p>
<p>查看哪些分支已被并入当前分支（译注：也就是说哪些分支是当前分支的直接上游。）</p>
<p><code>git branch --merge</code></p>
<p>查看尚未合并的工作：</p>
<p><code>git branch --no-merged</code></p>
<p>删除不包含未提交内容的分支：</p>
<p><code>git branch -d [branchName]</code></p>
<p>强制删除包含为提交内容的分支：</p>
<p><code>git branch -D [branchName]</code></p>
<p><span style="color:red">额，谷歌看一下有没有可以实时查看这些选项方法没有，大脑内存不足</span></p>
<p><span style="color:red">没错，是有的。比如，要学习config命令可以怎么用，运行：</span></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">help</span> config</span><br></pre></td></tr></table></figure>

<p><span style="color:red">会弹出对应命令的网页。</span>或者利用代码的自动补全功能查看选项的全称。</p>
]]></content>
      <categories>
        <category>VCS</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>Blog questions</title>
    <url>/2019/06/04/Blog-questions/</url>
    <content><![CDATA[<ol>
<li>正常的<code>MarkDown</code>语法下图片部署装换成HTML后无法显示</li>
</ol>
<p>参考文档：<a href="https://hexo.io/zh-cn/docs/asset-folders" target="_blank" rel="noopener">资源文件夹</a></p>
<p>原因：部署以后，图片会自动添加日期相关的文件结构目录</p>
<p><img src="http://cdn1.hikariblog.cn/image-1.png" alt=""></p>
<p>解决方案：</p>
<ul>
<li><p>将站点配置文件 <code>config.yml</code> 文件中的 <code>post_asset_folder</code> 选项设为 <code>true</code>：开启文章资源文件夹</p>
</li>
<li><p>在插入图片的时候不使用<code>MarkDown</code>语法（可能造成图片或其他资源显示不正确），而使用<code>Hexo 3</code>提供的相对路径引用的标签插件。</p>
</li>
<li><p>缺陷：因为不是<code>MarkDown</code>语法所以在编写文章的时候没办法预览。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% asset_path slug %&#125;</span><br><span class="line">&#123;% asset_img slug [title] %&#125;</span><br><span class="line">&#123;% asset_link slug [title] %&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>其他解决方案：可以利用插件<code>hexo-asset-image</code>实现<code>MarkDown</code>语法插入相对路径的图片。尝试多次以配置失败告终，若感兴趣可自行搜索。</p>
<ol start="2">
<li><p>在hexo中使用plantUML画图，要将(当然首先要下载插件配置好，自行搜索)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p>改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% plantuml %&#125;</span><br><span class="line">&#123;% endplantuml %&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这个目前有更好的解决办法，直接通过图床服务器存储图片，然后使用外链来引入图片，语法也不用改，直接使用Markdown的语法即可。</strong></p>
<p><strong>缓解了服务器加载图片的压力，七牛云图床服务器还有CDN加速，加快博客的加载！！我感觉需要自己写一个插件，在markdown传入图片的时候就把照片传上七牛云，七牛云存在一个Windows端的同步上传工具，允许将指定文件夹的内容同步上传到七牛云，所以我们只需要配置好Mrakdown编辑器拉进来的图片的保存位置即可，允许同名图片</strong></p>
<p><strong>可以把资源文件夹去掉了！！</strong></p>
</li>
<li><p>如何在<code>MarkDown</code>文档中实现首行缩进？</p>
</li>
</ol>
<p>日常写文章的时候都习惯性地每一个段落进行首行缩进，但是在MarkDown语法中却似乎没有内置段落首行缩进。这让我感到十分困扰。我尝试过用<code>HTML</code>和<code>CSS</code>来实现，如<code>&lt;p style=&quot;text-indent:2em&quot;&gt;&lt;/p&gt;</code>，但是在<code>HTML</code>块中没办法使用<code>MarkDown</code>语法进行加粗、下划线等操作。可以通过使用占位符来实现首行缩进：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&amp;ensp;或&amp;#8194; &#x2F;&#x2F;半角</span><br><span class="line">&amp;emsp;或&amp;#8195; &#x2F;&#x2F;全角   强烈推荐</span><br><span class="line">&amp;nbsp;或&amp;#160;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2019/05/29/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Maven之坐标、依赖</title>
    <url>/2019/05/29/Maven%E4%B9%8B%E5%9D%90%E6%A0%87%E3%80%81%E4%BE%9D%E8%B5%96/</url>
    <content><![CDATA[<h3 id="坐标-：唯一标识Java构件（artifact）"><a href="#坐标-：唯一标识Java构件（artifact）" class="headerlink" title="坐标 ：唯一标识Java构件（artifact）"></a><em>坐标 ：唯一标识Java构件（artifact）</em></h3><p>在Maven世界中，任何一个依赖、插件或者项目构建的输出，都可以称为 <em>构件</em></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.sonatype.nexus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nexus-indexer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>Maven项目的坐标与仓库路径以及文件名对应的关系：（以上述坐标为例，具体可到本地仓库查看引入的依赖目录）</em></p>
<blockquote>
<p>目录：<u>org/sonatype/nexus</u>/<u>nexus-indexer</u>/<u>2.0.0</u>/<strong>nexus-indexer-2.0.0.jar</strong></p>
<p>文件名规则：artifactId-version[-classifier].packaging，中括号表示可选</p>
</blockquote>
<h6 id="构成Maven坐标的一些元素"><a href="#构成Maven坐标的一些元素" class="headerlink" title="构成Maven坐标的一些元素"></a>构成Maven坐标的一些元素</h6><p>一个实际项目可拆分为多个Maven项目（模块）</p>
<ol>
<li><em>必须定义的元素</em></li>
</ol>
<ul>
<li><strong>groupId</strong>：公司或组织域名倒序.实际项目</li>
<li><strong>artifactId</strong>：实际项目-【模块（Maven项目）】</li>
<li><strong>version</strong>：版本</li>
</ul>
<ol start="2">
<li><em>可选的元素</em></li>
</ol>
<ul>
<li><p><strong>packaging</strong>：jar/war（默认为jar）</p>
<p><u>注意：packaging不一定与构件扩展名对应，比如packaging为maven.plugin的构件扩展名为jar。</u></p>
</li>
</ul>
<ol start="3">
<li>不能直接定义的元素</li>
</ol>
<ul>
<li><p><strong>classifier</strong>：该元素用来帮助定义构建输出的一些附属构件。</p>
<p><u>注意：不能直接定义项目的classifier，因为附属构件不是项目直接默认生成的，而是由插件帮助生成。</u></p>
</li>
</ul>
<hr>
<p><strong>依赖</strong>：</p>
<h6 id="依赖的配置"><a href="#依赖的配置" class="headerlink" title="依赖的配置"></a>依赖的配置</h6><p>根元素project下的deppendencies可以包含一个或者多个dependency元素，以声明一个或者多个项目依赖。每个依赖可以包含的元素有：</p>
<ul>
<li><strong>groupId、artifactId和version</strong>：依赖的基本坐标，对于任何一个依赖来说，基本坐标是最重要的，Maven根据坐标才能找到需要的依赖。</li>
<li><strong>type</strong>：依赖的类型，对应于项目坐标定义的packaging。大部分情况下，该元素不必声明，其默认值为jar。</li>
<li><strong>scope</strong>：依赖的范围。</li>
<li><strong>optional</strong>：标记依赖是否可选。</li>
<li><strong>exclusion</strong>：用来排除传递性依赖。</li>
</ul>
<p>大部分依赖声明只包含基本坐标，然而在一些特殊情况下，其他元素至关重要。</p>
<h6 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h6><p>&emsp;&emsp;Maven在编译项目主代码的时候需要使用一套classpath，Maven在编译和执行测试的时候会使用另一套classpath，实际运行Maven项目的时候，又会使用一套classpath。</p>
<p>&emsp;&emsp;依赖范围就是用来控制依赖与这三种classpath（编译classpath、测试classpath、运行classpath）的关系。</p>
<p>Maven有以下几种依赖范围：</p>
<ol>
<li>compile：编译依赖范围，对于三种classpath都有效。（默认使用）</li>
<li>test：测试依赖范围，值对于测试classpath有效。</li>
<li></li>
</ol>
<p><img src="http://cdn1.hikariblog.cn/%E4%BE%9D%E8%B5%96%E8%8C%83%E5%9B%B4%E5%92%8Cclasspath%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="依赖范围和classpath的关系"></p>
<h6 id="传递性依赖"><a href="#传递性依赖" class="headerlink" title="传递性依赖"></a>传递性依赖</h6><p><em>概念</em></p>
<p>A依赖B，B依赖C，A对于B是第一直接依赖，B对于C是第二直接依赖，A对于C是传递性依赖。这时Maven的传递性依赖机制会解析各个直接依赖的POM，将那些必要的间接依赖，以传递性依赖的形式引入到当前的项目中。</p>
<p><em>传递性依赖和依赖范围</em></p>
<p><img src="http://cdn1.hikariblog.cn/%E4%BE%9D%E8%B5%96%E8%8C%83%E5%9B%B4%E5%BD%B1%E5%93%8D%E4%BC%A0%E9%80%92%E6%80%A7%E4%BE%9D%E8%B5%96.png" alt="依赖范围影响传递性依赖"></p>
<p>仔细琢磨该表是有一定规律可循的，不必死记硬背。</p>
]]></content>
      <categories>
        <category>Mavan</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown的学习笔记</title>
    <url>/2019/05/27/Markdown%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Markdown的学习笔记"><a href="#Markdown的学习笔记" class="headerlink" title="Markdown的学习笔记"></a>Markdown的学习笔记</h1><p>参考自：<a href="http://www.markdown.cn/" target="_blank" rel="noopener" title="教程-MarkDown">MarkDown-语法说明</a></p>
<!-- 文章中的参考式链接管理 -->

<h4 id="Markdown介绍"><a href="#Markdown介绍" class="headerlink" title="Markdown介绍"></a>Markdown介绍</h4><p>一个Web上使用的文本到HTML的转换工具，可以通过简单、易读易写的文本格式生成结构化的HTML文档。</p>
<h4 id="Markdown和HTML的区别？"><a href="#Markdown和HTML的区别？" class="headerlink" title="Markdown和HTML的区别？"></a>Markdown和HTML的区别？</h4><p><u><strong>HTML 是一种发布的格式，Markdown 是一种书写的格式。</strong></u></p>
<p>也就是说Markdown到最后还是要装换成HTML才能呈现。那为什么还会有Markdown的出现呢？而且为什么会这么受人欢迎呢？那肯定是它有优于HTML的闪光点！！</p>
<ol>
<li><p><strong>Markdown只对应HTML的一小部分标记。（即纯文本可以涵盖的范围）</strong><br>当然会有程序员朋友觉得HTML的标记不难记，但是对于非程序员的用户他们的<u>关注点在于撰写的内容上</u>，并不想花费太多的时间去学习HTMl标记的语义，这时候Markdown的语法简单，但是学习成本低，容易上手。又能达到他们想要的效果，何乐不为呢！！</p>
</li>
<li><p>那问题又来了，Markdown对应的HTML标记那么少，有一些功能不能实现，需要用到Markdown涵盖范围之外的HTML标记呢？不用担心，<strong>Markdown兼容HTML,在Markdown环境下编写的HTML5代码也能实时转换成对应的格式。</strong><u>不在Markdown涵盖范围之内的标签，都可以直接在文档里面用HTML撰写。当然如果你乐意，在Markdown涵盖范围内的标签也可以直接用HTML标记来撰写。不过这就没意思啦</u></p>
<p>注意：在HTML区块标签间的Markdown格式语法将不会被处理。</p>
</li>
<li><p><strong>撰写过程中的直观性。</strong>不会像是由许多标签或是格式指令所构成，关注于内容本身，没有HTML的各种标签的干扰。排版格式良好、可</p>
</li>
<li><p>可读性强。</p>
<p><em>Markdown也是存在一些缺陷的，具体可以自己自行上网搜索。</em></p>
</li>
</ol>
<h4 id="Markdown的语法"><a href="#Markdown的语法" class="headerlink" title="Markdown的语法"></a>Markdown的语法</h4><h5 id="区段元素"><a href="#区段元素" class="headerlink" title="区段元素"></a>区段元素</h5><h6 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h6><ol>
<li><p>行内式</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">[<span class="string">链接文字</span>](<span class="link">网址链接 "Title"</span>)</span><br><span class="line">例：</span><br><span class="line">[<span class="string">我的博客</span>](<span class="link">https://forhcl.github.io/ "Hogan_Lee'note"</span>)</span><br></pre></td></tr></table></figure>

<p>效果展示：<a href="https://forhcl.github.io/" title="Hogan_Lee&#39;note">我的博客</a></p>
<p>注意：<code>&quot;Title&quot;</code>是可选的部分，对应<strong>HTML5</strong>的<code>&lt;a&gt;</code>标签的<code>title</code>属性。当写入<code>&quot;Title&quot;</code>后，鼠标在超链接上悬停时会把<code>Title</code>显示出来。一般将<code>Title</code>设置为链接对应网页的标题。</p>
</li>
<li><p>参考式</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">[<span class="string">链接文字</span>][<span class="symbol">辨识链接的标记</span>]</span><br><span class="line">然后，在文件的任意处，定义标记的链接内容</span><br><span class="line">[<span class="symbol">标记</span>]: <span class="link">网址链接  "Title"</span></span><br><span class="line">[<span class="symbol">标记</span>]: <span class="link">网址链接  'Title'</span></span><br><span class="line">[<span class="symbol">标记</span>]: <span class="link">网址链接  (Title)</span></span><br><span class="line">例子：</span><br><span class="line">[<span class="string">我的博客</span>][<span class="symbol">myBlog</span>]</span><br><span class="line">[<span class="symbol">myBlog</span>]: <span class="link">https://forhcl.github.io/ "Hogan_Lee'note"</span></span><br></pre></td></tr></table></figure>

<p>效果展示：<a href="https://forhcl.github.io/" title="Hogan_Lee&#39;note">我的博客</a></p>
<p><strong>隐式链接标记功能</strong>让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 “Google” 链接到 google.com，你可以简化成：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">Google</span>][<span class="symbol"></span>]</span><br></pre></td></tr></table></figure>

<p>然后定义链接内容：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="symbol">Google</span>]: <span class="link">http://google.com/</span></span><br></pre></td></tr></table></figure>

<p> 注意：</p>
<ul>
<li><p><code>Title</code> 依旧是可选的，可以用单引号、双引号或是括弧包着，三种标记的链接内容的定义都是相同的。当然也可以把title属性放到下一行。</p>
</li>
<li><p>辨识链接的标记不区分大小写。</p>
</li>
</ul>
<p><strong>行内式和参考式的比较</strong>：对于这两种定义链接的语法，给我最直观的感觉就是参考式对于链接的管理十分便捷。</p>
<h6 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h6><p>类似于链接的格式</p>
<ol>
<li><p>行内式</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">Alt text</span>](<span class="link">/path/to/img.jpg "Optional title"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>参考式</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">![<span class="string">Alt text</span>][<span class="symbol">id</span>]</span><br></pre></td></tr></table></figure>

<p>「id」是图片参考的名称，图片参考的定义方式则和连结参考一样：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">[<span class="symbol">id</span>]: <span class="link">url/to/image  "Optional title attribute"</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>注意：到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的<code>&lt;img&gt;</code>标签。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
