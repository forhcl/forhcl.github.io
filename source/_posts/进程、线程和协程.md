---
title: 进程、线程和协程
date: 2019-06-15 20:46:22
tags:
- Java
- 面试
- 多线程
categories: 多线程
---

相关面试题：

## 进程和线程的区别

#### 进程和线程的由来

{% plantuml %}

:串行处理;

:批处理;

:进程;

:线程;

{% endplantuml %}

+ 初期的计算机智能串行执行任务，并且需要长时间等待用户输入。
+ 预先将用户的指令集中成清单，批量串行处理用户指令，仍然无法并发执行。
+ 进程独占内存空间，保存各自的运行状态，相互间不干扰且可以互相切换，为并发处理任务提供了可能。
+ 共享进程的内存资源，相互间切换更快速，支持更细粒度的任务控制，使进程内的子任务得以并发执行。

#### 进程和线程的区别

__进程是系统资源分配和调度的最小单位，线程是CPU调度的最小单位。__

1. 线程不能看做独立的应用，而进程可看做独立应用。
2. 进程有独立的地址空间，相互不影响（其中一个进程挂了不影响程序），线程只是进程的不同执行路径（其中一个线程挂了，所在进程也就挂了），线程共享进程的内存空间。
3. 线程没有独立的地址空间，多进程的程序比多线程程序健壮。
4. 进程的切换比线程的切换开销大。效率低。
5. 进程是代码+数据集合，是代码在数据集合上的运行活动。
6. 进程是运行中的程序，而线程则是进程中的一个执行路径。

#### Java进程和线程的关系

{% asset_img 进程和线程的内存结构划分.jpg %}

如上图所示，Thread1到ThreadN这N个线程共享进程的堆和方法区资源，但是每个线程有自己的程序计数器（PC）和栈（stack）区域。

+ 其中PC计数器本质上是一块内存区域，用来记录线程当前要执行的指令地址，CPU一般是使用时间片轮转方式让线程轮询占用的，因此当前线程CPU时间片用完后，要让出CPU，这时PC计数器就会记录下当前线程下次要执行的命令的地址，等到下次轮到该线程占有CPU执行时，就从PC计数器获取自己将要执行的命令的地址继续执行。

+ 每个线程有自己的栈资源，用于存储该线程的局部变量，这些局部变量时该线程私有的，其它线程是访问不了的。另外，栈还用来存放线程的调用栈帧，如下代码，当我们调动test()方法时，就会把当前方法的一些信息封装为栈帧压入到栈顶，栈顶的栈帧就是活跃的test方法。当执行到say()方法时就会在栈顶新加一个关于say()方法的栈帧，这时候say()方法所在的栈帧就是活跃栈帧。当say()方法执行完毕后，say()方法所在栈顶帧就会出栈，这时候栈顶活跃帧就是test方法的了。

  ```java
  void test(int x,int y) {
      int a = 5;
      int b = 6;
      say();
  }
  ```

  

+ 堆（heap）是一个进程中最大的一块内存，是进程创建时候创建的，堆是被进程中的所有线程共享的。堆里面主要存放使用<span style="color:blue">new 操作创建的对象实例和基本类型的成员变量</span>，如下操作就是在堆上创建了一个 ArrayList 对象，这里需要注意的是，<span style="color:red">指向堆对象的 list 变量本身是在线程的栈上保存的</span>，只是 list 指向了堆上的 ArrayList 的地址。

  ```
  void test(int x,int y) {
      List<String> list = new ArrayList<String>();
  }
  ```

+ 方法区（method area）用来存放 JVM 加载的类信息、常量、静态变量等信息，也是线程共享的。

  

1. Java对操作系统提供的功能进行封装，包括进程和线程。
2. 运行一个程序会产生一个进程，进程至少包括一个线程；线程必须依托进程而存在，线程本身是不会独立存在的。
3. 每个进程对应一个JVM实例，多个进程共享JVM里的堆。
4. Java采用单线程编程模型，程序会自动创建主线程。
5. 主线程可以创建子线程，原则上要后于子线程完成执行。



## 说说进程，线程，协程之间的区别

## 为什么要有线程，而不是仅仅用进程？