---
title: 深入解析HashMap
date: 2019-07-22 17:01:13
tags:
- 集合
- Java
- HashMap
categories: Java
---

文章基于Java1.8版本，Java1.8相对于Java1.7版本对 `HashMap` 进行了一些优化。

&emsp;&emsp;`HashMap` 最擅长的事情就是<span style="color:#2E8B57">快速索引</span>。

### 数据结构HashMap

&emsp;&emsp;`HashMap`是一个存放数据的容器，`HashMap` 为了达到它快速索引的目的，利用了数组快速定位的特性。建立插入值和数组所在坐标之间的关系，pos=key%size（key为插入的值，size为数组的长度），假设存在以下长度为10的Integer数组，当key的值为21，求模之后为1，就将它存放在下标为1的位置，以此类推。当求模之后的值一样，则出现哈希冲突。

![](http://cdn1.hikariblog.cn/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90HashMap_%E5%9B%BE%E7%89%871.png)

通过扩展单链表来解决冲突

![](http://cdn1.hikariblog.cn/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90HashMap_%E5%9B%BE%E7%89%872.png)

当为解决哈希冲突延伸出来的单链表越来越长时，定位的时候首先还是定位到对应的下标，然后遍历单链表进行对比数值，时间复杂度为O(n)。不能满足快速定位的目的。所以JDK1.8又引入了红黑树(一种特殊的二叉树查询效率依赖的树的深度)的数据结构，当单链表过长的时候，将单链表转换为红黑树以提高查询的性能。

+ HashMap的数据结构包括了初始数组、链表、红黑树；
+ 插入数据的时候使用key%size来进行插入数据；
+ 当两个或者两个以上的pos=key的pos相同时而key值不同的时候（发生冲突），就会挂在数组初始化位置的链表后
+ 当节点后出现过多的链表节点的时候，就会转换成红黑树以提高效率。

### HashMap源码分析

初始容量为2的倍数

避免空间碎片，提高散列度，避免冲突