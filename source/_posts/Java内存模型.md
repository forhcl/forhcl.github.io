---

title: Java内存模型
date: 2019-07-09 08:59:07
tags:
- Java内存模型
- JVM
- 并发编程
- 面试
categories: Java
---

Java多线程之间进行通信是基于共享内存的。下面我们就来了解以下Java中多线程处理共享变量时的内存模型。

&emsp;&emsp;Java内存模型（Java Memory Model，JMM）和JVM的内存结构完全是两码事，请不要混淆。其实JMM并不像JVM内存结构一样是真实存在的。它只是一个抽象的概念。大多数人一听到JMM，脑海里浮现的就是JVM内存区域的堆、虚拟机栈、本地方法栈、方法区……其实这两者并不是同一层次的内存划分，基本上是没有关系的。唯一的相似点就是都存在共享区域和私有区域

![](http://cdn1.hikariblog.cn/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%88%92%E5%88%86.jpg)

<span style="color:#2251a3">可以将“内存模型”理解为在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。</span>

![](http://cdn1.hikariblog.cn/%E5%A4%84%E7%90%86%E5%99%A8%E3%80%81%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E3%80%81%E4%B8%BB%E5%86%85%E5%AD%98%E9%97%B4%E7%9A%84%E4%BA%A4%E4%BA%92%E5%85%B3%E7%B3%BB.png)

但实际上JMM并不是“Java内存区域划分”；JMM是与并发编程相关的，它是一种符合内存模型规范的，屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存效果。目的是解决由于多线程通过共享内存进行通信时，存在的<span style="color:red">原子性、可见性（缓存一致性）以及有序性</span>问题。

&emsp;&emsp;Java内存模型规定了所有的变量（这里的变量包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的）都存放在主存中，当线程使用变量时都是把主存中的变量拷贝到自己的工作内存中，线程读写变量的时候操作的是自己工作内存中的变量。

![线程、主内存、工作内存三者的交互关系](http://cdn1.hikariblog.cn/%E7%BA%BF%E7%A8%8B%E3%80%81%E4%B8%BB%E5%86%85%E5%AD%98%E3%80%81%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98%E4%B8%89%E8%80%85%E7%9A%84%E4%BA%A4%E4%BA%92%E5%85%B3%E7%B3%BB.png)

__主内存__

+ 存储Java实例对象
+ 包括成员变量、类信息、常量、静态变量等
+ 属于数据共享的区域，多线程并发操作时会引发线程安全问题

__工作内存__

+ 存储当前方法的所有本地变量信息，本地变量对其他线程不可见
+ 字节码行号指示器、Native方法信息
+ 属于线程私有的数据区域，不存在线程安全问题

__主内存与工作内存的数据存储类型以及操作方式归纳__

- 方法里的基本数据类型本地变量将直接存储在工作内存的栈帧结构中
- 引用类型的局部变量：引用存储在工作内存中，实例存储在主内存中
- 成员变量(基本数据类型&&引用类型)、static变量、类信息均会被存储在主内存中
- 主内存共享的方式是线程各拷贝一份数据到工作内存，操作完成后刷新回主内存。

&emsp;&emsp;当一个线程操作共享变量的时候，会进行以下三步操作：

1. __当前线程首先从主存拷贝共享变量到自己的共享内存；__
2. __然后对工作内存里的变量进行处理；__
3. __处理完后更新变量值到主存。__

------

&emsp;&emsp;因为当一个线程操作共享变量的时候是分为三部分操作，而Java采用的是时间片轮转的线程调度算法，可能执行了两步操作后时间片用完就切换给另一个线程执行，故这三步操作不具有原子性，所以会造成共享变量的内存不可见问题，具体是当线程A修改了共享变量，并且还没刷新修改后的值到主存的时候，线程B从主内存获取了修改前的值，这时候线程A修改过的值对线程B来说就是不可见的。



### JMM如何解决可见性问题

指令重排序需要满足的条件

+ 在单线程环境下不能改变程序运行的结果

+ 存在数据依赖关系的不允许重排序

  总结：无法通过happens-before原则推导出来的，才能进行指令的重排序。

A操作的结果需要对B操作可见，则A与B存在happens-before关系。

```java
i=1;//线程A执行
j=i;//线程B执行
```

__happens-before的八大规则__

1. 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；
2. 锁定规则：一个unLock操作先行于后面对同一个锁的lock操作；
3. volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；
4. 传递规则：如果操作A先行与操作B，而操作A又先行于操作C，则可以得出操作A先行发生于操作C；
5. 线程启动规则：Thread对象的start()方法先行于此线程的每一个动作。
6. 线程中断规则：对线程interrupt()方法的调用先行发生于被终端线程的代码检测到中断事件的发生；
7. 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值检测到线程已经终止执行。
8. 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始。

__happens_before的概念__

&emsp;&emsp;如果两个操作部满足上述任意一个happens-before规则，那么这两个操作就没有顺序的保障，JVM可以对这两个操作进行重排序；

&emsp;&emsp;如果操作A happens-before操作B，那么操作A在内存上所做的操作对操作B都是可见的。

__volatile：JVM提供的轻量级同步机制__

+ 保证被volatile修饰的共享变量对所有线程总是可见的

  当写一个volatile变量时，JMM会把该线程对应的工作内存中的共享变量值刷新到主内存中

  当读取一个volatile变量时，JMM会把该线程对应的工作内存置为无效。

+ 禁止指令重排序优化

  内存屏障

  1. 保证特定操作的执行顺序
  2. 保证某些变量的内存可见性

  通过插入内存屏障指令禁止在内存屏障前后的指令执行重排序优化。

  强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本

